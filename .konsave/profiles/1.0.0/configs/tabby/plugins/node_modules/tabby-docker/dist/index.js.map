{"version":3,"sources":["webpack-tabby-docker:///webpack/universalModuleDefinition","webpack://tabby-docker/./src/components/dockerProfileSettings.component.pug?c853","webpack://tabby-docker/./src/components/dockerSettingsTab.component.pug?e959","webpack-tabby-docker:///./node_modules/asn1/lib/ber/errors.js","webpack-tabby-docker:///./node_modules/asn1/lib/ber/index.js","webpack-tabby-docker:///./node_modules/asn1/lib/ber/reader.js","webpack-tabby-docker:///./node_modules/asn1/lib/ber/types.js","webpack-tabby-docker:///./node_modules/asn1/lib/ber/writer.js","webpack-tabby-docker:///./node_modules/asn1/lib/index.js","webpack-tabby-docker:///./src/components/dockerProfileSettings.component.ts","webpack-tabby-docker:///./src/components/dockerSettingsTab.component.ts","webpack-tabby-docker:///./src/components/dockerTab.component.ts","webpack-tabby-docker:///./src/config.ts","webpack-tabby-docker:///./src/index.ts","webpack-tabby-docker:///./src/profiles.ts","webpack-tabby-docker:///./src/recoveryProvider.ts","webpack-tabby-docker:///./src/services/docker.service.ts","webpack-tabby-docker:///./src/session.ts","webpack-tabby-docker:///./src/settings.ts","webpack-tabby-docker:///./node_modules/bcrypt-pbkdf/index.js","webpack-tabby-docker:///./node_modules/bl/BufferList.js","webpack-tabby-docker:///./node_modules/bl/bl.js","webpack-tabby-docker:///./node_modules/chownr/chownr.js","webpack-tabby-docker:///./node_modules/core-util-is/lib/util.js","webpack-tabby-docker:///./node_modules/debug/src/browser.js","webpack-tabby-docker:///./node_modules/debug/src/debug.js","webpack-tabby-docker:///./node_modules/debug/src/index.js","webpack-tabby-docker:///./node_modules/debug/src/node.js","webpack-tabby-docker:///./node_modules/docker-modem/lib/http.js","webpack-tabby-docker:///./node_modules/docker-modem/lib/http_duplex.js","webpack-tabby-docker:///./node_modules/docker-modem/lib/modem.js","webpack-tabby-docker:///./node_modules/docker-modem/lib/ssh.js","webpack-tabby-docker:///./node_modules/docker-modem/lib/utils.js","webpack-tabby-docker:///./node_modules/dockerode/lib/config.js","webpack-tabby-docker:///./node_modules/dockerode/lib/container.js","webpack-tabby-docker:///./node_modules/dockerode/lib/docker.js","webpack-tabby-docker:///./node_modules/dockerode/lib/exec.js","webpack-tabby-docker:///./node_modules/dockerode/lib/image.js","webpack-tabby-docker:///./node_modules/dockerode/lib/network.js","webpack-tabby-docker:///./node_modules/dockerode/lib/node.js","webpack-tabby-docker:///./node_modules/dockerode/lib/plugin.js","webpack-tabby-docker:///./node_modules/dockerode/lib/secret.js","webpack-tabby-docker:///./node_modules/dockerode/lib/service.js","webpack-tabby-docker:///./node_modules/dockerode/lib/task.js","webpack-tabby-docker:///./node_modules/dockerode/lib/util.js","webpack-tabby-docker:///./node_modules/dockerode/lib/volume.js","webpack-tabby-docker:///./node_modules/end-of-stream/index.js","webpack-tabby-docker:///./node_modules/fs-constants/index.js","webpack-tabby-docker:///./node_modules/inherits/inherits.js","webpack-tabby-docker:///./node_modules/inherits/inherits_browser.js","webpack-tabby-docker:///./node_modules/isarray/index.js","webpack-tabby-docker:///./node_modules/mkdirp-classic/index.js","webpack-tabby-docker:///./node_modules/ms/index.js","webpack-tabby-docker:///./node_modules/once/once.js","webpack-tabby-docker:///./node_modules/process-nextick-args/index.js","webpack-tabby-docker:///./src/components/dockerProfileSettings.component.pug","webpack-tabby-docker:///./src/components/dockerSettingsTab.component.pug","webpack-tabby-docker:///./node_modules/pug-runtime/index.js","webpack-tabby-docker:///./node_modules/pump/index.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/_stream_duplex.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/_stream_passthrough.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/_stream_readable.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/_stream_transform.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/_stream_writable.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/internal/streams/BufferList.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/internal/streams/destroy.js","webpack-tabby-docker:///./node_modules/readable-stream/lib/internal/streams/stream.js","webpack-tabby-docker:///./node_modules/readable-stream/readable.js","webpack-tabby-docker:///./node_modules/safe-buffer/index.js","webpack-tabby-docker:///./node_modules/safer-buffer/safer.js","webpack-tabby-docker:///./node_modules/shell-quote/index.js","webpack-tabby-docker:///./node_modules/slugify/slugify.js","webpack-tabby-docker:///./node_modules/split-ca/index.js","webpack-tabby-docker:///./node_modules/ssh2-streams/index.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/buffer-helpers.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/constants.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/jsbn.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/keyParser.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/node-fs-compat.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/sftp.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/ssh.js","webpack-tabby-docker:///./node_modules/ssh2-streams/lib/utils.js","webpack-tabby-docker:///./node_modules/ssh2/lib/Channel.js","webpack-tabby-docker:///./node_modules/ssh2/lib/SFTPWrapper.js","webpack-tabby-docker:///./node_modules/ssh2/lib/agent.js","webpack-tabby-docker:///./node_modules/ssh2/lib/buffer-helpers.js","webpack-tabby-docker:///./node_modules/ssh2/lib/client.js","webpack-tabby-docker:///./node_modules/ssh2/lib/http-agents.js","webpack-tabby-docker:///./node_modules/ssh2/lib/keepalivemgr.js","webpack-tabby-docker:///./node_modules/ssh2/lib/server.js","webpack-tabby-docker:///./node_modules/streamsearch/lib/sbmh.js","webpack-tabby-docker:///./node_modules/string_decoder/lib/string_decoder.js","webpack-tabby-docker:///./node_modules/tar-fs/index.js","webpack-tabby-docker:///./node_modules/tar-stream/extract.js","webpack-tabby-docker:///./node_modules/tar-stream/headers.js","webpack-tabby-docker:///./node_modules/tar-stream/index.js","webpack-tabby-docker:///./node_modules/tar-stream/pack.js","webpack-tabby-docker:///./node_modules/tweetnacl/nacl-fast.js","webpack-tabby-docker:///./node_modules/util-deprecate/node.js","webpack-tabby-docker:///./node_modules/uuid/index.js","webpack-tabby-docker:///./node_modules/uuid/lib/bytesToUuid.js","webpack-tabby-docker:///./node_modules/uuid/lib/rng.js","webpack-tabby-docker:///./node_modules/uuid/v1.js","webpack-tabby-docker:///./node_modules/uuid/v4.js","webpack-tabby-docker:///./node_modules/wrappy/wrappy.js","webpack-tabby-docker:///external \"@angular/common\"","webpack-tabby-docker:///external \"@angular/core\"","webpack-tabby-docker:///external \"@angular/forms\"","webpack-tabby-docker:///external \"@ng-bootstrap/ng-bootstrap\"","webpack-tabby-docker:///external \"assert\"","webpack-tabby-docker:///external \"buffer\"","webpack-tabby-docker:///external \"child_process\"","webpack-tabby-docker:///external \"constants\"","webpack-tabby-docker:///external \"crypto\"","webpack-tabby-docker:///external \"dns\"","webpack-tabby-docker:///external \"events\"","webpack-tabby-docker:///external \"fs\"","webpack-tabby-docker:///external \"http\"","webpack-tabby-docker:///external \"https\"","webpack-tabby-docker:///external \"net\"","webpack-tabby-docker:///external \"os\"","webpack-tabby-docker:///external \"path\"","webpack-tabby-docker:///external \"querystring\"","webpack-tabby-docker:///external \"rxjs\"","webpack-tabby-docker:///external \"stream\"","webpack-tabby-docker:///external \"string_decoder\"","webpack-tabby-docker:///external \"tabby-core\"","webpack-tabby-docker:///external \"tabby-settings\"","webpack-tabby-docker:///external \"tabby-terminal\"","webpack-tabby-docker:///external \"tty\"","webpack-tabby-docker:///external \"url\"","webpack-tabby-docker:///external \"util\"","webpack-tabby-docker:///external \"zlib\"","webpack-tabby-docker:///webpack/bootstrap","webpack-tabby-docker:///webpack/startup"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA,UAAU,mBAAO,CAAC,0LAAuJ;AACzK,uD;;;;;;;;;;ACDA,UAAU,mBAAO,CAAC,kLAAmJ;AACrK,uD;;;;;;;;;;ACDA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACZA;;AAEA,aAAa,mBAAO,CAAC,uDAAU;AAC/B,YAAY,mBAAO,CAAC,qDAAS;;AAE7B,aAAa,mBAAO,CAAC,uDAAU;AAC/B,aAAa,mBAAO,CAAC,uDAAU;;;AAG/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1BA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,sFAA8B;;AAE3C,WAAW,mBAAO,CAAC,qDAAS;AAC5B,aAAa,mBAAO,CAAC,uDAAU;;;AAG/B;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC,CAAC;;AAED;AACA;AACA,oBAAoB,uBAAuB;AAC3C,CAAC;;AAED;AACA,oBAAoB,oCAAoC;AACxD,CAAC;;AAED;AACA,oBAAoB,wCAAwC;AAC5D,CAAC;;;AAGD;AACA,2CAA2C;AAC3C;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,UAAU;AAC7B;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;;AAE5C;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;ACrQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,sFAA8B;AAC3C,WAAW,mBAAO,CAAC,qDAAS;AAC5B,aAAa,mBAAO,CAAC,uDAAU;;;AAG/B;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;;AAIA;;AAEA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,GAAG;AACvB;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;;AAEA;;;;;;;;;;;AC5TA;;AAEA;AACA;;AAEA,UAAU,mBAAO,CAAC,yDAAa;;;;AAI/B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA,sEAAsE;AACtE,yEAAyC;AACzC,yEAAsE;AAEtE,mHAA4E;AAE5E,cAAc;AAId,IAAa,8BAA8B,GAA3C,MAAa,8BAA8B;IAMvC,YACI,MAAqB,EACb,QAAyB;QAAzB,aAAQ,GAAR,QAAQ,CAAiB;QANrC,WAAM,GAAY,EAAE;QACpB,eAAU,GAAgB,EAAE;QAC5B,cAAS,GAAG,OAAO;QAMf,MAAM,CAAC,cAAc,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;YACtC,IAAI,CAAC,UAAU,GAAG,UAAU;YAC5B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACxE,CAAC,CAAC;QACF,MAAM,CAAC,UAAU,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE;YAC9B,IAAI,CAAC,MAAM,GAAG,MAAM;YACpB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;QAC1E,CAAC,CAAC;IACN,CAAC;IAED,QAAQ;QACJ,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,EAAE;YACpC,IAAI,CAAC,SAAS,GAAG,WAAW;SAC/B;IACL,CAAC;IAED,eAAe;QACX,IAAI,IAAI,CAAC,SAAS,KAAK,WAAW,EAAE;YAChC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;SACtC;aAAM;YACH,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI;YACvC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,GAAG,IAAI;SAC5C;IACL,CAAC;IAED,mBAAmB;;QACf,OAAO,sBAAI,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,KAAK,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,0CAAE,WAAW,mCAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,mCAAI,cAAc;IACtI,CAAC;IAEK,SAAS;;YACX,MAAM,GAAG,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,EAAE,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;gBACzE,MAAM,EAAE,GAAG;gBACX,IAAI,EAAE,GAAG,CAAC,WAAW;gBACrB,WAAW,EAAE,GAAG,CAAC,WAAW,KAAK,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;aAC1D,CAAC,CAAC,CAAC;YACJ,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,GAAG,GAAG,CAAC,EAAE;QACzC,CAAC;KAAA;IAED,gBAAgB;QACZ,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,GAAG,IAAI;IAC3C,CAAC;CACJ;AAnDY,8BAA8B;IAH1C,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,mGAAuC,CAAC;KAC7D,CAAC;qCAQc,8BAAa;QACH,4BAAe;GAR5B,8BAA8B,CAmD1C;AAnDY,wEAA8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACV3C,yEAAsD;AACtD,gHAAuD;AACvD,yEAAyD;AAEzD,cAAc;AAId,IAAa,0BAA0B,GAAvC,MAAa,0BAA2B,SAAQ,0BAAa;IAIzD,YACW,MAAqB,EACpB,MAAqB;QAE7B,KAAK,EAAE;QAHA,WAAM,GAAN,MAAM,CAAe;QACpB,WAAM,GAAN,MAAM,CAAe;QAJjC,cAAS,GAAG,KAAK;QAOb,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAS,EAAE;YAC1D,IAAI,CAAC,SAAS,GAAG,KAAK;YACtB,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE;YAClC,IAAI,CAAC,SAAS,GAAG,IAAI;QACzB,CAAC,EAAC;IACN,CAAC;CACJ;AAdqC;IAAjC,kBAAW,CAAC,mBAAmB,CAAC;;wDAAK;AAD7B,0BAA0B;IAHtC,gBAAS,CAAC;QACP,QAAQ,EAAE,mBAAO,CAAC,2FAAmC,CAAC;KACzD,CAAC;qCAMqB,0BAAa;QACZ,8BAAa;GANxB,0BAA0B,CAetC;AAfY,gEAA0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRvC,sEAAsE;AACtE,yEAAmD;AACnD,uDAA4B;AAC5B,qFAAyD;AAEzD,4EAA0C;AAE1C,cAAc;AAOd,IAAa,kBAAkB,GAA/B,MAAa,kBAAmB,SAAQ,yCAAwB;IAI5D,qEAAqE;IACrE,YACI,QAAkB;QAElB,KAAK,CAAC,QAAQ,CAAC;QANnB,YAAO,GAAuB,IAAI;IAOlC,CAAC;IAED,QAAQ;QACJ,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,WAAW,CAAC;QAE1C,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE;YACxD,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;gBAChB,OAAM;aACT;YACD,QAAQ,MAAM,EAAE;gBACZ,KAAK,MAAM;oBACP,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;oBACxB,MAAK;gBACT,KAAK,KAAK;oBACN,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC;oBACxB,MAAK;aACZ;QACL,CAAC,CAAC;QAEF,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,YAAK,EAAE,CAAC,CAAC,SAAS,CAAC,GAAG,EAAE;YAC7C,IAAI,CAAC,iBAAiB,EAAE;QAC5B,CAAC,CAAC;QAEF,KAAK,CAAC,QAAQ,EAAE;QAEhB,YAAY,CAAC,GAAG,EAAE;YACd,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAQ,CAAC,IAAI,CAAC;QACrC,CAAC,CAAC;IACN,CAAC;IAEK,iBAAiB;;YACnB,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBACf,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,0BAA0B,CAAC;gBAC7C,OAAM;aACT;YAED,MAAM,OAAO,GAAG,IAAI,uBAAa,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,OAAO,CAAC;YAC9D,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC;YAE9B,IAAI,CAAC,YAAY,CAAC,YAAY,CAAC;YAE/B,IAAI;gBACA,MAAM,IAAI,CAAC,OAAQ,CAAC,KAAK,EAAE;gBAC3B,IAAI,CAAC,WAAW,EAAE;aACrB;YAAC,OAAO,CAAC,EAAE;gBACR,IAAI,CAAC,WAAW,EAAE;gBAClB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,GAAG,MAAM,CAAC;gBAC9B,OAAM;aACT;YACD,IAAI,CAAC,OAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;QAC3D,CAAC;KAAA;IAEK,gBAAgB;;;YAClB,OAAO;gBACH,IAAI,EAAE,gBAAgB;gBACtB,OAAO,EAAE,IAAI,CAAC,OAAO;gBACrB,UAAU,EAAE,UAAI,CAAC,QAAQ,0CAAE,SAAS,EAAE;aACzC;;KACJ;CACJ;AApEY,kBAAkB;IAN9B,gBAAS,CAAC;QACP,QAAQ,EAAE,YAAY;QACtB,QAAQ,EAAE,yCAAwB,CAAC,QAAQ;QAC3C,MAAM,EAAE,yCAAwB,CAAC,MAAM;QACvC,UAAU,EAAE,yCAAwB,CAAC,UAAU;KAClD,CAAC;qCAOgB,eAAQ;GANb,kBAAkB,CAoE9B;AApEY,gDAAkB;;;;;;;;;;;;;;;ACd/B,yEAA2C;AAE3C,cAAc;AACd,MAAa,oBAAqB,SAAQ,2BAAc;IAAxD;;QACI,aAAQ,GAAG;YACP,MAAM,EAAE;gBACJ,IAAI,EAAE,IAAI;gBACV,IAAI,EAAE,IAAI;gBACV,MAAM,EAAE,IAAI;aACf;SACJ;QAED,qBAAgB,GAAG,EAAG;IAC1B,CAAC;CAAA;AAVD,oDAUC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbD,yEAAwC;AACxC,+EAA8C;AAC9C,4EAA4C;AAC5C,2GAAsD;AACtD,uFAAkG;AAClG,sGAAgD;AAChD,qFAAoD;AAEpD,qIAAqE;AACrE,yKAA6F;AAC7F,8EAAkD;AAClD,sGAAqD;AACrD,wEAA+C;AAC/C,8EAAsD;AACtD,2JAAmF;AA2BnF,IAAqB,YAAY,GAAjC,MAAqB,YAAY;CAAI;AAAhB,YAAY;IAzBhC,eAAQ,CAAC;QACN,OAAO,EAAE;YACL,qBAAY;YACZ,mBAAW;YACX,oBAAe;YACf,wBAAmB;YACnB,wBAAS;SACZ;QACD,SAAS,EAAE;YACP,EAAE,OAAO,EAAE,4BAAe,EAAE,QAAQ,EAAE,gCAAqB,EAAE,KAAK,EAAE,IAAI,EAAE;YAC1E,EAAE,OAAO,EAAE,gCAAmB,EAAE,QAAQ,EAAE,mCAAgB,EAAE,KAAK,EAAE,IAAI,EAAE;YACzE,EAAE,OAAO,EAAE,2BAAc,EAAE,QAAQ,EAAE,6BAAoB,EAAE,KAAK,EAAE,IAAI,EAAE;YACxE,EAAE,OAAO,EAAE,oCAAmB,EAAE,QAAQ,EAAE,oCAAyB,EAAE,KAAK,EAAE,IAAI,EAAE;SACrF;QACD,eAAe,EAAE;YACb,wCAAkB;YAClB,gEAA8B;YAC9B,wDAA0B;SAC7B;QACD,YAAY,EAAE;YACV,wCAAkB;YAClB,gEAA8B;YAC9B,wDAA0B;SAC7B;KACJ,CAAC;GACmB,YAAY,CAAI;kBAAhB,YAAY;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCjC,yEAA0C;AAC1C,yEAAyG;AACzG,qIAAqE;AACrE,yKAA6F;AAC7F,kHAAoE;AAepE,IAAa,qBAAqB,GAAlC,MAAa,qBAAsB,SAAQ,4BAA8B;IAcrE,YAAqB,MAAqB;QACtC,KAAK,EAAE;QADU,WAAM,GAAN,MAAM,CAAe;QAb1C,OAAE,GAAG,QAAQ;QACb,SAAI,GAAG,QAAQ;QACf,WAAM,GAAG,EAAE;QACX,sBAAiB,GAAG,gEAA8B;QAClD,mBAAc,GAAG;YACb,OAAO,EAAE;gBACL,WAAW,EAAE,IAAI;gBACjB,aAAa,EAAE,IAAI;gBACnB,OAAO,EAAE,IAAI;gBACb,OAAO,EAAE,IAAI;aAChB;SACJ;IAID,CAAC;IAEK,kBAAkB;;YACpB,IAAI,UAAuB;YAC3B,IAAI;gBACA,UAAU,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE;aAClD;YAAC,OAAO,CAAC,EAAE;gBACR,OAAO,CAAC,KAAK,CAAC,mCAAmC,EAAE,CAAC,CAAC;gBACrD,OAAO,EAAE;aACZ;YACD,OAAO;gBACH,GAAG,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,CAAC;oBAC5B,EAAE,EAAE,oBAAoB,SAAS,CAAC,EAAE,EAAE;oBACtC,IAAI,EAAE,QAAQ;oBACd,IAAI,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,KAAK,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;oBAC3E,SAAS,EAAE,IAAI;oBACf,IAAI,EAAE,eAAe;oBACrB,OAAO,EAAE;wBACL,WAAW,EAAE,SAAS,CAAC,EAAE;wBACzB,aAAa,EAAE,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;qBACpC;iBACJ,CAAC,CAAC;gBACH;oBACI,EAAE,EAAE,iBAAiB;oBACrB,IAAI,EAAE,QAAQ;oBACd,IAAI,EAAE,wBAAwB;oBAC9B,SAAS,EAAE,IAAI;oBACf,UAAU,EAAE,IAAI;oBAChB,IAAI,EAAE,eAAe;oBACrB,OAAO,EAAE,EAAG;iBACf;aACJ;QACL,CAAC;KAAA;IAEK,mBAAmB,CAAE,OAAsB;;YAC7C,OAAO;gBACH,IAAI,EAAE,wCAAkB;gBACxB,MAAM,EAAE;oBACJ,OAAO;iBACV;aACJ;QACL,CAAC;KAAA;IAED,cAAc,CAAE,QAAuC;QACnD,OAAO,EAAE;IACb,CAAC;CAEJ;AA/DY,qBAAqB;IADjC,iBAAU,EAAE;qCAeoB,8BAAa;GAdjC,qBAAqB,CA+DjC;AA/DY,sDAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBlC,yEAA0C;AAC1C,yEAAiF;AACjF,qIAAqE;AAErE,cAAc;AAEd,IAAa,gBAAgB,GAA7B,MAAa,gBAAiB,SAAQ,gCAAuC;IACnE,YAAY,CAAE,aAA4B;;YAC5C,OAAO,aAAa,CAAC,IAAI,KAAK,gBAAgB;QAClD,CAAC;KAAA;IAEK,OAAO,CAAE,aAA4B;;YACvC,OAAO;gBACH,IAAI,EAAE,wCAAkB;gBACxB,MAAM,EAAE;oBACJ,OAAO,EAAE,aAAa,CAAC,OAAO;oBAC9B,UAAU,EAAE,aAAa,CAAC,UAAU;iBACvC;aACJ;QACL,CAAC;KAAA;CACJ;AAdY,gBAAgB;IAD5B,iBAAU,EAAE;GACA,gBAAgB,CAc5B;AAdY,4CAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACN7B,+EAAmC;AACnC,2GAA6B;AAC7B,oHAA6C;AAC7C,yEAA0C;AAC1C,uDAA0C;AAE1C,yEAA8D;AAe9D,MAAa,aAAa;IAQtB,YAAqB,IAAS;QAAT,SAAI,GAAJ,IAAI,CAAK;QALtB,WAAM,GAAG,IAAI,cAAO,EAAU;QAC9B,WAAM,GAAG,IAAI,cAAO,EAAQ;QAE5B,SAAI,GAAG,KAAK;IAEc,CAAC;IAPnC,IAAI,OAAO,KAA0B,OAAO,IAAI,CAAC,MAAM,EAAC,CAAC;IACzD,IAAI,OAAO,KAAwB,OAAO,IAAI,CAAC,MAAM,EAAC,CAAC;IAQjD,KAAK;;YACP,IAAI,CAAC,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC;gBAChC,MAAM,EAAE,IAAI;gBACZ,KAAK,EAAE,IAAI;gBACX,GAAG,EAAE,IAAI;aACZ,CAAC;YACF,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YACtD,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,GAAG,EAAE;gBACzB,IAAI,CAAC,IAAI,GAAG,IAAI;gBAChB,IAAI,CAAC,KAAK,EAAE;YAChB,CAAC,CAAC;QACN,CAAC;KAAA;IAEK,MAAM,CAAE,CAAS,EAAE,CAAS;;YAC9B,MAAM,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC;QACpC,CAAC;KAAA;IAED,KAAK,CAAE,IAAY;QACf,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;YACZ,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC;SAC1B;IACL,CAAC;IAEK,IAAI;;YACN,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAC,SAAS;YACvC,MAAM,KAAK,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACvC,IAAI,KAAK,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE;gBACzB,IAAI;oBACA,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC;iBAC1B;gBAAC,OAAO,CAAC,EAAE;oBACR,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;wBACjC,MAAM,CAAC;qBACV;iBACJ;aACJ;QACL,CAAC;KAAA;IAEO,KAAK;QACT,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;QAClB,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;IAC1B,CAAC;CACJ;AApDD,sCAoDC;AAGD,IAAa,aAAa,GAA1B,MAAa,aAAa;IAGtB,YAAa,GAAe,EAAU,MAAqB;QAArB,WAAM,GAAN,MAAM,CAAe;QACvD,IAAI,CAAC,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC,QAAQ,CAAC;IACtC,CAAC;IAEK,cAAc;;YAChB,OAAO,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC,cAAc,EAAE,CAAC,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;;gBAAC,QAAC;oBAC/D,EAAE,EAAE,SAAS,CAAC,EAAE;oBAChB,KAAK,EAAE,eAAS,CAAC,KAAK,mCAAI,EAAE;oBAC5B,KAAK,EAAE,SAAS,CAAC,KAAK;oBACtB,KAAK,EAAE,SAAS,CAAC,KAAK;iBACzB,CAAC;aAAA,CAAC;QACP,CAAC;KAAA;IAEK,UAAU;;YACZ,OAAO,CAAC,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;gBACvD,EAAE,EAAE,KAAK,CAAC,EAAE;gBACZ,WAAW,EAAE,IAAI,CAAC,mBAAmB,CAAC,KAAK,CAAC;gBAC5C,IAAI,EAAE,KAAK,CAAC,QAAQ;aACvB,CAAC,CAAC;QACP,CAAC;KAAA;IAEK,eAAe,CAAE,OAAe,EAAE,IAAY,EAAE,IAAmB;;YACrE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,CAAC;YAC5C,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC,eAAe,CAAC;gBACrD,IAAI,EAAE,iBAAO,CAAC,SAAS,IAAI,IAAI,SAAM,EAAE,EAAE,CAAC;gBAC1C,WAAW,EAAE,IAAI;gBACjB,YAAY,EAAE,IAAI;gBAClB,YAAY,EAAE,IAAI;gBAClB,GAAG,EAAE,IAAI;gBACT,SAAS,EAAE,IAAI;gBACf,UAAU,EAAE,IAAI,aAAJ,IAAI,cAAJ,IAAI,GAAI,SAAS;gBAC7B,KAAK,EAAE,OAAO;aACjB,CAAC;YACF,MAAM,SAAS,CAAC,KAAK,EAAE;YACvB,MAAM,IAAI,GAAG,MAAM,SAAS,CAAC,OAAO,EAAE;YACtC,OAAO;gBACH,EAAE,EAAE,IAAI,CAAC,EAAE;gBACX,KAAK,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC;gBAClB,KAAK,EAAE,IAAI,CAAC,KAAK;gBACjB,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,MAAM;aAC3B;QACL,CAAC;KAAA;IAEK,gBAAgB,CAAE,WAAmB;;YACvC,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC,YAAY,CAAC,WAAW,CAAC;YAClE,IAAI;gBACA,MAAM,SAAS,CAAC,IAAI,EAAE;aACzB;YAAC,WAAM,GAAG;YACX,MAAM,SAAS,CAAC,MAAM,EAAE;QAC5B,CAAC;KAAA;IAEK,IAAI,CAAE,WAAmB,EAAE,IAAc;;YAC3C,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,WAAW,CAAC;YACjD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,EAAE,CAAC,YAAY,CAAC,WAAW,CAAC;YAClE,MAAM,IAAI,GAAG,MAAM,SAAS,CAAC,IAAI,CAAC;gBAC9B,GAAG,EAAE,IAAI;gBACT,UAAU,EAAE,QAAQ;gBACpB,WAAW,EAAE,IAAI;gBACjB,YAAY,EAAE,IAAI;gBAClB,YAAY,EAAE,IAAI;gBAClB,GAAG,EAAE,IAAI;aACZ,CAAC;YACF,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC;QAClC,CAAC;KAAA;IAED,mBAAmB,CAAE,KAAgB;QACjC,IAAI,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,eAAe,EAAE;YACvC,OAAO,KAAK,CAAC,EAAE;SAClB;QACD,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5B,CAAC;IAEO,SAAS;QACb,IAAI,IAAI,GAAQ,EAAE;QAClB,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM,EAAE;YACjC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,MAAM;SACpD;QACD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;YAC/B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI;SAC5C;QACD,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI,EAAE;YAC/B,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAC,IAAI;SAC5C;QACD,OAAO,IAAI,mBAAM,CAAC,IAAI,CAAC;IAC3B,CAAC;CAEJ;AAzFY,aAAa;IADzB,iBAAU,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC;qCAIb,uBAAU,EAAkB,0BAAa;GAHlD,aAAa,CAyFzB;AAzFY,sCAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5E1B,+GAAyC;AAEzC,yEAAuC;AACvC,qFAA4C;AAE5C,kHAAmF;AAEnF,MAAa,aAAc,SAAQ,4BAAW;IAK1C,YAAa,QAAkB,EAAU,OAAsB;;QAC3D,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,uBAAU,CAAC,CAAC,MAAM,CAAC,UAAU,yBAAO,CAAC,OAAO,CAAC,aAAa,mCAAI,OAAO,CAAC,OAAO,CAAC,WAAW,mCAAI,OAAO,CAAC,OAAO,CAAC,OAAO,mCAAI,SAAS,EAAE,CAAC,CAAC;QADnH,YAAO,GAAP,OAAO,CAAe;QAE3D,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,GAAG,CAAC,8BAAa,CAAC;IAC7C,CAAC;IAEK,KAAK;;YACP,IAAI,WAAW,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW;YAClD,IAAI,IAAI,GAAoB,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,IAAI,SAAS;YACrE,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,GAAG,CAAC,EAAE;gBAC5B,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC;aAChC;YAED,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE;gBAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,iCAAiC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,MAAM,CAAC,CAAC;gBACjG,IAAI,CAAC,SAAS,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,eAAe,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,CAAC;gBACjH,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,EAAE;aAClC;YAED,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,EAAE;gBACpD,WAAW,GAAG,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,cAAc,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE;gBACrH,IAAI,CAAC,WAAW,EAAE;oBACd,MAAM,IAAI,KAAK,CAAC,aAAa,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,YAAY,CAAC;iBAC/E;aACJ;YAED,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC,gBAAgB,WAAW,MAAM,CAAC,CAAC;YAC/D,IAAI,CAAC,OAAO,GAAG,MAAM,IAAI,CAAC,MAAM,CAAC,IAAI,CACjC,WAAW,EACX,IAAgB,CACnB;YACD,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;gBAClC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC;YACzB,CAAC,CAAC;YACF,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACpD,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE;YAC1B,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;YAC5B,IAAI,CAAC,IAAI,GAAG,IAAI;QACpB,CAAC;KAAA;IAED,MAAM,CAAE,OAAe,EAAE,IAAY;;QACjC,UAAI,CAAC,OAAO,0CAAE,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC;IACvC,CAAC;IAED,KAAK,CAAE,IAAY;;QACf,UAAI,CAAC,OAAO,0CAAE,KAAK,CAAC,IAAI,CAAC;IAC7B,CAAC;IAED,IAAI;;QACA,IAAI,IAAI,CAAC,SAAS,EAAE;YAChB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,CAAC;SAClD;QACD,UAAI,CAAC,OAAO,0CAAE,IAAI,EAAE;IACxB,CAAC;IAEK,qBAAqB;;;YACvB,UAAI,CAAC,OAAO,0CAAE,IAAI,EAAE;;KACvB;IAED,wBAAwB;QACpB,OAAO,KAAK;IAChB,CAAC;IAEK,mBAAmB;;YACrB,OAAO,IAAI;QACf,CAAC;KAAA;CACJ;AAtED,sCAsEC;;;;;;;;;;;;;;;;;;;;;AC7ED,yEAA0C;AAC1C,qFAAoD;AAEpD,6JAAqF;AAErF,cAAc;AAEd,IAAa,yBAAyB,GAAtC,MAAa,yBAA0B,SAAQ,oCAAmB;IAAlE;;QACI,OAAE,GAAG,QAAQ;QACb,SAAI,GAAG,YAAY;QACnB,UAAK,GAAG,QAAQ;IAKpB,CAAC;IAHG,gBAAgB;QACZ,OAAO,wDAA0B;IACrC,CAAC;CACJ;AARY,yBAAyB;IADrC,iBAAU,EAAE;GACA,yBAAyB,CAQrC;AARY,8DAAyB;;;;;;;;;;;;ACPzB;;AAEb,yBAAyB,kGAAyC;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;;AAEA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;;AAE1B;AACA,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA,aAAa,mBAAmB;AAChC;AACA,aAAa,QAAQ;AACrB;;AAEA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,aAAa;AAC1B;;AAEA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,KAAK;AACjC;;AAEA,eAAe,YAAY;AAC3B;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3iBY;;AAEZ,OAAO,SAAS,GAAG,mBAAO,CAAC,sBAAQ;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,cAAc;;AAErD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB,uBAAuB;AAC7C;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,uBAAuB;AACxC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,gBAAgB;AACnC;AACA;AACA,GAAG;AACH;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,QAAQ,6BAA6B;AACrC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;AC3YY;;AAEZ,qBAAqB,+FAAiC;AACtD,iBAAiB,mBAAO,CAAC,qDAAU;AACnC,mBAAmB,mBAAO,CAAC,qDAAc;;AAEzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,+BAA+B;AAC/B,yBAAyB;;;;;;;;;;;;ACnFb;AACZ,WAAW,mBAAO,CAAC,cAAI;AACvB,aAAa,mBAAO,CAAC,kBAAM;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,gBAAgB;;AAEhB;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;AAEnB,gBAAgB;;AAEhB;AACA;AACA;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;;AAEA,UAAU,wFAAmC;AAC7C,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM,qBAAqB;AAC3B;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd,eAAe;AACf,cAAc;AACd,eAAe;AACf,8EAAgC;;AAEhC;AACA;AACA;;AAEA,aAAa;AACb,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA,EAAE,aAAa;AACf,EAAE,aAAa;;AAEf;AACA;;AAEA,iBAAiB,SAAS;AAC1B,4BAA4B;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACzMA;AACA;AACA;AACA;;AAEA;AACA,EAAE,+FAAwC;AAC1C,CAAC;AACD,EAAE,yFAAqC;AACvC;;;;;;;;;;;ACTA;AACA;AACA;;AAEA,UAAU,mBAAO,CAAC,gBAAK;AACvB,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;AACA;AACA;;AAEA,UAAU,wFAAmC;AAC7C,YAAY;AACZ,WAAW;AACX,kBAAkB;AAClB,YAAY;AACZ,YAAY;AACZ,iBAAiB;;AAEjB;AACA;AACA;;AAEA,cAAc;;AAEd;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,yBAAyB;;AAEpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC,IAAI;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,mBAAO,CAAC,cAAI;AAC3B,2CAA2C,mBAAmB;AAC9D;AACA;;AAEA;AACA;AACA,gBAAgB,mBAAO,CAAC,gBAAK;AAC7B;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;ACvPA;;AAEA,kBAAkB,mBAAO,CAAC,oBAAO;AACjC,eAAe,mBAAO,CAAC,kBAAM;AAC7B,QAAQ,mBAAO,CAAC,gBAAK;AACrB,UAAU,mBAAO,CAAC,yDAAS;;AAE3B,mBAAmB,2BAA2B;;AAE9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;ACtFA;;AAEA,WAAW,mBAAO,CAAC,kBAAM;AACzB,WAAW,mBAAO,CAAC,mEAAiB;;AAEpC;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACjDA,kBAAkB,mBAAO,CAAC,gCAAa;AACvC,SAAS,mBAAO,CAAC,uDAAQ;AACzB,OAAO,mBAAO,CAAC,cAAI;AACnB,SAAS,mBAAO,CAAC,kBAAM;AACvB,QAAQ,mBAAO,CAAC,gBAAK;AACrB,QAAQ,mBAAO,CAAC,qDAAO;AACvB,eAAe,mBAAO,CAAC,qEAAe;AACtC,UAAU,mBAAO,CAAC,gDAAO;AACzB,UAAU,mBAAO,CAAC,yDAAS;AAC3B,SAAS,mBAAO,CAAC,kBAAM;AACvB,QAAQ,mBAAO,CAAC,gBAAK;AACrB,YAAY,mBAAO,CAAC,kDAAU;AAC9B,UAAU,wCAAkB;;AAE5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,6BAA6B;;AAE7B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,mCAAmC;AACvE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL,sBAAsB;AACtB;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH,8FAA8F,EAAE;;AAEhG;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA,6EAA6E,IAAI;AACjF,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;ACxcA,aAAa,2EAAsB;AACnC,SAAS,mBAAO,CAAC,kBAAM;;AAEvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;;;;;;;;;;;AC7BA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;ACvBA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sDAA8B,gBAAgB,aAAa;;AAE5E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;;AAIA;;;;;;;;;;;AClIA,aAAa,gFAAwB;AACrC,SAAS,mBAAO,CAAC,oDAAQ;AACzB,SAAS,mBAAO,CAAC,oDAAQ;;AAEzB;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW;AACX,aAAa;AACb,cAAc;AACd,YAAY;AACZ,aAAa;AACb,eAAe;AACf,eAAe;AACf,cAAc;AACd,cAAc;AACd,cAAc;AACd,YAAY;AACZ,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,WAAW;AACX,aAAa;AACb,kBAAkB;AAClB,mBAAmB;AACnB,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;;AAEA,oBAAoB,sDAA8B,gBAAgB,aAAa;;AAE/E;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;AC3hCA,mBAAmB,wDAA8B;AACjD,UAAU,mBAAO,CAAC,8DAAc;AAChC,QAAQ,mBAAO,CAAC,8CAAQ;AACxB,SAAS,mBAAO,CAAC,kBAAM;AACvB,cAAc,mBAAO,CAAC,8DAAa;AACnC,UAAU,mBAAO,CAAC,sDAAS;AAC3B,WAAW,mBAAO,CAAC,wDAAU;AAC7B,YAAY,mBAAO,CAAC,0DAAW;AAC/B,YAAY,mBAAO,CAAC,0DAAW;AAC/B,WAAW,mBAAO,CAAC,wDAAU;AAC7B,WAAW,mBAAO,CAAC,wDAAU;AAC7B,WAAW,mBAAO,CAAC,wDAAU;AAC7B,SAAS,mBAAO,CAAC,oDAAQ;AACzB,SAAS,mBAAO,CAAC,oDAAQ;AACzB,SAAS,mBAAO,CAAC,oDAAQ;AACzB,SAAS,mBAAO,CAAC,oDAAQ;AACzB;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AClvDA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,eAAe,sDAA8B,gBAAgB,aAAa;;AAE1E;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;;;;;;;;;;ACrIA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sDAA8B,gBAAgB,aAAa;;AAE3E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACjRA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sDAA8B,gBAAgB,aAAa;;AAE7E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;;;AAKA;;;;;;;;;;;ACvKA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,eAAe,sDAA8B,gBAAgB,aAAa;;AAE1E;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;;;;;;;;;;ACjIA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sDAA8B,gBAAgB,aAAa;;AAE5E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;;;;;;;;;;ACnWA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sDAA8B,gBAAgB,aAAa;;AAE5E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;;AAIA;;;;;;;;;;;AChIA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,sDAA8B,gBAAgB,aAAa;;AAE7E;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;;AAIA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;;AAIA;;;;;;;;;;;AC9KA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,sDAA8B,gBAAgB,aAAa;;AAE1E;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;;AAGA;;;;;;;;;;;AC5FA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;ACrEA,WAAW,mBAAO,CAAC,oDAAQ;;AAE3B;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,sDAA8B,gBAAgB,aAAa;;AAE5E;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;;AAEA;;;;;;;;;;;ACrFA,WAAW,mBAAO,CAAC,yCAAM;;AAEzB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,4BAA4B;AAC9B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC7FA,iBAAiB,6CAAuB,IAAI,mBAAO,CAAC,4BAAW;;;;;;;;;;;ACA/D;AACA,aAAa,mBAAO,CAAC,kBAAM;AAC3B;AACA;AACA,CAAC;AACD,EAAE,gHAAiD;AACnD;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtBA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;;;;ACJA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;ACjGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,YAAY,MAAM;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvJA,aAAa,mBAAO,CAAC,+CAAQ;AAC7B;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCa;;AAEb;AACA;AACA;AACA,oBAAoB;AACpB,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;AC1CA,UAAU,mBAAO,CAAC,qFAA0C;;AAE5D,2BAA2B,kCAAkC,aAAa,0eAA0e,WAAW,6JAA6J,eAAe,0IAA0I,eAAe,iRAAiR,oBAAoB,gIAAgI,WAAW,sKAAsK,yBAAyB,wiBAAwiB;AAC3hE,0B;;;;;;;;;;ACHA,UAAU,mBAAO,CAAC,qFAA0C;;AAE5D,2BAA2B,kCAAkC,aAAa,2tCAA2tC;AACryC,0B;;;;;;;;;;;ACHa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;AACA,iDAAiD,aAAa;AAC9D;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iDAAiD;AAC5D,WAAW,gBAAgB;AAC3B,YAAY;AACZ;AACA,eAAe;AACf;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iCAAiC;AAC5C,YAAY;AACZ;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA,+BAA+B,EAAE;AACjC,8BAA8B,EAAE;AAChC,6BAA6B,EAAE;AAC/B,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAA0B;AAC3C,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5PA,WAAW,mBAAO,CAAC,yCAAM;AACzB,UAAU,mBAAO,CAAC,4DAAe;AACjC,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,eAAe,qCAAqC;AACpD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,0EAAsB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,6DAAc;AACjC,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;;AAEA,eAAe,mBAAO,CAAC,kFAAoB;AAC3C,eAAe,mBAAO,CAAC,kFAAoB;;AAE3C;;AAEA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,gBAAgB,mBAAO,CAAC,oFAAqB;;AAE7C;AACA,WAAW,mBAAO,CAAC,6DAAc;AACjC,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,0EAAsB;AACxC;;AAEA;;AAEA;AACA,cAAc,mBAAO,CAAC,gDAAS;AAC/B;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS,wDAA8B;;AAEvC;AACA;AACA;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,gGAA2B;AAChD;;AAEA;;AAEA,aAAa,oFAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,6DAAc;AACjC,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;;AAEA;AACA,gBAAgB,mBAAO,CAAC,kBAAM;AAC9B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,wGAA+B;AACxD,kBAAkB,mBAAO,CAAC,kGAA4B;AACtD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yEAAyE,6EAA6E;AACtJ;;AAEA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,+GAAwC;AAChF;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,kGAAkG;AAClG,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,4FAA4F;AAC5F,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,+GAAwC;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4CAA4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,4EAA4E;;AAE5E;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,iBAAiB,yBAAyB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;AACnD;AACA,mDAAmD,iEAAiE;AACpH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA,C;;;;;;;;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,mBAAO,CAAC,8EAAkB;;AAEvC;AACA,WAAW,mBAAO,CAAC,6DAAc;AACjC,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,C;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEa;;AAEb;;AAEA,UAAU,mBAAO,CAAC,0EAAsB;AACxC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,WAAW,mBAAO,CAAC,6DAAc;AACjC,gBAAgB,mBAAO,CAAC,qDAAU;AAClC;;AAEA;AACA;AACA,aAAa,mBAAO,CAAC,6DAAgB;AACrC;AACA;;AAEA;AACA,aAAa,mBAAO,CAAC,gGAA2B;AAChD;;AAEA;;AAEA,aAAa,oFAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,mBAAO,CAAC,kGAA4B;;AAEtD;;AAEA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAiD,0FAA0F;;AAE3I;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,8EAAkB;;AAE/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iCAAiC;;AAEjC;;AAEA,2CAA2C;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;AC9qBa;;AAEb,iDAAiD,0CAA0C,0DAA0D,EAAE;;AAEvJ,aAAa,oFAA6B;AAC1C,WAAW,mBAAO,CAAC,kBAAM;;AAEzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB,gDAAgD;AAChD;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA,C;;;;;;;;;;;AC9Ea;;AAEb;;AAEA,UAAU,mBAAO,CAAC,0EAAsB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,E;;;;;;;;;;ACzEA,4DAAkC;;;;;;;;;;;ACAlC,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA,EAAE,gBAAgB;AAClB,EAAE,gBAAgB;AAClB,EAAE,cAAc;AAChB,EAAE,iBAAiB;AACnB,EAAE,mBAAmB;AACrB,EAAE,cAAc;AAChB,CAAC;AACD,YAAY,+HAAqD;AACjE,EAAE,cAAc;AAChB,EAAE,gBAAgB;AAClB,EAAE,iIAAuD;AACzD,EAAE,2HAAmD;AACrD,EAAE,oIAAyD;AAC3D,EAAE,0IAA6D;AAC/D;;;;;;;;;;;AClBA;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,EAAE,cAAc;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC5EA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,cAAc,EAAE;AAC7E;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,2BAA2B,yCAAyC;AACpE;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,kCAAkC,qDAAqD;AACvF;AACA,yBAAyB,qDAAqD;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;;AAE5B;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,sCAAsC;AACtC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrMA,CAAC;AACD,MAAM,IAA2B;AACjC;AACA,IAAI,sBAAyB;AAC7B;AACA;AACA,OAAO,EAKJ;AACH,CAAC;AACD,6BAA6B,svJAAsvJ;AACnxJ,6BAA6B,MAAM,iIAAiI,OAAO,6JAA6J,OAAO,2JAA2J,OAAO,uHAAuH,OAAO,0GAA0G,OAAO,iBAAiB;;AAEjvB;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;AChED,SAAS,mBAAO,CAAC,cAAI;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1BA;AACA,cAAc,mBAAO,CAAC,2DAAY;AAClC,cAAc,mBAAO,CAAC,yDAAW;AACjC,SAAS,mBAAO,CAAC,6DAAa;AAC9B,aAAa,mBAAO,CAAC,qEAAiB;AACtC,E;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;;AAEA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA,4BAA4B,6BAA6B;AACzD;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;;AAEA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,SAAS;AAC1E;;AAEA,gCAAgC,iCAAiC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,YAAY;AACvB;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB,4BAA4B;;;;;;;;;;;ACxd5B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,6BAA6B;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,YAAY,SAAS;AACrB;AACA,YAAY,SAAS;;AAErB,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe,cAAc,UAAU;;AAExD;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,QAAQ,qBAAqB,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,eAAe,+BAA+B,UAAU;;AAE7E;AACA,kBAAkB,sCAAsC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,SAAS;AACvC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC,qBAAqB,OAAO,QAAQ;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAS,QAAQ;AACrC;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,eAAe,oBAAoB,oBAAoB;AACvD,QAAQ,cAAc,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,qBAAqB,2BAA2B;AAChD,wBAAwB,mBAAmB,gBAAgB;AAC3D,sBAAsB,eAAe,gBAAgB;;AAErD;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,4BAA4B;AAC5B,8BAA8B;AAC9B,6CAA6C;AAC7C;AACA;AACA,kCAAkC;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,cAAc,UAAU;AACjD;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,yBAAyB,eAAe,gBAAgB;;AAExD,oBAAoB;AACpB,2BAA2B,mBAAmB,gBAAgB;;AAE9D;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,6CAA6C;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW,QAAQ,QAAQ;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,oBAAoB,eAAe,gBAAgB,UAAU;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,6CAA6C;;AAErE;AACA,yBAAyB,6CAA6C;;AAEtE;AACA,0BAA0B,iDAAiD;;AAE3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,8BAA8B;AACpD,mBAAmB,oCAAoC;AACvD,mBAAmB,oCAAoC;;AAEvD;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,YAAY;AAClC,mBAAmB,eAAe,4BAA4B,UAAU;;AAExE;AACA,qBAAqB,YAAY;AACjC,kBAAkB,eAAe,2BAA2B,UAAU;;AAEtE;AACA,sBAAsB,YAAY;AAClC,mBAAmB,eAAe,4BAA4B,UAAU;;AAExE;AACA,yBAAyB,aAAa;AACtC,sBAAsB,eAAe,+BAA+B,UAAU;;AAE9E;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU,SAAS;AAC1C,qBAAqB,SAAS,QAAQ;AACtC,oBAAoB,SAAS,QAAQ;AACrC,kBAAkB,SAAS,QAAQ;AACnC;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,UAAU,KAAK;AAChC;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gCAAgC;;AAEtD;AACA,wBAAwB,oCAAoC;;AAE5D;AACA,uBAAuB,iCAAiC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe,iBAAiB,UAAU;;AAE7D;AACA,wBAAwB,eAAe,iBAAiB,UAAU;;AAElE;AACA,wBAAwB,eAAe,sBAAsB,UAAU;;AAEvE;AACA,qBAAqB,eAAe,kBAAkB,UAAU;;AAEhE;AACA,sBAAsB,eAAe,yBAAyB,UAAU;;AAExE;AACA,yBAAyB,eAAe,yBAAyB,UAAU;;AAE3E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B,wBAAwB,mBAAmB;AAC3C,sBAAsB,eAAe;;AAErC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;;AAErD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B,0BAA0B,OAAO;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ,eAAe,aAAa,gBAAgB,UAAU;AAC9D;;AAEA,2BAA2B,UAAU;;AAErC;AACA;AACA;AACA,wBAAwB,kBAAkB,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB,4BAA4B,eAAe,gBAAgB;;AAE3D,iBAAiB;AACjB,8BAA8B,mBAAmB,gBAAgB;;AAEjE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS,KAAK;AACrC,sBAAsB,cAAc,KAAK;AACzC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,eAAe,eAAe,QAAQ;AAC1D,8BAA8B,OAAO,OAAO,QAAQ,QAAQ;AAC5D;AACA;;AAEA;AACA,oBAAoB,OAAO,QAAQ;AACnC,mBAAmB,eAAe,KAAK;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,WAAW,OAAO,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,cAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,qCAAqC;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AChqCA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,uEAAmB;AAC7B,mBAAmB,qFAA6B;;AAEhD,oBAAoB,mBAAO,CAAC,2EAAkB;AAC9C;AACA;AACA,gBAAgB,mBAAO,CAAC,iEAAa;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+DAA+D;AAC/D,wCAAwC;AACxC,sEAAsE;AACtE,sEAAsE;AACtE;AACA,2DAA2D;AAC3D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,uBAAuB,mBAAO,CAAC,0DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,yDAAS;;AAE/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,yDAAS;;AAE/B;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,YAAY,mBAAO,CAAC,yDAAS;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,yDAAS;;AAE/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,mBAAO,CAAC,yDAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;AAID;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC96Ca;;AAEb,cAAc,+CAAuB;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB,cAAc,oBAAoB,EAAE,IAAI;AACxC,YAAY,gBAAgB,EAAE,IAAI;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM,GAAG,sCAAsC;AACtE;AACA,KAAK;AACL,uBAAuB,MAAM,GAAG,YAAY,MAAM,YAAY;AAC9D,KAAK;AACL,mBAAmB,MAAM,GAAG,YAAY;AACxC;AACA,GAAG;AACH,iBAAiB,MAAM,GAAG,iBAAiB;AAC3C;AACA;;;;AAIA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wDAAwD,QAAQ,IAAI,OAAO;AAC3E;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,MAAM,aAAa,SAAS;;AAEtD;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,KAAK,GAAG,WAAW,GAAG,wBAAwB;AACjE,KAAK;AACL;AACA,oBAAoB,KAAK,IAAI,KAAK,GAAG,WAAW,GAAG,wBAAwB;AAC3E;;AAEA,8BAA8B,cAAc;;AAE5C;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpMA;;AAEA,sBAAsB,qDAA2B;AACjD,qBAAqB,oDAA0B;AAC/C,qBAAqB,oDAA0B;AAC/C,gBAAgB,6CAAuB;AACvC,WAAW,mBAAO,CAAC,kBAAM;AACzB;AACA;AACA,oBAAoB,sEAA4C;AAChE,SAAS,mBAAO,CAAC,cAAI;;AAErB,iBAAiB,yFAA6B;AAC9C,cAAc,sFAA0B;AACxC,mBAAmB,6GAAwC;AAC3D,oBAAoB,8GAAyC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;AACA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,kBAAkB,EAAE;AAC3D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,qBAAqB,iBAAiB;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA,eAAe;AACf;AACA;;AAEA;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA,0CAA0C,SAAS;AACnD;;AAEA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,aAAa,WAAW;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD,6CAA6C,UAAU;AACvD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,SAAS;AAChC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,mBAAO,CAAC,2EAAkB;AACzC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,6BAA6B,EAAE;AACxC;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS,6BAA6B,EAAE;AACxC;AACA,CAAC;;AAED;;;;;;;;;;;;ACrjGA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,WAAW,mBAAO,CAAC,kBAAM;AACzB,sBAAsB,qDAA2B;AACjD,eAAe,gDAAwB;AACvC,cAAc,+CAAuB;;AAErC,mBAAmB,mBAAO,CAAC,6DAAc;AACzC,UAAU,uEAAmB;;AAE7B,mBAAmB,6GAAwC;AAC3D,oBAAoB,8GAAyC;AAC7D,aAAa,mBAAO,CAAC,iEAAa;AAClC,YAAY,mBAAO,CAAC,yDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kGAAkC;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8FAAkC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,iBAAiB;;AAEjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC,iBAAiB,EAAE;;AAEpD;AACA;AACA,uCAAuC,uBAAuB,EAAE;AAChE,GAAG;AACH;AACA,2CAA2C,2BAA2B,EAAE;AACxE;AACA,kCAAkC,qCAAqC,EAAE;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA,qCAAqC;AACrC;;AAEA;AACA,wDAAwD;AACxD,kBAAkB;;AAElB;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,oCAAoC;;AAEpC,4DAA4D;;AAE5D,yDAAyD;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,UAAU,UAAU;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,+BAA+B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sCAAsC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kCAAkC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,wCAAwC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kCAAkC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,8BAA8B;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,gCAAgC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,+BAA+B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,oCAAoC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,iCAAiC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,mCAAmC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qDAAqD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA,wDAAwD;AACxD,kBAAkB;;AAElB;AACA;AACA,oCAAoC;AACpC;;AAEA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,+BAA+B;;AAE/B,4DAA4D;;AAE5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB;AACxB;;AAEA;AACA;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,8BAA8B;AACvE,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;;;;;;;;;;;AC7vKpB,UAAU,uEAAmB;;AAE7B,mBAAmB,6GAAwC;AAC3D,oBAAoB,8GAAyC;;AAE7D;AACA;AACA,8BAA8B,OAAO;;AAErC;AACA;AACA;AACA;AACA,YAAY,+FAA+B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AC3LA,eAAe,gDAAwB;AACvC,mBAAmB,kDAAwB;AAC3C,qBAAqB,oDAA0B;AAC/C,qBAAqB,oDAA0B;;AAE/C,aAAa,0HAAkE;;AAE/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,2BAA2B;;AAE3B;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,4BAA4B;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AC3fA;AACA;AACA;;AAEA,eAAe,gDAAwB;AACvC,mBAAmB,wDAA8B;;AAEjD;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChJA,aAAa,4CAAqB;AAClC,mBAAmB,wDAA8B;AACjD,eAAe,gDAAwB;AACvC,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;AACrB,SAAS,mBAAO,CAAC,oCAAe;;AAEhC,mBAAmB,qGAAwC;AAC3D,oBAAoB,sGAAyC;AAC7D,oBAAoB,sGAAyC;;AAE7D;AACA;AACA;AACA;AACA;;AAEA,oDAAoD,EAAE,WAAW,EAAE,WAAW,EAAE,WAAW,EAAE;;AAE7F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;;AAEA;AACA,qBAAqB,QAAQ;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClaA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrBA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B,aAAa,4CAAqB;AAClC,gBAAgB,4CAAqB;AACrC,mBAAmB,wDAA8B;AACjD,eAAe,gDAAwB;AACvC;;AAEA,mBAAmB,mBAAO,CAAC,0DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,6DAAe;AACxC,cAAc,mBAAO,CAAC,qDAAW;AACjC,iBAAiB,mBAAO,CAAC,iDAAS;AAClC,kBAAkB,mBAAO,CAAC,6DAAe;AACzC,mBAAmB,qGAAwC;;AAE3D;AACA,iDAAiD,GAAG;AACpD;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;AACA;;AAEA,0BAA0B,8BAA8B,EAAE;AAC1D;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B,EAAE;AACxD;;AAEA;AACA,4BAA4B,8BAA8B,EAAE;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAA+B,EAAE;AAC/D;AACA;;AAEA,0BAA0B,oBAAoB,EAAE;AAChD;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,gBAAgB,mBAAO,CAAC,mDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB;;;;;;;;;;;ACliDxB,gBAAgB,6CAAqB;AACrC,iBAAiB,+CAAsB;AACvC,eAAe,gDAAwB;;AAEvC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,+EAA0B;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9DA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC/EA,UAAU,mBAAO,CAAC,gBAAK;AACvB,mBAAmB,wDAA8B;AACjD;AACA,eAAe,gDAAwB;;AAEvC,mBAAmB,mBAAO,CAAC,0DAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,mBAAO,CAAC,qDAAW;AACjC,uBAAuB,mBAAO,CAAC,+DAAgB;AAC/C,oBAAoB,sGAAyC;;AAE7D;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,kCAAkC;AAClC,KAAK;AACL,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qDAAqD,eAAe;;AAEpE;;AAEA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,qDAAqD,eAAe;;AAEpE;;AAEA;AACA;;AAEA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mDAAmD,eAAe;;AAElE;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe;AAC9D,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;;;;;;;;;;ACvoC7B;AACA;AACA;AACA;AACA,mBAAmB,wDAA8B;AACjD,eAAe,gDAAwB;;AAEvC;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,aAAa,oFAA6B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6BAA6B,sCAAsC,sCAAsC;AACzG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;ACvSA,aAAa,mBAAO,CAAC,+CAAQ;AAC7B,UAAU,mBAAO,CAAC,sDAAY;AAC9B,WAAW,mBAAO,CAAC,0CAAM;AACzB,aAAa,mBAAO,CAAC,8DAAgB;AACrC,SAAS,mBAAO,CAAC,cAAI;AACrB,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,cAAI;;AAErB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,uBAAuB,kBAAkB;AACzC;AACA;;AAEA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mCAAmC;AACnC;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,qCAAqC;AACrC;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;;;;;;;;;;AC3VA,WAAW,mBAAO,CAAC,kBAAM;AACzB,SAAS,mBAAO,CAAC,mCAAI;AACrB,cAAc,mBAAO,CAAC,uDAAW;;AAEjC,eAAe,iGAAmC;AAClD,kBAAkB,oGAAsC;;AAExD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AChQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB;AACtB;AACA;;AAEA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtSA,8FAAsC;AACtC,qFAAgC;;;;;;;;;;;ACDhC,gBAAgB,mBAAO,CAAC,0DAAc;AACtC,UAAU,mBAAO,CAAC,4DAAe;AACjC,eAAe,mBAAO,CAAC,qDAAU;AACjC;;AAEA,eAAe,iGAAmC;AAClD,eAAe,iGAAmC;AAClD,oBAAoB,yEAAuC;;AAE3D,cAAc,mBAAO,CAAC,uDAAW;;AAEjC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,cAAc;AACd;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC9PA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA,wCAAwC,4BAA4B;;AAEpE;AACA,4BAA4B;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;AACA,8CAA8C;AAC9C,8CAA8C;AAC9C,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;AACA,sDAAsD;AACtD,sDAAsD;AACtD,sDAAsD;AACtD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,qBAAqB;;AAErB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA,iBAAiB,QAAQ;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD,sBAAsB,2BAA2B;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB,qBAAqB;;AAErB;AACA;;AAEA,sBAAsB;AACtB,sBAAsB;;AAEtB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B,0BAA0B;;AAE1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB,mBAAmB;;AAEnB;AACA;;AAEA,oBAAoB;AACpB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;;AAEpB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;;AAErB;AACA;AACA;AACA;;AAEA,cAAc,QAAQ;AACtB;AACA;;AAEA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC,aAAa,gBAAgB;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,KAAK;AACL,GAAG,UAAU,IAA8B;AAC3C;AACA,aAAa,mBAAO,CAAC,sBAAQ;AAC7B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,OAAO;AACP;AACA;AACA,CAAC;;AAED,CAAC,EAAE,KAA6B,kEAAkE;;;;;;;;;;;;ACl1ElG;AACA;AACA;;AAEA,kEAA0C;;;;;;;;;;;ACL1C,SAAS,mBAAO,CAAC,uCAAM;AACvB,SAAS,mBAAO,CAAC,uCAAM;;AAEvB;AACA;AACA;;AAEA;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;ACvBA;AACA;;AAEA,aAAa,mBAAO,CAAC,sBAAQ;;AAE7B;AACA;AACA;;;;;;;;;;;ACPA,UAAU,mBAAO,CAAC,iDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC5GA,UAAU,mBAAO,CAAC,iDAAW;AAC7B,kBAAkB,mBAAO,CAAC,iEAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;;;;;;;;;;;AChCA,6D;;;;;;;;;;;ACAA,2D;;;;;;;;;;;ACAA,4D;;;;;;;;;;;ACAA,wE;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,2C;;;;;;;;;;;ACAA,uC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,gD;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,yC;;;;;;;;;;;ACAA,kD;;;;;;;;;;;ACAA,oC;;;;;;;;;;;ACAA,4C;;;;;;;;;;;ACAA,wD;;;;;;;;;;;ACAA,4D;;;;;;;;;;;ACAA,4D;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kD;;;;;;;;;;;ACAA,kC;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UCrBA;UACA;UACA;UACA","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"@angular/common\"), require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@ng-bootstrap/ng-bootstrap\"), require(\"fs\"), require(\"rxjs\"), require(\"tabby-core\"), require(\"tabby-settings\"), require(\"tabby-terminal\"), require(\"util\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"@angular/common\", \"@angular/core\", \"@angular/forms\", \"@ng-bootstrap/ng-bootstrap\", \"fs\", \"rxjs\", \"tabby-core\", \"tabby-settings\", \"tabby-terminal\", \"util\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"@angular/common\"), require(\"@angular/core\"), require(\"@angular/forms\"), require(\"@ng-bootstrap/ng-bootstrap\"), require(\"fs\"), require(\"rxjs\"), require(\"tabby-core\"), require(\"tabby-settings\"), require(\"tabby-terminal\"), require(\"util\")) : factory(root[\"@angular/common\"], root[\"@angular/core\"], root[\"@angular/forms\"], root[\"@ng-bootstrap/ng-bootstrap\"], root[\"fs\"], root[\"rxjs\"], root[\"tabby-core\"], root[\"tabby-settings\"], root[\"tabby-terminal\"], root[\"util\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, function(__WEBPACK_EXTERNAL_MODULE__angular_common__, __WEBPACK_EXTERNAL_MODULE__angular_core__, __WEBPACK_EXTERNAL_MODULE__angular_forms__, __WEBPACK_EXTERNAL_MODULE__ng_bootstrap_ng_bootstrap__, __WEBPACK_EXTERNAL_MODULE_fs__, __WEBPACK_EXTERNAL_MODULE_rxjs__, __WEBPACK_EXTERNAL_MODULE_tabby_core__, __WEBPACK_EXTERNAL_MODULE_tabby_settings__, __WEBPACK_EXTERNAL_MODULE_tabby_terminal__, __WEBPACK_EXTERNAL_MODULE_util__) {\nreturn ","var req = require(\"!!/Users/eugene/Work/tabby-docker/node_modules/pug-loader/index.js!/Users/eugene/Work/tabby-docker/src/components/dockerProfileSettings.component.pug\");\nmodule.exports = (req['default'] || req).apply(req, [])","var req = require(\"!!/Users/eugene/Work/tabby-docker/node_modules/pug-loader/index.js!/Users/eugene/Work/tabby-docker/src/components/dockerSettingsTab.component.pug\");\nmodule.exports = (req['default'] || req).apply(req, [])","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n\n  newInvalidAsn1Error: function (msg) {\n    var e = new Error();\n    e.name = 'InvalidAsn1Error';\n    e.message = msg || '';\n    return e;\n  }\n\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar errors = require('./errors');\nvar types = require('./types');\n\nvar Reader = require('./reader');\nvar Writer = require('./writer');\n\n\n// --- Exports\n\nmodule.exports = {\n\n  Reader: Reader,\n\n  Writer: Writer\n\n};\n\nfor (var t in types) {\n  if (types.hasOwnProperty(t))\n    module.exports[t] = types[t];\n}\nfor (var e in errors) {\n  if (errors.hasOwnProperty(e))\n    module.exports[e] = errors[e];\n}\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\n\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\n\n\n// --- API\n\nfunction Reader(data) {\n  if (!data || !Buffer.isBuffer(data))\n    throw new TypeError('data must be a node Buffer');\n\n  this._buf = data;\n  this._size = data.length;\n\n  // These hold the \"current\" state\n  this._len = 0;\n  this._offset = 0;\n}\n\nObject.defineProperty(Reader.prototype, 'length', {\n  enumerable: true,\n  get: function () { return (this._len); }\n});\n\nObject.defineProperty(Reader.prototype, 'offset', {\n  enumerable: true,\n  get: function () { return (this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'remain', {\n  get: function () { return (this._size - this._offset); }\n});\n\nObject.defineProperty(Reader.prototype, 'buffer', {\n  get: function () { return (this._buf.slice(this._offset)); }\n});\n\n\n/**\n * Reads a single byte and advances offset; you can pass in `true` to make this\n * a \"peek\" operation (i.e., get the byte, but don't advance the offset).\n *\n * @param {Boolean} peek true means don't move offset.\n * @return {Number} the next byte, null if not enough data.\n */\nReader.prototype.readByte = function (peek) {\n  if (this._size - this._offset < 1)\n    return null;\n\n  var b = this._buf[this._offset] & 0xff;\n\n  if (!peek)\n    this._offset += 1;\n\n  return b;\n};\n\n\nReader.prototype.peek = function () {\n  return this.readByte(true);\n};\n\n\n/**\n * Reads a (potentially) variable length off the BER buffer.  This call is\n * not really meant to be called directly, as callers have to manipulate\n * the internal buffer afterwards.\n *\n * As a result of this call, you can call `Reader.length`, until the\n * next thing called that does a readLength.\n *\n * @return {Number} the amount of offset to advance the buffer.\n * @throws {InvalidAsn1Error} on bad ASN.1\n */\nReader.prototype.readLength = function (offset) {\n  if (offset === undefined)\n    offset = this._offset;\n\n  if (offset >= this._size)\n    return null;\n\n  var lenB = this._buf[offset++] & 0xff;\n  if (lenB === null)\n    return null;\n\n  if ((lenB & 0x80) === 0x80) {\n    lenB &= 0x7f;\n\n    if (lenB === 0)\n      throw newInvalidAsn1Error('Indefinite length not supported');\n\n    if (lenB > 4)\n      throw newInvalidAsn1Error('encoding too long');\n\n    if (this._size - offset < lenB)\n      return null;\n\n    this._len = 0;\n    for (var i = 0; i < lenB; i++)\n      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);\n\n  } else {\n    // Wasn't a variable length\n    this._len = lenB;\n  }\n\n  return offset;\n};\n\n\n/**\n * Parses the next sequence in this BER buffer.\n *\n * To get the length of the sequence, call `Reader.length`.\n *\n * @return {Number} the sequence's tag.\n */\nReader.prototype.readSequence = function (tag) {\n  var seq = this.peek();\n  if (seq === null)\n    return null;\n  if (tag !== undefined && tag !== seq)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + seq.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  this._offset = o;\n  return seq;\n};\n\n\nReader.prototype.readInt = function () {\n  return this._readTag(ASN1.Integer);\n};\n\n\nReader.prototype.readBoolean = function () {\n  return (this._readTag(ASN1.Boolean) === 0 ? false : true);\n};\n\n\nReader.prototype.readEnumeration = function () {\n  return this._readTag(ASN1.Enumeration);\n};\n\n\nReader.prototype.readString = function (tag, retbuf) {\n  if (!tag)\n    tag = ASN1.OctetString;\n\n  var b = this.peek();\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n\n  if (o === null)\n    return null;\n\n  if (this.length > this._size - o)\n    return null;\n\n  this._offset = o;\n\n  if (this.length === 0)\n    return retbuf ? Buffer.alloc(0) : '';\n\n  var str = this._buf.slice(this._offset, this._offset + this.length);\n  this._offset += this.length;\n\n  return retbuf ? str : str.toString('utf8');\n};\n\nReader.prototype.readOID = function (tag) {\n  if (!tag)\n    tag = ASN1.OID;\n\n  var b = this.readString(tag, true);\n  if (b === null)\n    return null;\n\n  var values = [];\n  var value = 0;\n\n  for (var i = 0; i < b.length; i++) {\n    var byte = b[i] & 0xff;\n\n    value <<= 7;\n    value += byte & 0x7f;\n    if ((byte & 0x80) === 0) {\n      values.push(value);\n      value = 0;\n    }\n  }\n\n  value = values.shift();\n  values.unshift(value % 40);\n  values.unshift((value / 40) >> 0);\n\n  return values.join('.');\n};\n\n\nReader.prototype._readTag = function (tag) {\n  assert.ok(tag !== undefined);\n\n  var b = this.peek();\n\n  if (b === null)\n    return null;\n\n  if (b !== tag)\n    throw newInvalidAsn1Error('Expected 0x' + tag.toString(16) +\n                              ': got 0x' + b.toString(16));\n\n  var o = this.readLength(this._offset + 1); // stored in `length`\n  if (o === null)\n    return null;\n\n  if (this.length > 4)\n    throw newInvalidAsn1Error('Integer too long: ' + this.length);\n\n  if (this.length > this._size - o)\n    return null;\n  this._offset = o;\n\n  var fb = this._buf[this._offset];\n  var value = 0;\n\n  for (var i = 0; i < this.length; i++) {\n    value <<= 8;\n    value |= (this._buf[this._offset++] & 0xff);\n  }\n\n  if ((fb & 0x80) === 0x80 && i !== 4)\n    value -= (1 << (i * 8));\n\n  return value >> 0;\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Reader;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n\nmodule.exports = {\n  EOC: 0,\n  Boolean: 1,\n  Integer: 2,\n  BitString: 3,\n  OctetString: 4,\n  Null: 5,\n  OID: 6,\n  ObjectDescriptor: 7,\n  External: 8,\n  Real: 9, // float\n  Enumeration: 10,\n  PDV: 11,\n  Utf8String: 12,\n  RelativeOID: 13,\n  Sequence: 16,\n  Set: 17,\n  NumericString: 18,\n  PrintableString: 19,\n  T61String: 20,\n  VideotexString: 21,\n  IA5String: 22,\n  UTCTime: 23,\n  GeneralizedTime: 24,\n  GraphicString: 25,\n  VisibleString: 26,\n  GeneralString: 28,\n  UniversalString: 29,\n  CharacterString: 30,\n  BMPString: 31,\n  Constructor: 32,\n  Context: 128\n};\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\nvar assert = require('assert');\nvar Buffer = require('safer-buffer').Buffer;\nvar ASN1 = require('./types');\nvar errors = require('./errors');\n\n\n// --- Globals\n\nvar newInvalidAsn1Error = errors.newInvalidAsn1Error;\n\nvar DEFAULT_OPTS = {\n  size: 1024,\n  growthFactor: 8\n};\n\n\n// --- Helpers\n\nfunction merge(from, to) {\n  assert.ok(from);\n  assert.equal(typeof (from), 'object');\n  assert.ok(to);\n  assert.equal(typeof (to), 'object');\n\n  var keys = Object.getOwnPropertyNames(from);\n  keys.forEach(function (key) {\n    if (to[key])\n      return;\n\n    var value = Object.getOwnPropertyDescriptor(from, key);\n    Object.defineProperty(to, key, value);\n  });\n\n  return to;\n}\n\n\n\n// --- API\n\nfunction Writer(options) {\n  options = merge(DEFAULT_OPTS, options || {});\n\n  this._buf = Buffer.alloc(options.size || 1024);\n  this._size = this._buf.length;\n  this._offset = 0;\n  this._options = options;\n\n  // A list of offsets in the buffer where we need to insert\n  // sequence tag/len pairs.\n  this._seq = [];\n}\n\nObject.defineProperty(Writer.prototype, 'buffer', {\n  get: function () {\n    if (this._seq.length)\n      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');\n\n    return (this._buf.slice(0, this._offset));\n  }\n});\n\nWriter.prototype.writeByte = function (b) {\n  if (typeof (b) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(1);\n  this._buf[this._offset++] = b;\n};\n\n\nWriter.prototype.writeInt = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Integer;\n\n  var sz = 4;\n\n  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&\n        (sz > 1)) {\n    sz--;\n    i <<= 8;\n  }\n\n  if (sz > 4)\n    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');\n\n  this._ensure(2 + sz);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = sz;\n\n  while (sz-- > 0) {\n    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);\n    i <<= 8;\n  }\n\n};\n\n\nWriter.prototype.writeNull = function () {\n  this.writeByte(ASN1.Null);\n  this.writeByte(0x00);\n};\n\n\nWriter.prototype.writeEnumeration = function (i, tag) {\n  if (typeof (i) !== 'number')\n    throw new TypeError('argument must be a Number');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Enumeration;\n\n  return this.writeInt(i, tag);\n};\n\n\nWriter.prototype.writeBoolean = function (b, tag) {\n  if (typeof (b) !== 'boolean')\n    throw new TypeError('argument must be a Boolean');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Boolean;\n\n  this._ensure(3);\n  this._buf[this._offset++] = tag;\n  this._buf[this._offset++] = 0x01;\n  this._buf[this._offset++] = b ? 0xff : 0x00;\n};\n\n\nWriter.prototype.writeString = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OctetString;\n\n  var len = Buffer.byteLength(s);\n  this.writeByte(tag);\n  this.writeLength(len);\n  if (len) {\n    this._ensure(len);\n    this._buf.write(s, this._offset);\n    this._offset += len;\n  }\n};\n\n\nWriter.prototype.writeBuffer = function (buf, tag) {\n  if (typeof (tag) !== 'number')\n    throw new TypeError('tag must be a number');\n  if (!Buffer.isBuffer(buf))\n    throw new TypeError('argument must be a buffer');\n\n  this.writeByte(tag);\n  this.writeLength(buf.length);\n  this._ensure(buf.length);\n  buf.copy(this._buf, this._offset, 0, buf.length);\n  this._offset += buf.length;\n};\n\n\nWriter.prototype.writeStringArray = function (strings) {\n  if ((!strings instanceof Array))\n    throw new TypeError('argument must be an Array[String]');\n\n  var self = this;\n  strings.forEach(function (s) {\n    self.writeString(s);\n  });\n};\n\n// This is really to solve DER cases, but whatever for now\nWriter.prototype.writeOID = function (s, tag) {\n  if (typeof (s) !== 'string')\n    throw new TypeError('argument must be a string');\n  if (typeof (tag) !== 'number')\n    tag = ASN1.OID;\n\n  if (!/^([0-9]+\\.){3,}[0-9]+$/.test(s))\n    throw new Error('argument is not a valid OID string');\n\n  function encodeOctet(bytes, octet) {\n    if (octet < 128) {\n        bytes.push(octet);\n    } else if (octet < 16384) {\n        bytes.push((octet >>> 7) | 0x80);\n        bytes.push(octet & 0x7F);\n    } else if (octet < 2097152) {\n      bytes.push((octet >>> 14) | 0x80);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else if (octet < 268435456) {\n      bytes.push((octet >>> 21) | 0x80);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    } else {\n      bytes.push(((octet >>> 28) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 21) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 14) | 0x80) & 0xFF);\n      bytes.push(((octet >>> 7) | 0x80) & 0xFF);\n      bytes.push(octet & 0x7F);\n    }\n  }\n\n  var tmp = s.split('.');\n  var bytes = [];\n  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));\n  tmp.slice(2).forEach(function (b) {\n    encodeOctet(bytes, parseInt(b, 10));\n  });\n\n  var self = this;\n  this._ensure(2 + bytes.length);\n  this.writeByte(tag);\n  this.writeLength(bytes.length);\n  bytes.forEach(function (b) {\n    self.writeByte(b);\n  });\n};\n\n\nWriter.prototype.writeLength = function (len) {\n  if (typeof (len) !== 'number')\n    throw new TypeError('argument must be a Number');\n\n  this._ensure(4);\n\n  if (len <= 0x7f) {\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xff) {\n    this._buf[this._offset++] = 0x81;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffff) {\n    this._buf[this._offset++] = 0x82;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else if (len <= 0xffffff) {\n    this._buf[this._offset++] = 0x83;\n    this._buf[this._offset++] = len >> 16;\n    this._buf[this._offset++] = len >> 8;\n    this._buf[this._offset++] = len;\n  } else {\n    throw newInvalidAsn1Error('Length too long (> 4 bytes)');\n  }\n};\n\nWriter.prototype.startSequence = function (tag) {\n  if (typeof (tag) !== 'number')\n    tag = ASN1.Sequence | ASN1.Constructor;\n\n  this.writeByte(tag);\n  this._seq.push(this._offset);\n  this._ensure(3);\n  this._offset += 3;\n};\n\n\nWriter.prototype.endSequence = function () {\n  var seq = this._seq.pop();\n  var start = seq + 3;\n  var len = this._offset - start;\n\n  if (len <= 0x7f) {\n    this._shift(start, len, -2);\n    this._buf[seq] = len;\n  } else if (len <= 0xff) {\n    this._shift(start, len, -1);\n    this._buf[seq] = 0x81;\n    this._buf[seq + 1] = len;\n  } else if (len <= 0xffff) {\n    this._buf[seq] = 0x82;\n    this._buf[seq + 1] = len >> 8;\n    this._buf[seq + 2] = len;\n  } else if (len <= 0xffffff) {\n    this._shift(start, len, 1);\n    this._buf[seq] = 0x83;\n    this._buf[seq + 1] = len >> 16;\n    this._buf[seq + 2] = len >> 8;\n    this._buf[seq + 3] = len;\n  } else {\n    throw newInvalidAsn1Error('Sequence too long');\n  }\n};\n\n\nWriter.prototype._shift = function (start, len, shift) {\n  assert.ok(start !== undefined);\n  assert.ok(len !== undefined);\n  assert.ok(shift);\n\n  this._buf.copy(this._buf, start + shift, start, start + len);\n  this._offset += shift;\n};\n\nWriter.prototype._ensure = function (len) {\n  assert.ok(len);\n\n  if (this._size - this._offset < len) {\n    var sz = this._size * this._options.growthFactor;\n    if (sz - this._offset < len)\n      sz += len;\n\n    var buf = Buffer.alloc(sz);\n\n    this._buf.copy(buf, 0, 0, this._offset);\n    this._buf = buf;\n    this._size = sz;\n  }\n};\n\n\n\n// --- Exported API\n\nmodule.exports = Writer;\n","// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.\n\n// If you have no idea what ASN.1 or BER is, see this:\n// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc\n\nvar Ber = require('./ber/index');\n\n\n\n// --- Exported API\n\nmodule.exports = {\n\n  Ber: Ber,\n\n  BerReader: Ber.Reader,\n\n  BerWriter: Ber.Writer\n\n};\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { Component } from '@angular/core'\nimport { ProfileSettingsComponent, SelectorService } from 'tabby-core'\nimport { DockerProfile } from '../profiles'\nimport { Container, DockerService, Image } from '../services/docker.service'\n\n/** @hidden */\n@Component({\n    template: require('./dockerProfileSettings.component.pug'),\n})\nexport class DockerProfileSettingsComponent implements ProfileSettingsComponent<DockerProfile> {\n    profile: DockerProfile\n    images: Image[] = []\n    containers: Container[] = []\n    startMode = 'image'\n\n    constructor (\n        docker: DockerService,\n        private selector: SelectorService,\n    ) {\n        docker.listContainers().then(containers => {\n            this.containers = containers\n            this.containers.sort((a, b) => a.names[0].localeCompare(b.names[0]))\n        })\n        docker.listImages().then(images => {\n            this.images = images\n            this.images.sort((a, b) => a.description.localeCompare(b.description))\n        })\n    }\n\n    ngOnInit () {\n        if (this.profile.options.containerName) {\n            this.startMode = 'container'\n        }\n    }\n\n    updateStartMode () {\n        if (this.startMode === 'container') {\n            this.profile.options.imageID = null\n        } else {\n            this.profile.options.containerID = null\n            this.profile.options.containerName = null\n        }\n    }\n\n    getImageDescription () {\n        return this.images.find(x => x.id === this.profile.options.imageID)?.description ?? this.profile.options.imageID ?? 'Not selected'\n    }\n\n    async pickImage () {\n        const img = await this.selector.show('Select image', this.images.map(img => ({\n            result: img,\n            name: img.description,\n            description: img.description === img.id ? null : img.id,\n        })))\n        this.profile.options.imageID = img.id\n    }\n\n    clearContainerID () {\n        this.profile.options.containerID = null\n    }\n}\n","import { Component, HostBinding } from '@angular/core'\nimport { DockerService } from 'services/docker.service'\nimport { BaseComponent, ConfigService } from 'tabby-core'\n\n/** @hidden */\n@Component({\n    template: require('./dockerSettingsTab.component.pug'),\n})\nexport class DockerSettingsTabComponent extends BaseComponent {\n    @HostBinding('class.content-box') true\n    connected = false\n\n    constructor (\n        public config: ConfigService,\n        private docker: DockerService,\n    ) {\n        super()\n        this.subscribeUntilDestroyed(this.config.changed$, async () => {\n            this.connected = false\n            await this.docker.listContainers()\n            this.connected = true\n        })\n    }\n}\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { Component, Injector } from '@angular/core'\nimport { first } from 'rxjs'\nimport { BaseTerminalTabComponent } from 'tabby-terminal'\nimport { DockerProfile } from '../profiles'\nimport { DockerSession } from '../session'\n\n/** @hidden */\n@Component({\n    selector: 'docker-tab',\n    template: BaseTerminalTabComponent.template,\n    styles: BaseTerminalTabComponent.styles,\n    animations: BaseTerminalTabComponent.animations,\n})\nexport class DockerTabComponent extends BaseTerminalTabComponent {\n    profile?: DockerProfile\n    session: DockerSession|null = null\n\n    // eslint-disable-next-line @typescript-eslint/no-useless-constructor\n    constructor (\n        injector: Injector,\n    ) {\n        super(injector)\n    }\n\n    ngOnInit () {\n        this.logger = this.log.create('dockerTab')\n\n        this.subscribeUntilDestroyed(this.hotkeys.hotkey$, hotkey => {\n            if (!this.hasFocus) {\n                return\n            }\n            switch (hotkey) {\n                case 'home':\n                    this.sendInput('\\x1b[H')\n                    break\n                case 'end':\n                    this.sendInput('\\x1b[F')\n                    break\n            }\n        })\n\n        this.frontendReady$.pipe(first()).subscribe(() => {\n            this.initializeSession()\n        })\n\n        super.ngOnInit()\n\n        setImmediate(() => {\n            this.setTitle(this.profile!.name)\n        })\n    }\n\n    async initializeSession () {\n        if (!this.profile) {\n            this.logger.error('No profile info supplied')\n            return\n        }\n\n        const session = new DockerSession(this.injector, this.profile)\n        this.setSession(session, true)\n\n        this.startSpinner('Connecting')\n\n        try {\n            await this.session!.start()\n            this.stopSpinner()\n        } catch (e) {\n            this.stopSpinner()\n            this.write(e.message + '\\r\\n')\n            return\n        }\n        this.session!.resize(this.size.columns, this.size.rows)\n    }\n\n    async getRecoveryToken (): Promise<any> {\n        return {\n            type: 'app:docker-tab',\n            profile: this.profile,\n            savedState: this.frontend?.saveState(),\n        }\n    }\n}\n","import { ConfigProvider } from 'tabby-core'\n\n/** @hidden */\nexport class DockerConfigProvider extends ConfigProvider {\n    defaults = {\n        docker: {\n            host: null,\n            port: null,\n            socket: null,\n        },\n    }\n\n    platformDefaults = { }\n}\n","import { NgModule } from '@angular/core'\nimport { CommonModule } from '@angular/common'\nimport { FormsModule } from '@angular/forms'\nimport { NgbModule } from '@ng-bootstrap/ng-bootstrap'\nimport TabbyCoreModule, { ConfigProvider, ProfileProvider, TabRecoveryProvider } from 'tabby-core'\nimport TabbyTerminalModule from 'tabby-terminal'\nimport { SettingsTabProvider } from 'tabby-settings'\n\nimport { DockerTabComponent } from './components/dockerTab.component'\nimport { DockerProfileSettingsComponent } from './components/dockerProfileSettings.component'\nimport { DockerProfileProvider } from './profiles'\nimport { RecoveryProvider } from './recoveryProvider'\nimport { DockerConfigProvider } from './config'\nimport { DockerSettingsTabProvider } from './settings'\nimport { DockerSettingsTabComponent } from 'components/dockerSettingsTab.component'\n\n@NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        TabbyCoreModule,\n        TabbyTerminalModule,\n        NgbModule,\n    ],\n    providers: [\n        { provide: ProfileProvider, useClass: DockerProfileProvider, multi: true },\n        { provide: TabRecoveryProvider, useClass: RecoveryProvider, multi: true },\n        { provide: ConfigProvider, useClass: DockerConfigProvider, multi: true },\n        { provide: SettingsTabProvider, useClass: DockerSettingsTabProvider, multi: true },\n    ],\n    entryComponents: [\n        DockerTabComponent,\n        DockerProfileSettingsComponent,\n        DockerSettingsTabComponent,\n    ],\n    declarations: [\n        DockerTabComponent,\n        DockerProfileSettingsComponent,\n        DockerSettingsTabComponent,\n    ],\n})\nexport default class DockerModule { }\n","import { Injectable } from '@angular/core'\nimport { BaseTabComponent, NewTabParameters, PartialProfile, Profile, ProfileProvider } from 'tabby-core'\nimport { DockerTabComponent } from './components/dockerTab.component'\nimport { DockerProfileSettingsComponent } from './components/dockerProfileSettings.component'\nimport { Container, DockerService } from './services/docker.service'\n\nexport interface DockerProfileOptions {\n    containerID?: string\n    containerName?: string\n    imageID?: string\n    command: string\n}\n\nexport interface DockerProfile extends Profile {\n    type: 'docker'\n    options: DockerProfileOptions\n}\n\n@Injectable()\nexport class DockerProfileProvider extends ProfileProvider<DockerProfile> {\n    id = 'docker'\n    name = 'Docker'\n    weight = 10\n    settingsComponent = DockerProfileSettingsComponent\n    configDefaults = {\n        options: {\n            containerID: null,\n            containerName: null,\n            imageID: null,\n            command: null,\n        }\n    }\n\n    constructor (private docker: DockerService) {\n        super()\n    }\n\n    async getBuiltinProfiles (): Promise<PartialProfile<DockerProfile>[]> {\n        let containers: Container[]\n        try {\n            containers = await this.docker.listContainers()\n        } catch (e) {\n            console.error('Could not load Docker containers:', e)\n            return []\n        }\n        return [\n            ...containers.map(container => ({\n                id: `docker:container-${container.id}`,\n                type: 'docker',\n                name: container.names[0] + (container.image ? ` (${container.image})` : ''),\n                isBuiltin: true,\n                icon: 'fab fa-docker',\n                options: {\n                    containerID: container.id,\n                    containerName: container.names[0],\n                },\n            })),\n            {\n                id: `docker:template`,\n                type: 'docker',\n                name: 'Docker container shell',\n                isBuiltin: true,\n                isTemplate: true,\n                icon: 'fab fa-docker',\n                options: { },\n            }\n        ]\n    }\n\n    async getNewTabParameters (profile: DockerProfile): Promise<NewTabParameters<BaseTabComponent>> {\n        return {\n            type: DockerTabComponent,\n            inputs: {\n                profile,\n            },\n        }\n    }\n\n    getDescription (_profile: PartialProfile<DockerProfile>): string {\n        return ''\n    }\n\n}\n","import { Injectable } from '@angular/core'\nimport { TabRecoveryProvider, NewTabParameters, RecoveryToken } from 'tabby-core'\nimport { DockerTabComponent } from './components/dockerTab.component'\n\n/** @hidden */\n@Injectable()\nexport class RecoveryProvider extends TabRecoveryProvider<DockerTabComponent> {\n    async applicableTo (recoveryToken: RecoveryToken): Promise<boolean> {\n        return recoveryToken.type === 'app:docker-tab'\n    }\n\n    async recover (recoveryToken: RecoveryToken): Promise<NewTabParameters<DockerTabComponent>> {\n        return {\n            type: DockerTabComponent,\n            inputs: {\n                profile: recoveryToken.profile,\n                savedState: recoveryToken.savedState,\n            },\n        }\n    }\n}\n","import { v4 as uuidv4 } from 'uuid'\nimport slugify from 'slugify'\nimport Docker, { ImageInfo } from 'dockerode'\nimport { Injectable } from '@angular/core'\nimport { Observable, Subject } from 'rxjs'\nimport type { Duplex } from 'stream'\nimport { ConfigService, Logger, LogService } from 'tabby-core'\n\nexport interface Container {\n    id: string\n    names: string[]\n    image: string\n    state: string\n}\n\nexport interface Image {\n    id: string\n    description: string\n    tags: string[]\n}\n\nexport class DockerProcess {\n    get output$ (): Observable<Buffer> { return this.output }\n    get closed$ (): Observable<void> { return this.closed }\n    private output = new Subject<Buffer>()\n    private closed = new Subject<void>()\n    private stream: Duplex\n    private dead = false\n\n    constructor (private exec: any) { }\n\n    async start (): Promise<void> {\n        this.stream = await this.exec.start({\n            hijack: true,\n            stdin: true,\n            Tty: true,\n        })\n        this.stream.on('data', data => this.output.next(data))\n        this.stream.on('close', () => {\n            this.dead = true\n            this.close()\n        })\n    }\n\n    async resize (w: number, h: number): Promise<void> {\n        await this.exec.resize({ w, h })\n    }\n\n    write (data: Buffer) {\n        if (!this.dead) {\n            this.stream.write(data)\n        }\n    }\n\n    async stop (): Promise<void> {\n        this.write(Buffer.from([31])) // Ctrl-_\n        const state = await this.exec.inspect()\n        if (state.Pid && !this.dead) {\n            try {\n                process.kill(state.Pid)\n            } catch (e) {\n                if (!e.toString().includes('ESRCH')) {\n                    throw e\n                }\n            }\n        }\n    }\n\n    private close () {\n        this.output.complete()\n        this.closed.next()\n        this.closed.complete()\n    }\n}\n\n@Injectable({ providedIn: 'root' })\nexport class DockerService {\n    logger: Logger\n\n    constructor (log: LogService, private config: ConfigService) {\n        this.logger = log.create('docker')\n    }\n\n    async listContainers (): Promise<Container[]> {\n        return (await this.getDocker().listContainers()).map(container => ({\n            id: container.Id,\n            names: container.Names ?? [],\n            image: container.Image,\n            state: container.State,\n        }))\n    }\n\n    async listImages (): Promise<Image[]> {\n        return (await this.getDocker().listImages()).map(image => ({\n            id: image.Id,\n            description: this.getImageDescription(image),\n            tags: image.RepoTags,\n        }))\n    }\n\n    async createContainer (imageID: string, name: string, args: string[]|null): Promise<Container> {\n        this.logger.info('run', args, 'in', imageID)\n        const container = await this.getDocker().createContainer({\n            name: slugify(`tabby-${name}-${uuidv4()}`),\n            AttachStdin: true,\n            AttachStdout: true,\n            AttachStderr: true,\n            Tty: true,\n            OpenStdin: true,\n            Entrypoint: args ?? undefined,\n            Image: imageID,\n        })\n        await container.start()\n        const info = await container.inspect()\n        return {\n            id: info.Id,\n            names: [info.Name],\n            image: info.Image,\n            state: info.State.Status,\n        }\n    }\n\n    async destroyContainer (containerID: string): Promise<void> {\n        const container = await this.getDocker().getContainer(containerID)\n        try {\n            await container.kill()\n        } catch { }\n        await container.remove()\n    }\n\n    async exec (containerID: string, args: string[]): Promise<DockerProcess> {\n        this.logger.info('exec', args, 'in', containerID)\n        const container = await this.getDocker().getContainer(containerID)\n        const exec = await container.exec({\n            Cmd: args,\n            DetachKeys: 'ctrl-_',\n            AttachStdin: true,\n            AttachStdout: true,\n            AttachStderr: true,\n            Tty: true,\n        })\n        return new DockerProcess(exec)\n    }\n\n    getImageDescription (image: ImageInfo): string {\n        if (image.RepoTags[0] === '<none>:<none>') {\n            return image.Id\n        }\n        return image.RepoTags[0]\n    }\n\n    private getDocker (): Docker {\n        let opts: any = {}\n        if (this.config.store.docker.socket) {\n            opts.socketPath = this.config.store.docker.socket\n        }\n        if (this.config.store.docker.host) {\n            opts.host = this.config.store.docker.host\n        }\n        if (this.config.store.docker.port) {\n            opts.port = this.config.store.docker.port\n        }\n        return new Docker(opts)\n    }\n\n}\n","import * as shellQuote from 'shell-quote'\nimport { Injector } from '@angular/core'\nimport { LogService } from 'tabby-core'\nimport { BaseSession } from 'tabby-terminal'\nimport { DockerProfile } from './profiles'\nimport { Container, DockerProcess, DockerService } from './services/docker.service'\n\nexport class DockerSession extends BaseSession {\n    private docker: DockerService\n    private process: DockerProcess|undefined\n    private container: Container|undefined\n\n    constructor (injector: Injector, private profile: DockerProfile) {\n        super(injector.get(LogService).create(`docker-${profile.options.containerName ?? profile.options.containerID ?? profile.options.imageID ?? 'unknown'}`))\n        this.docker = injector.get(DockerService)\n    }\n\n    async start (): Promise<void> {\n        let containerID = this.profile.options.containerID\n        let args: string|string[] = this.profile.options.command || '/bin/sh'\n        if (args && args[0].length > 0) {\n            args = shellQuote.parse(args)\n        }\n\n        if (this.profile.options.imageID) {\n            this.emitOutput(Buffer.from(`Starting container with image ${this.profile.options.imageID}\\r\\n`))\n            this.container = await this.docker.createContainer(this.profile.options.imageID, this.profile.name, ['/bin/cat'])\n            containerID = this.container.id\n        }\n\n        if (!containerID && this.profile.options.containerName) {\n            containerID = (await this.docker.listContainers()).find(x => x.names.includes(this.profile.options.containerName)).id\n            if (!containerID) {\n                throw new Error(`Container ${this.profile.options.containerName} not found`)\n            }\n        }\n\n        this.emitOutput(Buffer.from(`Attaching to ${containerID}\\r\\n`))\n        this.process = await this.docker.exec(\n            containerID,\n            args as string[],\n        )\n        this.process.output$.subscribe(data => {\n            this.emitOutput(data)\n        })\n        this.process.closed$.subscribe(() => this.destroy())\n        await this.process.start()\n        this.logger.info('Attached')\n        this.open = true\n    }\n\n    resize (columns: number, rows: number): void {\n        this.process?.resize(columns, rows)\n    }\n\n    write (data: Buffer): void {\n        this.process?.write(data)\n    }\n\n    kill (): void {\n        if (this.container) {\n            this.docker.destroyContainer(this.container.id)\n        }\n        this.process?.stop()\n    }\n\n    async gracefullyKillProcess (): Promise<void> {\n        this.process?.stop()\n    }\n\n    supportsWorkingDirectory (): boolean {\n        return false\n    }\n\n    async getWorkingDirectory (): Promise<null> {\n        return null\n    }\n}\n","import { Injectable } from '@angular/core'\nimport { SettingsTabProvider } from 'tabby-settings'\n\nimport { DockerSettingsTabComponent } from './components/dockerSettingsTab.component'\n\n/** @hidden */\n@Injectable()\nexport class DockerSettingsTabProvider extends SettingsTabProvider {\n    id = 'docker'\n    icon = 'docker fab'\n    title = 'Docker'\n\n    getComponentType (): any {\n        return DockerSettingsTabComponent\n    }\n}\n","'use strict';\n\nvar crypto_hash_sha512 = require('tweetnacl').lowlevel.crypto_hash;\n\n/*\n * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a\n * result, it retains the original copyright and license. The two files are\n * under slightly different (but compatible) licenses, and are here combined in\n * one file.\n *\n * Credit for the actual porting work goes to:\n *  Devi Mandiri <me@devi.web.id>\n */\n\n/*\n * The Blowfish portions are under the following license:\n *\n * Blowfish block cipher for OpenBSD\n * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>\n * All rights reserved.\n *\n * Implementation advice by David Mazieres <dm@lcs.mit.edu>.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * The bcrypt_pbkdf portions are under the following license:\n *\n * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * Performance improvements (Javascript-specific):\n *\n * Copyright 2016, Joyent Inc\n * Author: Alex Wilson <alex.wilson@joyent.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n// Ported from OpenBSD bcrypt_pbkdf.c v1.9\n\nvar BLF_J = 0;\n\nvar Blowfish = function() {\n  this.S = [\n    new Uint32Array([\n      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,\n      0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,\n      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,\n      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,\n      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,\n      0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,\n      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,\n      0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,\n      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,\n      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,\n      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,\n      0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,\n      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,\n      0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,\n      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,\n      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,\n      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,\n      0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,\n      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,\n      0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,\n      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,\n      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,\n      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,\n      0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,\n      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,\n      0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,\n      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,\n      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,\n      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,\n      0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,\n      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,\n      0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,\n      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,\n      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,\n      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,\n      0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,\n      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,\n      0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,\n      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,\n      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,\n      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,\n      0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,\n      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,\n      0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,\n      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,\n      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,\n      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,\n      0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,\n      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,\n      0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,\n      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,\n      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,\n      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,\n      0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,\n      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,\n      0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,\n      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,\n      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,\n      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,\n      0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,\n      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,\n      0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,\n      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,\n      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]),\n    new Uint32Array([\n      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,\n      0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,\n      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,\n      0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,\n      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,\n      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,\n      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,\n      0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,\n      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,\n      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,\n      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,\n      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,\n      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,\n      0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,\n      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,\n      0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,\n      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,\n      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,\n      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,\n      0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,\n      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,\n      0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,\n      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,\n      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,\n      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,\n      0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,\n      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,\n      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,\n      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,\n      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,\n      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,\n      0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,\n      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,\n      0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,\n      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,\n      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,\n      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,\n      0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,\n      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,\n      0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,\n      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,\n      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,\n      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,\n      0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,\n      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,\n      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,\n      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,\n      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,\n      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,\n      0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,\n      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,\n      0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,\n      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,\n      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,\n      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,\n      0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,\n      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,\n      0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,\n      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,\n      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,\n      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,\n      0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,\n      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,\n      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]),\n    new Uint32Array([\n      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,\n      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,\n      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,\n      0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,\n      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,\n      0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,\n      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,\n      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,\n      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,\n      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,\n      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,\n      0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,\n      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,\n      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,\n      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,\n      0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,\n      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,\n      0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,\n      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,\n      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,\n      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,\n      0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,\n      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,\n      0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,\n      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,\n      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,\n      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,\n      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,\n      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,\n      0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,\n      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,\n      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,\n      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,\n      0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,\n      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,\n      0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,\n      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,\n      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,\n      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,\n      0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,\n      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,\n      0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,\n      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,\n      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,\n      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,\n      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,\n      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,\n      0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,\n      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,\n      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,\n      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,\n      0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,\n      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,\n      0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,\n      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,\n      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,\n      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,\n      0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,\n      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,\n      0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,\n      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,\n      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,\n      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,\n      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]),\n    new Uint32Array([\n      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,\n      0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,\n      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,\n      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,\n      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,\n      0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,\n      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,\n      0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,\n      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,\n      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,\n      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,\n      0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,\n      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,\n      0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,\n      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,\n      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,\n      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,\n      0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,\n      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,\n      0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,\n      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,\n      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,\n      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,\n      0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,\n      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,\n      0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,\n      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,\n      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,\n      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,\n      0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,\n      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,\n      0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,\n      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,\n      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,\n      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,\n      0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,\n      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,\n      0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,\n      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,\n      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,\n      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,\n      0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,\n      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,\n      0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,\n      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,\n      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,\n      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,\n      0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,\n      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,\n      0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,\n      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,\n      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,\n      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,\n      0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,\n      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,\n      0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,\n      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,\n      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,\n      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,\n      0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,\n      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,\n      0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,\n      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,\n      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])\n    ];\n  this.P = new Uint32Array([\n    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,\n    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,\n    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,\n    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,\n    0x9216d5d9, 0x8979fb1b]);\n};\n\nfunction F(S, x8, i) {\n  return (((S[0][x8[i+3]] +\n            S[1][x8[i+2]]) ^\n            S[2][x8[i+1]]) +\n            S[3][x8[i]]);\n};\n\nBlowfish.prototype.encipher = function(x, x8) {\n  if (x8 === undefined) {\n    x8 = new Uint8Array(x.buffer);\n    if (x.byteOffset !== 0)\n      x8 = x8.subarray(x.byteOffset);\n  }\n  x[0] ^= this.P[0];\n  for (var i = 1; i < 16; i += 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i+1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[17];\n  x[1] = t;\n};\n\nBlowfish.prototype.decipher = function(x) {\n  var x8 = new Uint8Array(x.buffer);\n  if (x.byteOffset !== 0)\n    x8 = x8.subarray(x.byteOffset);\n  x[0] ^= this.P[17];\n  for (var i = 16; i > 0; i -= 2) {\n    x[1] ^= F(this.S, x8, 0) ^ this.P[i];\n    x[0] ^= F(this.S, x8, 4) ^ this.P[i-1];\n  }\n  var t = x[0];\n  x[0] = x[1] ^ this.P[0];\n  x[1] = t;\n};\n\nfunction stream2word(data, databytes){\n  var i, temp = 0;\n  for (i = 0; i < 4; i++, BLF_J++) {\n    if (BLF_J >= databytes) BLF_J = 0;\n    temp = (temp << 8) | data[BLF_J];\n  }\n  return temp;\n};\n\nBlowfish.prototype.expand0state = function(key, keybytes) {\n  var d = new Uint32Array(2), i, k;\n  var d8 = new Uint8Array(d.buffer);\n\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n  BLF_J = 0;\n\n  for (i = 0; i < 18; i += 2) {\n    this.encipher(d, d8);\n    this.P[i]   = d[0];\n    this.P[i+1] = d[1];\n  }\n\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      this.encipher(d, d8);\n      this.S[i][k]   = d[0];\n      this.S[i][k+1] = d[1];\n    }\n  }\n};\n\nBlowfish.prototype.expandstate = function(data, databytes, key, keybytes) {\n  var d = new Uint32Array(2), i, k;\n\n  for (i = 0, BLF_J = 0; i < 18; i++) {\n    this.P[i] ^= stream2word(key, keybytes);\n  }\n\n  for (i = 0, BLF_J = 0; i < 18; i += 2) {\n    d[0] ^= stream2word(data, databytes);\n    d[1] ^= stream2word(data, databytes);\n    this.encipher(d);\n    this.P[i]   = d[0];\n    this.P[i+1] = d[1];\n  }\n\n  for (i = 0; i < 4; i++) {\n    for (k = 0; k < 256; k += 2) {\n      d[0] ^= stream2word(data, databytes);\n      d[1] ^= stream2word(data, databytes);\n      this.encipher(d);\n      this.S[i][k]   = d[0];\n      this.S[i][k+1] = d[1];\n    }\n  }\n  BLF_J = 0;\n};\n\nBlowfish.prototype.enc = function(data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.encipher(data.subarray(i*2));\n  }\n};\n\nBlowfish.prototype.dec = function(data, blocks) {\n  for (var i = 0; i < blocks; i++) {\n    this.decipher(data.subarray(i*2));\n  }\n};\n\nvar BCRYPT_BLOCKS = 8,\n    BCRYPT_HASHSIZE = 32;\n\nfunction bcrypt_hash(sha2pass, sha2salt, out) {\n  var state = new Blowfish(),\n      cdata = new Uint32Array(BCRYPT_BLOCKS), i,\n      ciphertext = new Uint8Array([79,120,121,99,104,114,111,109,97,116,105,\n            99,66,108,111,119,102,105,115,104,83,119,97,116,68,121,110,97,109,\n            105,116,101]); //\"OxychromaticBlowfishSwatDynamite\"\n\n  state.expandstate(sha2salt, 64, sha2pass, 64);\n  for (i = 0; i < 64; i++) {\n    state.expand0state(sha2salt, 64);\n    state.expand0state(sha2pass, 64);\n  }\n\n  for (i = 0; i < BCRYPT_BLOCKS; i++)\n    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);\n  for (i = 0; i < 64; i++)\n    state.enc(cdata, cdata.byteLength / 8);\n\n  for (i = 0; i < BCRYPT_BLOCKS; i++) {\n    out[4*i+3] = cdata[i] >>> 24;\n    out[4*i+2] = cdata[i] >>> 16;\n    out[4*i+1] = cdata[i] >>> 8;\n    out[4*i+0] = cdata[i];\n  }\n};\n\nfunction bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {\n  var sha2pass = new Uint8Array(64),\n      sha2salt = new Uint8Array(64),\n      out = new Uint8Array(BCRYPT_HASHSIZE),\n      tmpout = new Uint8Array(BCRYPT_HASHSIZE),\n      countsalt = new Uint8Array(saltlen+4),\n      i, j, amt, stride, dest, count,\n      origkeylen = keylen;\n\n  if (rounds < 1)\n    return -1;\n  if (passlen === 0 || saltlen === 0 || keylen === 0 ||\n      keylen > (out.byteLength * out.byteLength) || saltlen > (1<<20))\n    return -1;\n\n  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);\n  amt = Math.floor((keylen + stride - 1) / stride);\n\n  for (i = 0; i < saltlen; i++)\n    countsalt[i] = salt[i];\n\n  crypto_hash_sha512(sha2pass, pass, passlen);\n\n  for (count = 1; keylen > 0; count++) {\n    countsalt[saltlen+0] = count >>> 24;\n    countsalt[saltlen+1] = count >>> 16;\n    countsalt[saltlen+2] = count >>>  8;\n    countsalt[saltlen+3] = count;\n\n    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);\n    bcrypt_hash(sha2pass, sha2salt, tmpout);\n    for (i = out.byteLength; i--;)\n      out[i] = tmpout[i];\n\n    for (i = 1; i < rounds; i++) {\n      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);\n      bcrypt_hash(sha2pass, sha2salt, tmpout);\n      for (j = 0; j < out.byteLength; j++)\n        out[j] ^= tmpout[j];\n    }\n\n    amt = Math.min(amt, keylen);\n    for (i = 0; i < amt; i++) {\n      dest = i * stride + (count - 1);\n      if (dest >= origkeylen)\n        break;\n      key[dest] = out[i];\n    }\n    keylen -= i;\n  }\n\n  return 0;\n};\n\nmodule.exports = {\n      BLOCKS: BCRYPT_BLOCKS,\n      HASHSIZE: BCRYPT_HASHSIZE,\n      hash: bcrypt_hash,\n      pbkdf: bcrypt_pbkdf\n};\n","'use strict'\n\nconst { Buffer } = require('buffer')\nconst symbol = Symbol.for('BufferList')\n\nfunction BufferList (buf) {\n  if (!(this instanceof BufferList)) {\n    return new BufferList(buf)\n  }\n\n  BufferList._init.call(this, buf)\n}\n\nBufferList._init = function _init (buf) {\n  Object.defineProperty(this, symbol, { value: true })\n\n  this._bufs = []\n  this.length = 0\n\n  if (buf) {\n    this.append(buf)\n  }\n}\n\nBufferList.prototype._new = function _new (buf) {\n  return new BufferList(buf)\n}\n\nBufferList.prototype._offset = function _offset (offset) {\n  if (offset === 0) {\n    return [0, 0]\n  }\n\n  let tot = 0\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    const _t = tot + this._bufs[i].length\n    if (offset < _t || i === this._bufs.length - 1) {\n      return [i, offset - tot]\n    }\n    tot = _t\n  }\n}\n\nBufferList.prototype._reverseOffset = function (blOffset) {\n  const bufferId = blOffset[0]\n  let offset = blOffset[1]\n\n  for (let i = 0; i < bufferId; i++) {\n    offset += this._bufs[i].length\n  }\n\n  return offset\n}\n\nBufferList.prototype.get = function get (index) {\n  if (index > this.length || index < 0) {\n    return undefined\n  }\n\n  const offset = this._offset(index)\n\n  return this._bufs[offset[0]][offset[1]]\n}\n\nBufferList.prototype.slice = function slice (start, end) {\n  if (typeof start === 'number' && start < 0) {\n    start += this.length\n  }\n\n  if (typeof end === 'number' && end < 0) {\n    end += this.length\n  }\n\n  return this.copy(null, 0, start, end)\n}\n\nBufferList.prototype.copy = function copy (dst, dstStart, srcStart, srcEnd) {\n  if (typeof srcStart !== 'number' || srcStart < 0) {\n    srcStart = 0\n  }\n\n  if (typeof srcEnd !== 'number' || srcEnd > this.length) {\n    srcEnd = this.length\n  }\n\n  if (srcStart >= this.length) {\n    return dst || Buffer.alloc(0)\n  }\n\n  if (srcEnd <= 0) {\n    return dst || Buffer.alloc(0)\n  }\n\n  const copy = !!dst\n  const off = this._offset(srcStart)\n  const len = srcEnd - srcStart\n  let bytes = len\n  let bufoff = (copy && dstStart) || 0\n  let start = off[1]\n\n  // copy/slice everything\n  if (srcStart === 0 && srcEnd === this.length) {\n    if (!copy) {\n      // slice, but full concat if multiple buffers\n      return this._bufs.length === 1\n        ? this._bufs[0]\n        : Buffer.concat(this._bufs, this.length)\n    }\n\n    // copy, need to copy individual buffers\n    for (let i = 0; i < this._bufs.length; i++) {\n      this._bufs[i].copy(dst, bufoff)\n      bufoff += this._bufs[i].length\n    }\n\n    return dst\n  }\n\n  // easy, cheap case where it's a subset of one of the buffers\n  if (bytes <= this._bufs[off[0]].length - start) {\n    return copy\n      ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes)\n      : this._bufs[off[0]].slice(start, start + bytes)\n  }\n\n  if (!copy) {\n    // a slice, we need something to copy in to\n    dst = Buffer.allocUnsafe(len)\n  }\n\n  for (let i = off[0]; i < this._bufs.length; i++) {\n    const l = this._bufs[i].length - start\n\n    if (bytes > l) {\n      this._bufs[i].copy(dst, bufoff, start)\n      bufoff += l\n    } else {\n      this._bufs[i].copy(dst, bufoff, start, start + bytes)\n      bufoff += l\n      break\n    }\n\n    bytes -= l\n\n    if (start) {\n      start = 0\n    }\n  }\n\n  // safeguard so that we don't return uninitialized memory\n  if (dst.length > bufoff) return dst.slice(0, bufoff)\n\n  return dst\n}\n\nBufferList.prototype.shallowSlice = function shallowSlice (start, end) {\n  start = start || 0\n  end = typeof end !== 'number' ? this.length : end\n\n  if (start < 0) {\n    start += this.length\n  }\n\n  if (end < 0) {\n    end += this.length\n  }\n\n  if (start === end) {\n    return this._new()\n  }\n\n  const startOffset = this._offset(start)\n  const endOffset = this._offset(end)\n  const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1)\n\n  if (endOffset[1] === 0) {\n    buffers.pop()\n  } else {\n    buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1])\n  }\n\n  if (startOffset[1] !== 0) {\n    buffers[0] = buffers[0].slice(startOffset[1])\n  }\n\n  return this._new(buffers)\n}\n\nBufferList.prototype.toString = function toString (encoding, start, end) {\n  return this.slice(start, end).toString(encoding)\n}\n\nBufferList.prototype.consume = function consume (bytes) {\n  // first, normalize the argument, in accordance with how Buffer does it\n  bytes = Math.trunc(bytes)\n  // do nothing if not a positive number\n  if (Number.isNaN(bytes) || bytes <= 0) return this\n\n  while (this._bufs.length) {\n    if (bytes >= this._bufs[0].length) {\n      bytes -= this._bufs[0].length\n      this.length -= this._bufs[0].length\n      this._bufs.shift()\n    } else {\n      this._bufs[0] = this._bufs[0].slice(bytes)\n      this.length -= bytes\n      break\n    }\n  }\n\n  return this\n}\n\nBufferList.prototype.duplicate = function duplicate () {\n  const copy = this._new()\n\n  for (let i = 0; i < this._bufs.length; i++) {\n    copy.append(this._bufs[i])\n  }\n\n  return copy\n}\n\nBufferList.prototype.append = function append (buf) {\n  if (buf == null) {\n    return this\n  }\n\n  if (buf.buffer) {\n    // append a view of the underlying ArrayBuffer\n    this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength))\n  } else if (Array.isArray(buf)) {\n    for (let i = 0; i < buf.length; i++) {\n      this.append(buf[i])\n    }\n  } else if (this._isBufferList(buf)) {\n    // unwrap argument into individual BufferLists\n    for (let i = 0; i < buf._bufs.length; i++) {\n      this.append(buf._bufs[i])\n    }\n  } else {\n    // coerce number arguments to strings, since Buffer(number) does\n    // uninitialized memory allocation\n    if (typeof buf === 'number') {\n      buf = buf.toString()\n    }\n\n    this._appendBuffer(Buffer.from(buf))\n  }\n\n  return this\n}\n\nBufferList.prototype._appendBuffer = function appendBuffer (buf) {\n  this._bufs.push(buf)\n  this.length += buf.length\n}\n\nBufferList.prototype.indexOf = function (search, offset, encoding) {\n  if (encoding === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n  }\n\n  if (typeof search === 'function' || Array.isArray(search)) {\n    throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.')\n  } else if (typeof search === 'number') {\n    search = Buffer.from([search])\n  } else if (typeof search === 'string') {\n    search = Buffer.from(search, encoding)\n  } else if (this._isBufferList(search)) {\n    search = search.slice()\n  } else if (Array.isArray(search.buffer)) {\n    search = Buffer.from(search.buffer, search.byteOffset, search.byteLength)\n  } else if (!Buffer.isBuffer(search)) {\n    search = Buffer.from(search)\n  }\n\n  offset = Number(offset || 0)\n\n  if (isNaN(offset)) {\n    offset = 0\n  }\n\n  if (offset < 0) {\n    offset = this.length + offset\n  }\n\n  if (offset < 0) {\n    offset = 0\n  }\n\n  if (search.length === 0) {\n    return offset > this.length ? this.length : offset\n  }\n\n  const blOffset = this._offset(offset)\n  let blIndex = blOffset[0] // index of which internal buffer we're working on\n  let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n\n  // scan over each buffer\n  for (; blIndex < this._bufs.length; blIndex++) {\n    const buff = this._bufs[blIndex]\n\n    while (buffOffset < buff.length) {\n      const availableWindow = buff.length - buffOffset\n\n      if (availableWindow >= search.length) {\n        const nativeSearchResult = buff.indexOf(search, buffOffset)\n\n        if (nativeSearchResult !== -1) {\n          return this._reverseOffset([blIndex, nativeSearchResult])\n        }\n\n        buffOffset = buff.length - search.length + 1 // end of native search window\n      } else {\n        const revOffset = this._reverseOffset([blIndex, buffOffset])\n\n        if (this._match(revOffset, search)) {\n          return revOffset\n        }\n\n        buffOffset++\n      }\n    }\n\n    buffOffset = 0\n  }\n\n  return -1\n}\n\nBufferList.prototype._match = function (offset, search) {\n  if (this.length - offset < search.length) {\n    return false\n  }\n\n  for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {\n    if (this.get(offset + searchOffset) !== search[searchOffset]) {\n      return false\n    }\n  }\n  return true\n}\n\n;(function () {\n  const methods = {\n    readDoubleBE: 8,\n    readDoubleLE: 8,\n    readFloatBE: 4,\n    readFloatLE: 4,\n    readInt32BE: 4,\n    readInt32LE: 4,\n    readUInt32BE: 4,\n    readUInt32LE: 4,\n    readInt16BE: 2,\n    readInt16LE: 2,\n    readUInt16BE: 2,\n    readUInt16LE: 2,\n    readInt8: 1,\n    readUInt8: 1,\n    readIntBE: null,\n    readIntLE: null,\n    readUIntBE: null,\n    readUIntLE: null\n  }\n\n  for (const m in methods) {\n    (function (m) {\n      if (methods[m] === null) {\n        BufferList.prototype[m] = function (offset, byteLength) {\n          return this.slice(offset, offset + byteLength)[m](0, byteLength)\n        }\n      } else {\n        BufferList.prototype[m] = function (offset = 0) {\n          return this.slice(offset, offset + methods[m])[m](0)\n        }\n      }\n    }(m))\n  }\n}())\n\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferList || BufferList.isBufferList(b)\n}\n\nBufferList.isBufferList = function isBufferList (b) {\n  return b != null && b[symbol]\n}\n\nmodule.exports = BufferList\n","'use strict'\n\nconst DuplexStream = require('readable-stream').Duplex\nconst inherits = require('inherits')\nconst BufferList = require('./BufferList')\n\nfunction BufferListStream (callback) {\n  if (!(this instanceof BufferListStream)) {\n    return new BufferListStream(callback)\n  }\n\n  if (typeof callback === 'function') {\n    this._callback = callback\n\n    const piper = function piper (err) {\n      if (this._callback) {\n        this._callback(err)\n        this._callback = null\n      }\n    }.bind(this)\n\n    this.on('pipe', function onPipe (src) {\n      src.on('error', piper)\n    })\n    this.on('unpipe', function onUnpipe (src) {\n      src.removeListener('error', piper)\n    })\n\n    callback = null\n  }\n\n  BufferList._init.call(this, callback)\n  DuplexStream.call(this)\n}\n\ninherits(BufferListStream, DuplexStream)\nObject.assign(BufferListStream.prototype, BufferList.prototype)\n\nBufferListStream.prototype._new = function _new (callback) {\n  return new BufferListStream(callback)\n}\n\nBufferListStream.prototype._write = function _write (buf, encoding, callback) {\n  this._appendBuffer(buf)\n\n  if (typeof callback === 'function') {\n    callback()\n  }\n}\n\nBufferListStream.prototype._read = function _read (size) {\n  if (!this.length) {\n    return this.push(null)\n  }\n\n  size = Math.min(size, this.length)\n  this.push(this.slice(0, size))\n  this.consume(size)\n}\n\nBufferListStream.prototype.end = function end (chunk) {\n  DuplexStream.prototype.end.call(this, chunk)\n\n  if (this._callback) {\n    this._callback(null, this.slice())\n    this._callback = null\n  }\n}\n\nBufferListStream.prototype._destroy = function _destroy (err, cb) {\n  this._bufs.length = 0\n  this.length = 0\n  cb(err)\n}\n\nBufferListStream.prototype._isBufferList = function _isBufferList (b) {\n  return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b)\n}\n\nBufferListStream.isBufferList = BufferList.isBufferList\n\nmodule.exports = BufferListStream\nmodule.exports.BufferListStream = BufferListStream\nmodule.exports.BufferList = BufferList\n","'use strict'\nconst fs = require('fs')\nconst path = require('path')\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n","/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = require('./browser.js');\n} else {\n  module.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = require('fs');\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = require('net');\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n","//Based on follow-redirects v0.0.x\n\nvar nativeHttps = require('https'),\n  nativeHttp = require('http'),\n  url = require('url'),\n  utils = require('./utils');\n\nvar maxRedirects = module.exports.maxRedirects = 5;\n\nvar protocols = {\n  https: nativeHttps,\n  http: nativeHttp\n};\n\nfor (var protocol in protocols) {\n  var h = function() {};\n  h.prototype = protocols[protocol];\n  h = new h();\n\n  h.request = function(h) {\n    return function(options, callback, redirectOptions) {\n\n      redirectOptions = redirectOptions || {};\n\n      var max = (typeof options === 'object' && 'maxRedirects' in options) ? options.maxRedirects : exports.maxRedirects;\n\n      var redirect = utils.extend({\n        count: 0,\n        max: max,\n        clientRequest: null,\n        userCallback: callback\n      }, redirectOptions);\n\n      if (redirect.count > redirect.max) {\n        var err = new Error('Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.');\n        redirect.clientRequest.emit('error', err);\n        return redirect.clientRequest;\n      }\n\n      redirect.count++;\n\n      var reqUrl;\n      if (typeof options === 'string') {\n        reqUrl = options;\n      } else {\n        reqUrl = url.format(utils.extend({\n          protocol: protocol\n        }, options));\n      }\n\n      var clientRequest = Object.getPrototypeOf(h).request(options, redirectCallback(reqUrl, redirect));\n\n      if (!redirect.clientRequest) redirect.clientRequest = clientRequest;\n\n      function redirectCallback(reqUrl, redirect) {\n        return function(res) {\n          if (res.statusCode < 300 || res.statusCode > 399) {\n            return redirect.userCallback(res);\n          }\n\n          if (!('location' in res.headers)) {\n            return redirect.userCallback(res);\n          }\n\n          var redirectUrl = url.resolve(reqUrl, res.headers.location);\n\n          var proto = url.parse(redirectUrl).protocol;\n          proto = proto.substr(0, proto.length - 1);\n          return module.exports[proto].get(redirectUrl, redirectCallback(reqUrl, redirect), redirect);\n        };\n      }\n\n      return clientRequest;\n    };\n  }(h);\n\n  // see https://github.com/joyent/node/blob/master/lib/http.js#L1623\n  h.get = function(h) {\n    return function(options, cb, redirectOptions) {\n      var req = h.request(options, cb, redirectOptions);\n      req.end();\n      return req;\n    };\n  }(h);\n\n  module.exports[protocol] = h;\n}\n","module.exports = HttpDuplex;\n\nvar util = require('util'),\n  stream = require('readable-stream');\n\nutil.inherits(HttpDuplex, stream.Duplex);\n\nfunction HttpDuplex(req, res, options) {\n  var self = this;\n\n  if (!(self instanceof HttpDuplex)) return new HttpDuplex(req, res, options);\n\n  stream.Duplex.call(self, options);\n  self._output = null;\n\n  self.connect(req, res);\n}\n\nHttpDuplex.prototype.connect = function(req, res) {\n  var self = this;\n  self.req = req;\n  self._output = res;\n  self.emit('response', res);\n\n  res.on('data', function(c) {\n    if (!self.push(c)) self._output.pause();\n  });\n  res.on('end', function() {\n    self.push(null);\n  });\n};\n\nHttpDuplex.prototype._read = function(n) {\n  if (this._output) this._output.resume();\n};\n\nHttpDuplex.prototype._write = function(chunk, encoding, cb) {\n  this.req.write(chunk, encoding);\n  cb();\n};\n\nHttpDuplex.prototype.end = function(chunk, encoding, cb) {\n  this._output.socket.destroy();\n  return this.req.end(chunk, encoding, cb);\n};\n\nHttpDuplex.prototype.destroy = function() {\n  this.req.destroy();\n  this._output.socket.destroy();\n};\n","var querystring = require('querystring'),\n  http = require('./http'),\n  fs = require('fs'),\n  path = require('path'),\n  url = require('url'),\n  ssh = require('./ssh'),\n  HttpDuplex = require('./http_duplex'),\n  debug = require('debug')('modem'),\n  utils = require('./utils'),\n  util = require('util'),\n  url = require('url'),\n  splitca = require('split-ca'),\n  isWin = require('os').type() === 'Windows_NT';\n\nvar defaultOpts = function () {\n  var host;\n  var opts = {};\n\n  if (!process.env.DOCKER_HOST) {\n    // Windows socket path: //./pipe/docker_engine ( Windows 10 )\n    // Linux & Darwin socket path: /var/run/docker.sock\n    opts.socketPath = isWin ? '//./pipe/docker_engine' : '/var/run/docker.sock';\n  } else if (process.env.DOCKER_HOST.indexOf('unix://') === 0) {\n    // Strip off unix://, fall back to default of /var/run/docker.sock if\n    // unix:// was passed without a path\n    opts.socketPath = process.env.DOCKER_HOST.substring(7) || '/var/run/docker.sock';\n  } else if (process.env.DOCKER_HOST.indexOf('npipe://') === 0) {\n    // Strip off npipe://, fall back to default of //./pipe/docker_engine if\n    // npipe:// was passed without a path\n    opts.socketPath = process.env.DOCKER_HOST.substring(8) || '//./pipe/docker_engine';\n  } else {\n    var hostStr = process.env.DOCKER_HOST;\n    if (hostStr.indexOf('\\/\\/') < 0) {\n      hostStr = 'tcp://' + hostStr;\n    }\n    try {\n      host = new url.URL(hostStr);\n    } catch (err) {\n      throw new Error('DOCKER_HOST env variable should be something like tcp://localhost:1234');\n    }\n\n    opts.port = host.port;\n\n    if (process.env.DOCKER_TLS_VERIFY === '1' || opts.port === '2376') {\n      opts.protocol = 'https';\n    } else if (host.protocol === 'ssh:') {\n      opts.protocol = 'ssh';\n      opts.username = host.username;\n      opts.sshOptions = {\n        agent: process.env.SSH_AUTH_SOCK,\n      }\n    } else {\n      opts.protocol = 'http';\n    }\n\n    opts.host = host.hostname;\n\n    if (process.env.DOCKER_CERT_PATH) {\n      opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, 'ca.pem'));\n      opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'cert.pem'));\n      opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, 'key.pem'));\n    }\n\n    if (process.env.DOCKER_CLIENT_TIMEOUT) {\n      opts.timeout = parseInt(process.env.DOCKER_CLIENT_TIMEOUT, 10);\n    }\n  }\n\n  return opts;\n};\n\n\nvar Modem = function (options) {\n  var optDefaults = defaultOpts();\n  var opts = Object.assign({}, optDefaults, options);\n\n  this.host = opts.host;\n\n  if(!this.host) {\n    this.socketPath = opts.socketPath;\n  }\n\n  this.port = opts.port;\n  this.username = opts.username;\n  this.password = opts.password;\n  this.version = opts.version;\n  this.key = opts.key;\n  this.cert = opts.cert;\n  this.ca = opts.ca;\n  this.timeout = opts.timeout;\n  this.connectionTimeout = opts.connectionTimeout;\n  this.checkServerIdentity = opts.checkServerIdentity;\n  this.agent = opts.agent;\n  this.headers = opts.headers || {};\n  this.sshOptions = Object.assign({}, options ? options.sshOptions : {}, optDefaults.sshOptions);\n  //retrocompabitlity\n  if(this.sshOptions.agentForward === undefined) {\n    this.sshOptions.agentForward = opts.agentForward;\n  }\n\n  if (this.key && this.cert && this.ca) {\n    this.protocol = 'https';\n  }\n  this.protocol = opts.protocol || this.protocol || 'http';\n};\n\nModem.prototype.dial = function (options, callback) {\n  var opts, address, data;\n  var self = this;\n\n  if (options.options) {\n    opts = options.options;\n  }\n\n  // Prevent credentials from showing up in URL\n  if (opts && opts.authconfig) {\n    delete opts.authconfig;\n  }\n\n  if (this.version) {\n    options.path = '/' + this.version + options.path;\n  }\n\n  if (this.host) {\n    var parsed = url.parse(self.host);\n    address = url.format({\n      'protocol': parsed.protocol || self.protocol,\n      'hostname': parsed.hostname || self.host,\n      'port': self.port\n    });\n    address = url.resolve(address, options.path);\n  } else {\n    address = options.path;\n  }\n\n  if (options.path.indexOf('?') !== -1) {\n    if (opts && Object.keys(opts).length > 0) {\n      address += this.buildQuerystring(opts._query || opts);\n    } else {\n      address = address.substring(0, address.length - 1);\n    }\n  }\n\n  var optionsf = {\n    path: address,\n    method: options.method,\n    headers: options.headers || Object.assign({}, self.headers),\n    key: self.key,\n    cert: self.cert,\n    ca: self.ca\n  };\n\n  if (this.checkServerIdentity) {\n    optionsf.checkServerIdentity = this.checkServerIdentity;\n  }\n\n  if (this.agent) {\n    optionsf.agent = this.agent;\n  }\n\n  if (options.authconfig) {\n    optionsf.headers['X-Registry-Auth'] = options.authconfig.key || options.authconfig.base64 ||\n      Buffer.from(JSON.stringify(options.authconfig)).toString('base64');\n  }\n\n  if (options.registryconfig) {\n    optionsf.headers['X-Registry-Config'] = options.registryconfig.base64 ||\n      Buffer.from(JSON.stringify(options.registryconfig)).toString('base64');\n  }\n\n  if (options.file) {\n    if (typeof options.file === 'string') {\n      data = fs.createReadStream(path.resolve(options.file));\n    } else {\n      data = options.file;\n    }\n    optionsf.headers['Content-Type'] = 'application/tar';\n  } else if (opts && options.method === 'POST') {\n    data = JSON.stringify(opts._body || opts);\n    if (options.allowEmpty) {\n      optionsf.headers['Content-Type'] = 'application/json';\n    } else {\n      if (data !== '{}' && data !== '\"\"') {\n        optionsf.headers['Content-Type'] = 'application/json';\n      } else {\n        data = undefined;\n      }\n    }\n  }\n\n  if (typeof data === 'string') {\n    optionsf.headers['Content-Length'] = Buffer.byteLength(data);\n  } else if (Buffer.isBuffer(data) === true) {\n    optionsf.headers['Content-Length'] = data.length;\n  } else if (optionsf.method === 'PUT' || options.hijack || options.openStdin) {\n    optionsf.headers['Transfer-Encoding'] = 'chunked';\n  }\n\n  if (options.hijack) {\n    optionsf.headers.Connection = 'Upgrade';\n    optionsf.headers.Upgrade = 'tcp';\n  }\n\n  if (this.socketPath) {\n    optionsf.socketPath = this.socketPath;\n  } else {\n    var urlp = url.parse(address);\n    optionsf.hostname = urlp.hostname;\n    optionsf.port = urlp.port;\n    optionsf.path = urlp.path;\n  }\n\n  this.buildRequest(optionsf, options, data, callback);\n};\n\nModem.prototype.buildRequest = function (options, context, data, callback) {\n  var self = this;\n  var connectionTimeoutTimer;\n\n  var opts = self.protocol === 'ssh' ? Object.assign(options, {\n    agent: ssh(Object.assign({}, self.sshOptions, {\n      'host': self.host,\n      'port': self.port,\n      'username': self.username,\n      'password': self.password,\n    })),\n    protocol: 'http:',\n  }) : options;\n\n  var req = http[self.protocol === 'ssh' ? 'http' : self.protocol].request(opts, function () { });\n\n  debug('Sending: %s', util.inspect(options, {\n    showHidden: true,\n    depth: null\n  }));\n\n  if (self.connectionTimeout) {\n    connectionTimeoutTimer = setTimeout(function () {\n      debug('Connection Timeout of %s ms exceeded', self.connectionTimeout);\n      req.abort();\n    }, self.connectionTimeout);\n  }\n\n  if (self.timeout) {\n    req.on('socket', function (socket) {\n      socket.setTimeout(self.timeout);\n      socket.on('timeout', function () {\n        debug('Timeout of %s ms exceeded', self.timeout);\n        req.abort();\n      });\n    });\n  }\n\n  if (context.hijack === true) {\n    clearTimeout(connectionTimeoutTimer);\n    req.on('upgrade', function (res, sock, head) {\n      return callback(null, sock);\n    });\n  }\n\n  req.on('connect', function () {\n    clearTimeout(connectionTimeoutTimer);\n  });\n\n  req.on('disconnect', function () {\n    clearTimeout(connectionTimeoutTimer);\n  });\n\n  req.on('response', function (res) {\n    clearTimeout(connectionTimeoutTimer);\n    if (context.isStream === true) {\n      self.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);\n    } else {\n      var chunks = [];\n      res.on('data', function (chunk) {\n        chunks.push(chunk);\n      });\n\n      res.on('end', function () {\n        var buffer = Buffer.concat(chunks);\n        var result = buffer.toString();\n\n        debug('Received: %s', result);\n\n        var json = utils.parseJSON(result) || buffer;\n        self.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);\n      });\n    }\n  });\n\n  req.on('error', function (error) {\n    clearTimeout(connectionTimeoutTimer);\n    self.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);\n  });\n\n  if (typeof data === 'string' || Buffer.isBuffer(data)) {\n    req.write(data);\n  } else if (data) {\n    data.on('error', function (error) {\n      req.destroy(error);\n    });\n    data.pipe(req);\n  }\n\n  if (!context.hijack && !context.openStdin && (typeof data === 'string' || data === undefined || Buffer.isBuffer(data))) {\n    req.end();\n  }\n};\n\nModem.prototype.buildPayload = function (err, isStream, statusCodes, openStdin, req, res, json, cb) {\n  if (err) return cb(err, null);\n\n  if (statusCodes[res.statusCode] !== true) {\n    getCause(isStream, res, json, function (err, cause) {\n      var msg = new Error(\n        '(HTTP code ' + res.statusCode + ') ' +\n        (statusCodes[res.statusCode] || 'unexpected') + ' - ' +\n        (cause.message || cause) + ' '\n      );\n      msg.reason = statusCodes[res.statusCode];\n      msg.statusCode = res.statusCode;\n      msg.json = json;\n      cb(msg, null);\n    });\n  } else {\n    if (openStdin) {\n      cb(null, new HttpDuplex(req, res));\n    } else if (isStream) {\n      cb(null, res);\n    } else {\n      cb(null, json);\n    }\n  }\n\n  function getCause(isStream, res, json, callback) {\n    var chunks = '';\n    if (isStream) {\n      res.on('data', function (chunk) {\n        chunks += chunk;\n      });\n      res.on('end', function () {\n        callback(null, utils.parseJSON(chunks) || chunks);\n      });\n    } else {\n      callback(null, json);\n    }\n  }\n};\n\nModem.prototype.demuxStream = function (stream, stdout, stderr) {\n  var nextDataType = null;\n  var nextDataLength = null;\n  var buffer = Buffer.from('');\n  function processData(data) {\n    if (data) {\n      buffer = Buffer.concat([buffer, data]);\n    }\n    if (!nextDataType) {\n      if (buffer.length >= 8) {\n        var header = bufferSlice(8);\n        nextDataType = header.readUInt8(0);\n        nextDataLength = header.readUInt32BE(4);\n        // It's possible we got a \"data\" that contains multiple messages\n        // Process the next one\n        processData();\n      }\n    } else {\n      if (buffer.length >= nextDataLength) {\n        var content = bufferSlice(nextDataLength);\n        if (nextDataType === 1) {\n          stdout.write(content);\n        } else {\n          stderr.write(content);\n        }\n        nextDataType = null;\n        // It's possible we got a \"data\" that contains multiple messages\n        // Process the next one\n        processData();\n      }\n    }\n  }\n\n  function bufferSlice(end) {\n    var out = buffer.slice(0, end);\n    buffer = Buffer.from(buffer.slice(end, buffer.length));\n    return out;\n  }\n\n  stream.on('data', processData);\n};\n\nModem.prototype.followProgress = function (stream, onFinished, onProgress) {\n  var buf = '';\n  var output = [];\n  var finished = false;\n\n  stream.on('data', onStreamEvent);\n  stream.on('error', onStreamError);\n  stream.on('end', onStreamEnd);\n  stream.on('close', onStreamEnd);\n\n  function onStreamEvent(data) {\n    buf += data.toString();\n    pump();\n\n    function pump() {\n      var pos;\n      while ((pos = buf.indexOf('\\n')) >= 0) {\n        if (pos == 0) {\n          buf = buf.slice(1);\n          continue;\n        }\n        processLine(buf.slice(0, pos));\n        buf = buf.slice(pos + 1);\n      }\n    }\n\n    function processLine(line) {\n      if (line[line.length - 1] == '\\r') line = line.substr(0, line.length - 1);\n      if (line.length > 0) {\n        var obj = JSON.parse(line);\n        output.push(obj);\n        if (onProgress) {\n          onProgress(obj);\n        }\n      }\n    }\n  };\n\n  function onStreamError(err) {\n    finished = true;\n    stream.removeListener('data', onStreamEvent);\n    stream.removeListener('error', onStreamError);\n    stream.removeListener('end', onStreamEnd);\n    stream.removeListener('close', onStreamEnd);\n    onFinished(err, output);\n  }\n\n  function onStreamEnd() {\n    if(!finished) onFinished(null, output);\n    finished = true;\n  }\n};\n\nModem.prototype.buildQuerystring = function (opts) {\n  var clone = {};\n\n  // serialize map values as JSON strings, else querystring truncates.\n  Object.keys(opts).map(function (key, i) {\n    clone[key] = opts[key] && typeof opts[key] === 'object' && key !== 't' ?\n      JSON.stringify(opts[key]) : opts[key];\n  });\n\n  return querystring.stringify(clone);\n};\n\nmodule.exports = Modem;\n","var Client = require('ssh2').Client,\n  http = require('http');\n\nmodule.exports = function(opt) {\n  var conn = new Client();\n  var agent = new http.Agent();\n\n  agent.createConnection = function(options, fn) {\n    conn.once('ready', function() {\n      conn.exec('docker system dial-stdio', function(err, stream) {\n        if (err) {\n          conn.end();\n          agent.destroy();\n          return;\n        }\n\n        fn(null, stream);\n\n        stream.once('close', () => {\n          conn.end();\n          agent.destroy();\n        });\n      });\n    }).connect(opt);\n\n    conn.once('end', () => agent.destroy());\n  };\n\n  return agent;\n};\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.parseJSON = function(s) {\n  try {\n    return JSON.parse(s);\n  } catch (e) {\n    return null;\n  }\n};\n","var util = require('./util');\n\n/**\n * Represents a config\n * @param {Object} modem docker-modem\n * @param {String} id  Config's id\n */\nvar Config = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nConfig.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nConfig.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/configs/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update a config.\n *\n * @param {object} opts\n * @param {function} callback\n */\nConfig.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/configs/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Removes the config\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nConfig.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/configs/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'config not found',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Config;\n","var extend = require('./util').extend,\n  Exec = require('./exec'),\n  util = require('./util');\n\n/**\n * Represents a Container\n * @param {Object} modem docker-modem\n * @param {String} id    Container's ID\n */\nvar Container = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n\n  this.defaultOptions = {\n    top: {},\n    start: {},\n    commit: {},\n    stop: {},\n    pause: {},\n    unpause: {},\n    restart: {},\n    resize: {},\n    attach: {},\n    remove: {},\n    copy: {},\n    kill: {},\n    exec: {},\n    rename: {},\n    log: {},\n    stats: {},\n    getArchive: {},\n    infoArchive: {},\n    putArchive: {},\n    update: {},\n    wait: {}\n  };\n};\n\nContainer.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Object}   opts     Options (optional)\n * @param  {Function} callback Callback, if supplied will query Docker.\n * @return {Object}            ID only and only if callback isn't supplied.\n */\nContainer.prototype.inspect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Rename\n * @param  {Object}   opts     Rename options\n * @param  {Function} callback Callback\n */\nContainer.prototype.rename = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.rename);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/rename?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Update\n * @param  {Object}   opts     Update options\n * @param  {Function} callback Callback\n */\nContainer.prototype.update = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.update);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/update',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Top\n * @param  {Object}   opts like 'ps_args' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.top = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.top);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/top?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Containers changes\n * @param  {Function} callback Callback\n */\nContainer.prototype.changes = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/' + this.id + '/changes',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Checkpoints list\n * @param  {Object}   opts     List checkpoints options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.listCheckpoint = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Delete checkpoint\n * @param  {Object}   opts     Delete checkpoint options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.deleteCheckpoint = function(checkpoint, opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints/' + checkpoint + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Create checkpoint\n * @param  {Object}   opts     Create checkpoint options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.createCheckpoint = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/checkpoints',\n    method: 'POST',\n    allowEmpty: true,\n    statusCodes: {\n      200: true, //unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Export\n * @param  {Function} callback Callback with the octet-stream.\n */\nContainer.prototype.export = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/' + this.id + '/export',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Start\n * @param  {Object}   opts     Container start options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.start = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.start);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/start?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      304: 'container already started',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Pause\n * @param  {Object}   opts     Pause options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.pause = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.pause);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/pause',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Unpause\n * @param  {Object}   opts     Unpause options (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.unpause = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.unpause);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/unpause',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Setup an exec call to a running container\n *\n * @param {object} opts\n * @param {function} callback\n */\nContainer.prototype.exec = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.exec);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/exec',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      409: 'container stopped/paused',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(new Exec(self.modem, data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, new Exec(self.modem, data.Id));\n    });\n  }\n};\n\n/**\n * Commit\n * @param  {Object}   opts     Commit options like 'Hostname' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.commit = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.commit);\n\n  args.opts.container = this.id;\n\n  var optsf = {\n    path: '/commit?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Stop\n * @param  {Object}   opts     Container stop options, like 't' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.stop = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.stop);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/stop?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      304: 'container already stopped',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Restart\n * @param  {Object}   opts     Container restart options, like 't' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.restart = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.restart);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/restart?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Kill\n * @param  {Object}   opts     Container kill options, like 'signal' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.kill = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.kill);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/kill?',\n    method: 'POST',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container resize\n * @param  {[type]}   opts     Resize options. (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.resize = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.resize);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/resize?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Attach\n * @param  {Object}   opts     Attach options, like 'logs' (optional)\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.attach = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.attach);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/attach?',\n    method: 'POST',\n    isStream: true,\n    hijack: args.opts.hijack,\n    openStdin: args.opts.stdin,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, stream) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(stream);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, stream) {\n      args.callback(err, stream);\n    });\n  }\n};\n\n/**\n * Waits for a container to end.\n * @param  {[type]}   opts     Container wait options, like condition. (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.wait = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.wait);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/wait?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes a container\n * @param  {Object}   opts     Remove options, like 'force' (optional)\n * @param  {Function} callback Callback\n */\nContainer.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.remove);\n\n  var optsf = {\n    path: '/containers/' + this.id + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      400: 'bad parameter',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Copy (WARNING: DEPRECATED since RAPI v1.20)\n * @param  {Object}   opts     Copy options, like 'Resource' (optional)\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.copy = function(opts, callback) {\n  var self = this;\n  console.log('container.copy is deprecated since Docker v1.8.x');\n  var args = util.processArgs(opts, callback, this.defaultOptions.copy);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/copy',\n    method: 'POST',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * getArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.getArchive = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.getArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * infoArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.infoArchive = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.infoArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'HEAD',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * putArchive\n * @param  {Object}   opts     Archive options, like 'path'\n * @param  {Function} callback Callback with stream.\n */\nContainer.prototype.putArchive = function(file, opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.putArchive);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/archive?',\n    method: 'PUT',\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'client error, bad parameters',\n      403: 'client error, permission denied',\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nContainer.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\n\n  var optsf = {\n    path: '/containers/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Container stats\n * @param  {Object}   opts     Stats options. (optional)\n * @param  {Function} callback Callback with data\n */\nContainer.prototype.stats = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.stats);\n  var isStream = true;\n  if (args.opts.stream === false) {\n    isStream = false;\n  }\n  var optsf = {\n    path: '/containers/' + this.id + '/stats?',\n    method: 'GET',\n    isStream: isStream,\n    statusCodes: {\n      200: true,\n      404: 'no such container',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Container;\n","var EventEmitter = require('events').EventEmitter,\n  Modem = require('docker-modem'),\n  tar = require('tar-fs'),\n  zlib = require('zlib'),\n  Container = require('./container'),\n  Image = require('./image'),\n  Volume = require('./volume'),\n  Network = require('./network'),\n  Service = require('./service'),\n  Plugin = require('./plugin'),\n  Secret = require('./secret'),\n  Config = require('./config'),\n  Task = require('./task'),\n  Node = require('./node'),\n  Exec = require('./exec'),\n  util = require('./util'),\n  extend = util.extend;\n\nvar Docker = function(opts) {\n  if (!(this instanceof Docker)) return new Docker(opts);\n\n  var plibrary = global.Promise;\n\n  if (opts && opts.Promise) {\n    plibrary = opts.Promise;\n\n    if (Object.keys(opts).length === 1) {\n      opts = undefined;\n    }\n  }\n\n  this.modem = new Modem(opts);\n  this.modem.Promise = plibrary;\n};\n\n/**\n * Creates a new container\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createContainer = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/containers/create?',\n    method: 'POST',\n    options: opts,\n    authconfig: opts.authconfig,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'no such container',\n      406: 'impossible to attach',\n      500: 'server error'\n    }\n  };\n\n  delete opts.authconfig;\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getContainer(data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, self.getContainer(data.Id));\n    });\n  }\n};\n\n/**\n * Creates a new image\n * @param {Object}   auth     Authentication (optional)\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createImage = function(auth, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  } else if (!callback && !opts) {\n    opts = auth;\n    auth = opts.authconfig;\n  }\n\n  var optsf = {\n    path: '/images/create?',\n    method: 'POST',\n    options: opts,\n    authconfig: auth,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Load image\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.loadImage = function(file, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  var optsf = {\n    path: '/images/load?',\n    method: 'POST',\n    options: opts,\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Import image from a tar archive\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.importImage = function(file, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = undefined;\n  }\n  \n  if (!opts)\n    opts = {};\n\n  opts.fromSrc = '-';\n\n  var optsf = {\n    path: '/images/create?',\n    method: 'POST',\n    options: opts,\n    file: file,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Verifies auth\n * @param {Object}   opts     Options\n * @param {Function} callback Callback\n */\nDocker.prototype.checkAuth = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/auth',\n    method: 'POST',\n    options: opts,\n    statusCodes: {\n      200: true,\n      204: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Builds an image\n * @param {String}   file     File\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.buildImage = function(file, opts, callback) {\n  var self = this;\n  var content;\n\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n\n  function build(file) {\n    var optsf = {\n      path: '/build?',\n      method: 'POST',\n      file: file,\n      options: opts,\n      isStream: true,\n      statusCodes: {\n        200: true,\n        500: 'server error'\n      }\n    };\n\n    if (opts) {\n      if (opts.registryconfig) {\n        optsf.registryconfig = optsf.options.registryconfig;\n        delete optsf.options.registryconfig;\n      }\n\n      //undocumented?\n      if (opts.authconfig) {\n        optsf.authconfig = optsf.options.authconfig;\n        delete optsf.options.authconfig;\n      }\n    }\n\n    if (callback === undefined) {\n      return new self.modem.Promise(function(resolve, reject) {\n        self.modem.dial(optsf, function(err, data) {\n          if (err) {\n            return reject(err);\n          }\n          resolve(data);\n        });\n      });\n    } else {\n      self.modem.dial(optsf, function(err, data) {\n        callback(err, data);\n      });\n    }\n  }\n\n  if (file && file.context) {\n    var pack = tar.pack(file.context, {\n      entries: file.src\n    });\n    return build(pack.pipe(zlib.createGzip()));\n  } else {\n    return build(file);\n  }\n};\n\n/**\n * Fetches a Container by ID\n * @param {String} id Container's ID\n */\nDocker.prototype.getContainer = function(id) {\n  return new Container(this.modem, id);\n};\n\n/**\n * Fetches an Image by name\n * @param {String} name Image's name\n */\nDocker.prototype.getImage = function(name) {\n  return new Image(this.modem, name);\n};\n\n/**\n * Fetches a Volume by name\n * @param {String} name Volume's name\n */\nDocker.prototype.getVolume = function(name) {\n  return new Volume(this.modem, name);\n};\n\n/**\n * Fetches a Plugin by name\n * @param {String} name Volume's name\n */\nDocker.prototype.getPlugin = function(name, remote) {\n  return new Plugin(this.modem, name, remote);\n};\n\n/**\n * Fetches a Service by id\n * @param {String} id Services's id\n */\nDocker.prototype.getService = function(id) {\n  return new Service(this.modem, id);\n};\n\n/**\n * Fetches a Task by id\n * @param {String} id Task's id\n */\nDocker.prototype.getTask = function(id) {\n  return new Task(this.modem, id);\n};\n\n/**\n * Fetches Node by id\n * @param {String} id Node's id\n */\nDocker.prototype.getNode = function(id) {\n  return new Node(this.modem, id);\n};\n\n/**\n * Fetches a Network by id\n * @param {String} id network's id\n */\nDocker.prototype.getNetwork = function(id) {\n  return new Network(this.modem, id);\n};\n\n/**\n * Fetches a Secret by id\n * @param {String} id network's id\n */\nDocker.prototype.getSecret = function(id) {\n  return new Secret(this.modem, id);\n};\n\n/**\n * Fetches a Config by id\n * @param {String} id network's id\n */\nDocker.prototype.getConfig = function(id) {\n  return new Config(this.modem, id);\n};\n\n/**\n * Fetches an Exec instance by ID\n * @param {String} id Exec instance's ID\n */\nDocker.prototype.getExec = function(id) {\n  return new Exec(this.modem, id);\n};\n\n/**\n * Lists containers\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listContainers = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/json?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Get images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.getImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/get?',\n    method: 'GET',\n    options: args.opts,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Services\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listServices = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/services?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Nodes\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listNodes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/nodes?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      404: 'no such node',\n      500: 'server error',\n      503: 'node is not part of a swarm',\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists Tasks\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listTasks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/tasks?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new secret\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createSecret = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n  var optsf = {\n    path: '/secrets/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      406: 'server error or node is not part of a swarm',\n      409: 'name conflicts with an existing object',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getSecret(data.ID));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getSecret(data.ID));\n    });\n  }\n};\n\n\n/**\n * Creates a new config\n * @param {Object}   opts     Config options\n * @param {Function} callback Callback\n */\nDocker.prototype.createConfig = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n  var optsf = {\n    path: '/configs/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      406: 'server error or node is not part of a swarm',\n      409: 'name conflicts with an existing object',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getConfig(data.ID));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getConfig(data.ID));\n    });\n  }\n};\n\n\n/**\n * Lists secrets\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listSecrets = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/secrets?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Lists configs\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listConfigs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/configs?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new plugin\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createPlugin = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/plugins/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getPlugin(args.opts.name));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getPlugin(args.opts.name));\n    });\n  }\n};\n\n\n/**\n * Lists plugins\n * @param {Object} opts\n * @param {Function} callback Callback\n */\nDocker.prototype.listPlugins = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune images\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneImages = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/images/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune builder\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneBuilder = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/build/prune',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune containers\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneContainers = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/containers/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune volumes\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneVolumes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Prune networks\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.pruneNetworks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/prune?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Creates a new volume\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createVolume = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/volumes/create?',\n    method: 'POST',\n    allowEmpty: true,\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getVolume(data.Name));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getVolume(data.Name));\n    });\n  }\n};\n\n/**\n * Creates a new service\n * @param {Object}   auth\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createService = function(auth, opts, callback) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  } else if (!opts && !callback) {\n    opts = auth;\n  }\n\n\n  var self = this;\n  var optsf = {\n    path: '/services/create',\n    method: 'POST',\n    options: opts,\n    authconfig: auth,\n    statusCodes: {\n      200: true,\n      201: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getService(data.ID || data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, self.getService(data.ID || data.Id));\n    });\n  }\n};\n\n/**\n * Lists volumes\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listVolumes = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Creates a new network\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nDocker.prototype.createNetwork = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var optsf = {\n    path: '/networks/create?',\n    method: 'POST',\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      404: 'driver not found',\n      500: 'server error'\n    }\n  };\n\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(self.getNetwork(data.Id));\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, self.getNetwork(data.Id));\n    });\n  }\n};\n\n/**\n * Lists networks\n * @param {Object}   opts     Options (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.listNetworks = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks?',\n    method: 'GET',\n    options: args.opts,\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Search images\n * @param {Object}   opts     Options\n * @param {Function} callback Callback\n */\nDocker.prototype.searchImages = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/images/search?',\n    method: 'GET',\n    options: opts,\n    authconfig: opts.authconfig,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Info\n * @param  {Function} callback Callback with info\n */\nDocker.prototype.info = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/info',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Version\n * @param  {Function} callback Callback\n */\nDocker.prototype.version = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/version',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Ping\n * @param  {Function} callback Callback\n */\nDocker.prototype.ping = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/_ping',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * SystemDf \tequivalent to system/df API Engine\n *\t\tget usage data information\n * @param  {Function} callback Callback\n */\nDocker.prototype.df = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/system/df',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Events\n * @param {Object}   opts     Events options, like 'since' (optional)\n * @param {Function} callback Callback\n */\nDocker.prototype.getEvents = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/events?',\n    method: 'GET',\n    options: args.opts,\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Pull is a wrapper around createImage, parsing image's tags.\n * @param  {String}   repoTag  Repository tag\n * @param  {Object}   opts     Options (optional)\n * @param  {Function} callback Callback\n * @param  {Object}   auth     Authentication (optional)\n * @return {Object}            Image\n */\nDocker.prototype.pull = function(repoTag, opts, callback, auth) {\n  var args = util.processArgs(opts, callback);\n\n  var imageSrc = util.parseRepositoryTag(repoTag);\n  args.opts.fromImage = imageSrc.repository;\n  args.opts.tag = imageSrc.tag || 'latest';\n\n  var argsf = [args.opts, args.callback];\n  if (auth) {\n    argsf = [auth, args.opts, args.callback];\n  }\n  return this.createImage.apply(this, argsf);\n};\n\n/**\n * Like run command from Docker's CLI\n * @param  {String}   image         Image name to be used.\n * @param  {Array}   cmd           Command to run in array format.\n * @param  {Object}   streamo       Output stream\n * @param  {Object}   createOptions Container create options (optional)\n * @param  {Object}   startOptions  Container start options (optional)\n * @param  {Function} callback      Callback\n * @return {Object}                 EventEmitter\n */\nDocker.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {\n  if (typeof arguments[arguments.length - 1] === 'function') {\n    return this.runCallback(image, cmd, streamo, createOptions, startOptions, callback);\n  } else {\n    return this.runPromise(image, cmd, streamo, createOptions, startOptions);\n  }\n};\n\n\nDocker.prototype.runCallback = function(image, cmd, streamo, createOptions, startOptions, callback) {\n  if (!callback && typeof createOptions === 'function') {\n    callback = createOptions;\n    createOptions = {};\n    startOptions = {};\n  } else if (!callback && typeof startOptions === 'function') {\n    callback = startOptions;\n    startOptions = {};\n  }\n\n  var hub = new EventEmitter();\n\n  function handler(err, container) {\n    if (err) return callback(err, null, container);\n\n    hub.emit('container', container);\n\n    container.attach({\n      stream: true,\n      stdout: true,\n      stderr: true\n    }, function handler(err, stream) {\n      if (err) return callback(err, null, container);\n\n      hub.emit('stream', stream);\n\n      if (streamo) {\n        if (streamo instanceof Array) {\n          stream.on('end', function() {\n            try {\n              streamo[0].end();\n            } catch (e) {}\n            try {\n              streamo[1].end();\n            } catch (e) {}\n          });\n          container.modem.demuxStream(stream, streamo[0], streamo[1]);\n        } else {\n          stream.setEncoding('utf8');\n          stream.pipe(streamo, {\n            end: true\n          });\n        }\n      }\n\n      container.start(startOptions, function(err, data) {\n        if (err) return callback(err, data, container);\n        hub.emit('start', container);\n\n        container.wait(function(err, data) {\n          hub.emit('data', data);\n          callback(err, data, container);\n        });\n      });\n    });\n  }\n\n  var optsc = {\n    'Hostname': '',\n    'User': '',\n    'AttachStdin': false,\n    'AttachStdout': true,\n    'AttachStderr': true,\n    'Tty': true,\n    'OpenStdin': false,\n    'StdinOnce': false,\n    'Env': null,\n    'Cmd': cmd,\n    'Image': image,\n    'Volumes': {},\n    'VolumesFrom': []\n  };\n\n  extend(optsc, createOptions);\n\n  this.createContainer(optsc, handler);\n\n  return hub;\n};\n\nDocker.prototype.runPromise = function(image, cmd, streamo, createOptions, startOptions) {\n  var self = this;\n\n  createOptions = createOptions || {};\n  startOptions = startOptions || {};\n\n  var optsc = {\n    'Hostname': '',\n    'User': '',\n    'AttachStdin': false,\n    'AttachStdout': true,\n    'AttachStderr': true,\n    'Tty': true,\n    'OpenStdin': false,\n    'StdinOnce': false,\n    'Env': null,\n    'Cmd': cmd,\n    'Image': image,\n    'Volumes': {},\n    'VolumesFrom': []\n  };\n\n  extend(optsc, createOptions);\n\n  var containero;\n\n  return new this.modem.Promise(function(resolve, reject) {\n    self.createContainer(optsc).then(function(container) {\n      containero = container;\n      return container.attach({\n        stream: true,\n        stdout: true,\n        stderr: true\n      });\n    }).then(function(stream) {\n      if (streamo) {\n        if (streamo instanceof Array) {\n          stream.on('end', function() {\n            try {\n              streamo[0].end();\n            } catch (e) {}\n            try {\n              streamo[1].end();\n            } catch (e) {}\n          });\n          containero.modem.demuxStream(stream, streamo[0], streamo[1]);\n        } else {\n          stream.setEncoding('utf8');\n          stream.pipe(streamo, {\n            end: true\n          });\n        }\n      }\n      return containero.start(startOptions);\n    }).then(function(data) {\n      return containero.wait();\n    }).then(function(data) {\n      resolve([data, containero]);\n    }).catch(function(err) {\n      reject(err);\n    });\n  });\n};\n\n/**\n * Init swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmInit = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/init',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Join swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmJoin = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/join',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Leave swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmLeave = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/leave?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      406: 'node is not part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Update swarm.\n *\n * @param {object} opts\n * @param {function} callback\n */\nDocker.prototype.swarmUpdate = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/swarm/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      400: 'bad parameter',\n      406: 'node is already part of a Swarm'\n    },\n    options: args.opts\n  };\n\n  if (args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Inspect a Swarm.\n * Warning: This method is not documented in the API\n *\n * @param  {Function} callback Callback\n */\nDocker.prototype.swarmInspect = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/swarm',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      406: 'This node is not a swarm manager',\n      500: 'server error'\n    }\n  };\n\n  if (callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\nDocker.Container = Container;\nDocker.Image = Image;\nDocker.Volume = Volume;\nDocker.Network = Network;\nDocker.Service = Service;\nDocker.Plugin = Plugin;\nDocker.Secret = Secret;\nDocker.Task = Task;\nDocker.Node = Node;\nDocker.Exec = Exec;\n\nmodule.exports = Docker;\n","var util = require('./util');\n\n/**\n * Represents an Exec\n * @param {Object} modem docker-modem\n * @param {String} id    Exec's ID\n */\nvar Exec = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nExec.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Start the exec call that was setup.\n *\n * @param {object} opts\n * @param {function} callback\n */\nExec.prototype.start = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/exec/' + this.id + '/start',\n    method: 'POST',\n    isStream: true,\n    allowEmpty: true,\n    hijack: args.opts.hijack,\n    openStdin: args.opts.stdin,\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such exec',\n      409: 'container stopped/paused',\n      500: 'container not running'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Resize the exec call that was setup.\n *\n * @param {object} opts\n * @param {function} callback\n */\nExec.prototype.resize = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/exec/' + this.id + '/resize?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such exec',\n      500: 'container not running'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Get low-level information about the exec call.\n *\n * @param {function} callback\n */\nExec.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/exec/' + this.id + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such exec',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Exec;\n","var util = require('./util');\n\n/**\n * Represents an image\n * @param {Object} modem docker-modem\n * @param {String} name  Image's name\n */\nvar Image = function(modem, name) {\n  this.modem = modem;\n  this.name = name;\n};\n\nImage.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nImage.prototype.inspect = function(callback) {\n  var self = this;\n\n  var opts = {\n    path: '/images/' + this.name + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Distribution\n * @param {Object} opts\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nImage.prototype.distribution = function(opts, callback) {\n  var args = util.processArgs(opts, callback);\n  var self = this;\n\n  var fopts = {\n    path: '/distribution/' + this.name + '/json',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      401: 'no such image',\n      500: 'server error'\n    },\n    authconfig: (args.opts) ? args.opts.authconfig : undefined\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(fopts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(fopts, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * History\n * @param  {Function} callback Callback\n */\nImage.prototype.history = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/images/' + this.name + '/history',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Get\n * @param  {Function} callback Callback with data stream.\n */\nImage.prototype.get = function(callback) {\n  var self = this;\n  var opts = {\n    path: '/images/' + this.name + '/get',\n    method: 'GET',\n    isStream: true,\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      if (err) return callback(err, data);\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Push\n * @param  {Object}   opts     Push options, like 'registry' (optional)\n * @param  {Function} callback Callback with stream.\n * @param  {Object}   auth     Registry authentication\n */\nImage.prototype.push = function(opts, callback, auth) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n  var isStream = true;\n  if (args.opts.stream === false) {\n    isStream = false;\n  }\n  var optsf = {\n    path: '/images/' + this.name + '/push?',\n    method: 'POST',\n    options: args.opts,\n    authconfig: args.opts.authconfig || auth,\n    isStream: isStream,\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      500: 'server error'\n    }\n  };\n\n  delete optsf.options.authconfig;\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Tag\n * @param  {Object}   opts     Tag options, like 'repo' (optional)\n * @param  {Function} callback Callback\n */\nImage.prototype.tag = function(opts, callback) {\n  var self = this;\n  var optsf = {\n    path: '/images/' + this.name + '/tag?',\n    method: 'POST',\n    options: opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      201: true,\n      400: 'bad parameter',\n      404: 'no such image',\n      409: 'conflict',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the image\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nImage.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n\n  var optsf = {\n    path: '/images/' + this.name + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'no such image',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Image;\n","var util = require('./util');\n\n/**\n * Represents an network\n * @param {Object} modem docker-modem\n * @param {String} id  Network's id\n */\nvar Network = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nNetwork.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Id only if callback isn't specified.\n */\nNetwork.prototype.inspect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var opts = {\n    path: '/networks/' + this.id + '?',\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such network',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(opts, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(opts, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the network\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such network',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Connects a container to a network\n * @param  {[Object]}   opts     Connect options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.connect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id + '/connect',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      201: true,\n      404: 'network or container is not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Disconnects a container from a network\n * @param  {[Object]}   opts     Disconnect options (optional)\n * @param  {Function} callback Callback\n */\nNetwork.prototype.disconnect = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/networks/' + this.id + '/disconnect',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      201: true,\n      404: 'network or container is not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\n\nmodule.exports = Network;\n","var util = require('./util');\n\n/**\n * Represents an Node\n * @param {Object} modem docker-modem\n * @param {String} id    Node's ID\n */\nvar Node = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nNode.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for Node details.\n *\n * @param {function} callback\n */\nNode.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/nodes/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Update a node.\n *\n * @param {object} opts\n * @param {function} callback\n */\nNode.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/nodes/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      406: 'node is not part of a swarm',\n      500: 'server error'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Remove a Node.\n * Warning: This method is not documented in the API.\n *\n * @param {object} opts\n * @param {function} callback\n */\nNode.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/nodes/' + this.id + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'no such node',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Node;\n","var util = require('./util');\n\n/**\n * Represents a plugin\n * @param {Object} modem docker-modem\n * @param {String} name  Plugin's name\n */\nvar Plugin = function(modem, name, remote) {\n  this.modem = modem;\n  this.name = name;\n  this.remote = remote || name;\n};\n\nPlugin.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nPlugin.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/plugins/' + this.name,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'plugin is not installed',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the plugin\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '?',\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      404: 'plugin is not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      if (err) return args.callback(err, data);\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * get privileges\n * @param  {Function} callback Callback\n * @return {Object}            Name only if callback isn't specified.\n */\nPlugin.prototype.privileges = function(callback) {\n  var self = this;\n  var optsf = {\n    path: '/plugins/privileges?',\n    method: 'GET',\n    options: {\n      'remote': this.remote\n    },\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Installs a new plugin\n * @param {Object}   opts     Create options\n * @param {Function} callback Callback\n */\nPlugin.prototype.pull = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  if(args.opts._query && !args.opts._query.name) {\n    args.opts._query.name = this.name;\n  }\n  if(args.opts._query && !args.opts._query.remote) {\n    args.opts._query.remote = this.remote;\n  }\n\n  var optsf = {\n    path: '/plugins/pull?',\n    method: 'POST',\n    isStream: true,\n    options: args.opts,\n    statusCodes: {\n      200: true, // unofficial, but proxies may return it\n      204: true,\n      500: 'server error'\n    }\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Enable\n * @param  {Object}   opts     Plugin enable options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.enable = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/enable?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Disable\n * @param  {Object}   opts     Plugin disable options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.disable = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/disable',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * Push\n * @param  {Object}   opts     Plugin push options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.push = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/push',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n/**\n * COnfigure\n * @param  {Object}   opts     Plugin configure options (optional)\n * @param  {Function} callback Callback\n */\nPlugin.prototype.configure = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/set',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Upgrade plugin\n *\n * @param {object} auth\n * @param {object} opts\n * @param {function} callback\n */\nPlugin.prototype.upgrade = function(auth, opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = auth;\n    auth = opts.authconfig || undefined;\n  }\n\n  var optsf = {\n    path: '/plugins/' + this.name + '/upgrade?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'plugin not installed',\n      500: 'server error'\n    },\n    authconfig: auth,\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Plugin;\n","var util = require('./util');\n\n/**\n * Represents a secret\n * @param {Object} modem docker-modem\n * @param {String} id  Secret's id\n */\nvar Secret = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nSecret.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nSecret.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/secrets/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'secret not found',\n      406: 'node is not part of a swarm',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update a secret.\n *\n * @param {object} opts\n * @param {function} callback\n */\nSecret.prototype.update = function(opts, callback) {\n  var self = this;\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n  }\n\n  var optsf = {\n    path: '/secrets/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'secret not found',\n      500: 'server error'\n    },\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n/**\n * Removes the secret\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nSecret.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/secrets/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'secret not found',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Secret;\n","var util = require('./util');\n\n/**\n * Represents an Service\n * @param {Object} modem docker-modem\n * @param {String} id    Service's ID\n */\nvar Service = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n};\n\nService.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for service details.\n *\n * @param {function} callback\n */\nService.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/services/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Delete Service\n *\n * @param {function} callback\n */\nService.prototype.remove = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/services/' + this.id,\n    method: 'DELETE',\n    statusCodes: {\n      200: true,\n      204: true,\n      404: 'no such service',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Update service\n *\n * @param {object} auth\n * @param {object} opts\n * @param {function} callback\n */\nService.prototype.update = function(auth, opts, callback) {\n  var self = this;\n  if (!callback) {\n    var t = typeof opts;\n    if(t === 'function'){\n      callback = opts;\n      opts = auth;\n      auth = opts.authconfig || undefined;\n    } else if (t === 'undefined'){\n      opts = auth;\n      auth = opts.authconfig || undefined;\n    }\n  }\n\n  var optsf = {\n    path: '/services/' + this.id + '/update?',\n    method: 'POST',\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error'\n    },\n    authconfig: auth,\n    options: opts\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n\n\n/**\n * Service logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nService.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, {});\n\n  var optsf = {\n    path: '/services/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      200: true,\n      404: 'no such service',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\n\nmodule.exports = Service;\n","var util = require('./util');\n\n/**\n * Represents an Task\n * @param {Object} modem docker-modem\n * @param {String} id    Task's ID\n */\nvar Task = function(modem, id) {\n  this.modem = modem;\n  this.id = id;\n\n  this.defaultOptions = {\n    log: {}\n  };\n};\n\nTask.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Query Docker for Task details.\n *\n * @param {function} callback\n */\nTask.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/tasks/' + this.id,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'unknown task',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Task logs\n * @param  {Object}   opts     Logs options. (optional)\n * @param  {Function} callback Callback with data\n */\nTask.prototype.logs = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback, this.defaultOptions.log);\n\n  var optsf = {\n    path: '/tasks/' + this.id + '/logs?',\n    method: 'GET',\n    isStream: args.opts.follow || false,\n    statusCodes: {\n      101: true,\n      200: true,\n      404: 'no such container',\n      500: 'server error',\n      503: 'node is not part of a swarm'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\n\nmodule.exports = Task;\n","// https://github.com/HenrikJoreteg/extend-object/blob/v0.1.0/extend-object.js\n\nvar arr = [];\nvar each = arr.forEach;\nvar slice = arr.slice;\n\nmodule.exports.extend = function(obj) {\n  each.call(slice.call(arguments, 1), function(source) {\n    if (source) {\n      for (var prop in source) {\n        obj[prop] = source[prop];\n      }\n    }\n  });\n  return obj;\n};\n\nmodule.exports.processArgs = function(opts, callback, defaultOpts) {\n  if (!callback && typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  }\n  return {\n    callback: callback,\n    opts: module.exports.extend({}, defaultOpts, opts)\n  };\n};\n\n\n/**\n * Parse the given repo tag name (as a string) and break it out into repo/tag pair.\n * // if given the input http://localhost:8080/woot:latest\n * {\n *   repository: 'http://localhost:8080/woot',\n *   tag: 'latest'\n * }\n * @param {String} input Input e.g: 'repo/foo', 'ubuntu', 'ubuntu:latest'\n * @return {Object} input parsed into the repo and tag.\n */\nmodule.exports.parseRepositoryTag = function(input) {\n  var separatorPos;\n  var digestPos = input.indexOf('@');\n  var colonPos = input.lastIndexOf(':');\n  // @ symbol is more important\n  if (digestPos >= 0) {\n    separatorPos = digestPos;\n  } else if (colonPos >= 0) {\n    separatorPos = colonPos;\n  } else {\n    // no colon nor @\n    return {\n      repository: input\n    };\n  }\n\n  // last colon is either the tag (or part of a port designation)\n  var tag = input.slice(separatorPos + 1);\n\n  // if it contains a / its not a tag and is part of the url\n  if (tag.indexOf('/') === -1) {\n    return {\n      repository: input.slice(0, separatorPos),\n      tag: tag\n    };\n  }\n\n  return {\n    repository: input\n  };\n};\n","var util = require('./util');\n\n/**\n * Represents a volume\n * @param {Object} modem docker-modem\n * @param {String} name  Volume's name\n */\nvar Volume = function(modem, name) {\n  this.modem = modem;\n  this.name = name;\n};\n\nVolume.prototype[require('util').inspect.custom] = function() { return this; };\n\n/**\n * Inspect\n * @param  {Function} callback Callback, if specified Docker will be queried.\n * @return {Object}            Name only if callback isn't specified.\n */\nVolume.prototype.inspect = function(callback) {\n  var self = this;\n\n  var optsf = {\n    path: '/volumes/' + this.name,\n    method: 'GET',\n    statusCodes: {\n      200: true,\n      404: 'no such volume',\n      500: 'server error'\n    }\n  };\n\n  if(callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      callback(err, data);\n    });\n  }\n};\n\n/**\n * Removes the volume\n * @param  {[Object]}   opts     Remove options (optional)\n * @param  {Function} callback Callback\n */\nVolume.prototype.remove = function(opts, callback) {\n  var self = this;\n  var args = util.processArgs(opts, callback);\n\n  var optsf = {\n    path: '/volumes/' + this.name,\n    method: 'DELETE',\n    statusCodes: {\n      204: true,\n      404: 'no such volume',\n      409: 'conflict',\n      500: 'server error'\n    },\n    options: args.opts\n  };\n\n  if(args.callback === undefined) {\n    return new this.modem.Promise(function(resolve, reject) {\n      self.modem.dial(optsf, function(err, data) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(data);\n      });\n    });\n  } else {\n    this.modem.dial(optsf, function(err, data) {\n      args.callback(err, data);\n    });\n  }\n};\n\nmodule.exports = Volume;\n","var once = require('once');\n\nvar noop = function() {};\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tprocess.nextTick(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n","module.exports = require('fs').constants || require('constants')\n","try {\n  var util = require('util');\n  if (typeof util.inherits !== 'function') throw '';\n  module.exports = util.inherits;\n} catch (e) {\n  module.exports = require('./inherits_browser.js');\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n","var wrappy = require('wrappy')\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","var pug = require(\"!../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Cdiv class=\\\"form-line\\\"\\u003E\\u003Cdiv class=\\\"header\\\"\\u003E\\u003Cdiv class=\\\"title\\\"\\u003EStart mode\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"description\\\"\\u003EWhether to launch a new container\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"btn-group\\\" [(ngModel)]=\\\"startMode\\\" (ngModelChange)=\\\"updateStartMode()\\\" ngbRadioGroup\\u003E\\u003Clabel class=\\\"btn btn-secondary\\\" ngbButtonLabel\\u003E\\u003Cinput type=\\\"radio\\\" ngbButton [value]=\\\"&quot;image&quot;\\\"\\u003ENew container\\u003C\\u002Flabel\\u003E\\u003Clabel class=\\\"btn btn-secondary\\\" ngbButtonLabel\\u003E\\u003Cinput type=\\\"radio\\\" ngbButton [value]=\\\"&quot;container&quot;\\\"\\u003EAttach\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\" *ngIf=\\\"startMode === &quot;container&quot;\\\"\\u003E\\u003Clabel\\u003EContainer\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\\"form-control\\\" [(ngModel)]=\\\"profile.options.containerName\\\" (ngModelChange)=\\\"clearContainerID()\\\"\\u003E\\u003Coption [value]=\\\"container.names[0]\\\" *ngFor=\\\"let container of containers\\\"\\u003E{{container.names[0]}}\\u003C\\u002Foption\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\" *ngIf=\\\"startMode === &quot;image&quot;\\\"\\u003E\\u003Clabel\\u003EImage\\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\\"input-group flex-nowrap\\\"\\u003E\\u003Cdiv class=\\\"input-group-text flex-grow-1 no-wrap\\\"\\u003E{{ getImageDescription() }}\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"input-group-append flex-shrink-0\\\"\\u003E\\u003Cbutton class=\\\"btn btn-secondary\\\" (click)=\\\"pickImage()\\\"\\u003E\\u003Ci class=\\\"fab fa-docker\\\"\\u003E\\u003C\\u002Fi\\u003E\\u003Cspan\\u003ESelect\\u003C\\u002Fspan\\u003E\\u003C\\u002Fbutton\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-group\\\"\\u003E\\u003Clabel\\u003ECommand\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\\"form-control text-monospace\\\" type=\\\"text\\\" [(ngModel)]=\\\"profile.options.command\\\"\\u003E\\u003C\\u002Fdiv\\u003E\";;return pug_html;};\nmodule.exports = template;","var pug = require(\"!../../node_modules/pug-runtime/index.js\");\n\nfunction template(locals) {var pug_html = \"\", pug_mixins = {}, pug_interp;pug_html = pug_html + \"\\u003Ch3\\u003EDocker\\u003C\\u002Fh3\\u003E\\u003Cdiv class=\\\"form-line\\\"\\u003E\\u003Cdiv class=\\\"header\\\"\\u003E\\u003Cdiv class=\\\"title\\\" translate\\u003EDocker socket path\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"config.store.docker.socket\\\" (ngModelChange)=\\\"config.save()\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-line\\\"\\u003E\\u003Cdiv class=\\\"header\\\"\\u003E\\u003Cdiv class=\\\"title\\\" translate\\u003EDocker host\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"text\\\" [(ngModel)]=\\\"config.store.docker.host\\\" (ngModelChange)=\\\"config.save()\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"form-line\\\"\\u003E\\u003Cdiv class=\\\"header\\\"\\u003E\\u003Cdiv class=\\\"title\\\" translate\\u003EDocker port\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cinput class=\\\"form-control\\\" type=\\\"number\\\" [(ngModel)]=\\\"config.store.docker.port\\\" (ngModelChange)=\\\"config.save()\\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"alert alert-info\\\"\\u003ESet a socket path or a host and a port, or leave blank to use the defaults.\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\\"alert alert-success\\\" *ngIf=\\\"connected\\\"\\u003EConnected\\u003C\\u002Fdiv\\u003E\";;return pug_html;};\nmodule.exports = template;","'use strict';\n\nvar pug_has_own_property = Object.prototype.hasOwnProperty;\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = pug_merge;\nfunction pug_merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = pug_merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n\n  for (var key in b) {\n    if (key === 'class') {\n      var valA = a[key] || [];\n      a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || []);\n    } else if (key === 'style') {\n      var valA = pug_style(a[key]);\n      valA = valA && valA[valA.length - 1] !== ';' ? valA + ';' : valA;\n      var valB = pug_style(b[key]);\n      valB = valB && valB[valB.length - 1] !== ';' ? valB + ';' : valB;\n      a[key] = valA + valB;\n    } else {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Process array, object, or string as a string of classes delimited by a space.\n *\n * If `val` is an array, all members of it and its subarrays are counted as\n * classes. If `escaping` is an array, then whether or not the item in `val` is\n * escaped depends on the corresponding item in `escaping`. If `escaping` is\n * not an array, no escaping is done.\n *\n * If `val` is an object, all the keys whose value is truthy are counted as\n * classes. No escaping is done.\n *\n * If `val` is a string, it is counted as a class. No escaping is done.\n *\n * @param {(Array.<string>|Object.<string, boolean>|string)} val\n * @param {?Array.<string>} escaping\n * @return {String}\n */\nexports.classes = pug_classes;\nfunction pug_classes_array(val, escaping) {\n  var classString = '', className, padding = '', escapeEnabled = Array.isArray(escaping);\n  for (var i = 0; i < val.length; i++) {\n    className = pug_classes(val[i]);\n    if (!className) continue;\n    escapeEnabled && escaping[i] && (className = pug_escape(className));\n    classString = classString + padding + className;\n    padding = ' ';\n  }\n  return classString;\n}\nfunction pug_classes_object(val) {\n  var classString = '', padding = '';\n  for (var key in val) {\n    if (key && val[key] && pug_has_own_property.call(val, key)) {\n      classString = classString + padding + key;\n      padding = ' ';\n    }\n  }\n  return classString;\n}\nfunction pug_classes(val, escaping) {\n  if (Array.isArray(val)) {\n    return pug_classes_array(val, escaping);\n  } else if (val && typeof val === 'object') {\n    return pug_classes_object(val);\n  } else {\n    return val || '';\n  }\n}\n\n/**\n * Convert object or string to a string of CSS styles delimited by a semicolon.\n *\n * @param {(Object.<string, string>|string)} val\n * @return {String}\n */\n\nexports.style = pug_style;\nfunction pug_style(val) {\n  if (!val) return '';\n  if (typeof val === 'object') {\n    var out = '';\n    for (var style in val) {\n      /* istanbul ignore else */\n      if (pug_has_own_property.call(val, style)) {\n        out = out + style + ':' + val[style] + ';';\n      }\n    }\n    return out;\n  } else {\n    return val + '';\n  }\n};\n\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = pug_attr;\nfunction pug_attr(key, val, escaped, terse) {\n  if (val === false || val == null || !val && (key === 'class' || key === 'style')) {\n    return '';\n  }\n  if (val === true) {\n    return ' ' + (terse ? key : key + '=\"' + key + '\"');\n  }\n  if (typeof val.toJSON === 'function') {\n    val = val.toJSON();\n  }\n  if (typeof val !== 'string') {\n    val = JSON.stringify(val);\n    if (!escaped && val.indexOf('\"') !== -1) {\n      return ' ' + key + '=\\'' + val.replace(/'/g, '&#39;') + '\\'';\n    }\n  }\n  if (escaped) val = pug_escape(val);\n  return ' ' + key + '=\"' + val + '\"';\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} terse whether to use HTML5 terse boolean attributes\n * @return {String}\n */\nexports.attrs = pug_attrs;\nfunction pug_attrs(obj, terse){\n  var attrs = '';\n\n  for (var key in obj) {\n    if (pug_has_own_property.call(obj, key)) {\n      var val = obj[key];\n\n      if ('class' === key) {\n        val = pug_classes(val);\n        attrs = pug_attr(key, val, false, terse) + attrs;\n        continue;\n      }\n      if ('style' === key) {\n        val = pug_style(val);\n      }\n      attrs += pug_attr(key, val, false, terse);\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar pug_match_html = /[\"&<>]/;\nexports.escape = pug_escape;\nfunction pug_escape(_html){\n  var html = '' + _html;\n  var regexResult = pug_match_html.exec(html);\n  if (!regexResult) return _html;\n\n  var result = '';\n  var i, lastIndex, escape;\n  for (i = regexResult.index, lastIndex = 0; i < html.length; i++) {\n    switch (html.charCodeAt(i)) {\n      case 34: escape = '&quot;'; break;\n      case 38: escape = '&amp;'; break;\n      case 60: escape = '&lt;'; break;\n      case 62: escape = '&gt;'; break;\n      default: continue;\n    }\n    if (lastIndex !== i) result += html.substring(lastIndex, i);\n    lastIndex = i + 1;\n    result += escape;\n  }\n  if (lastIndex !== i) return result + html.substring(lastIndex, i);\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the pug in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @param {String} str original source\n * @api private\n */\n\nexports.rethrow = pug_rethrow;\nfunction pug_rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || require('fs').readFileSync(filename, 'utf8')\n  } catch (ex) {\n    pug_rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Pug') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n","var once = require('once')\nvar eos = require('end-of-stream')\nvar fs = require('fs') // we only need fs to get the ReadStream and WriteStream prototypes\n\nvar noop = function () {}\nvar ancient = /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('stream');\n","var Stream = require('stream');\nif (process.env.READABLE_STREAM === 'disable' && Stream) {\n  module.exports = Stream;\n  exports = module.exports = Stream.Readable;\n  exports.Readable = Stream.Readable;\n  exports.Writable = Stream.Writable;\n  exports.Duplex = Stream.Duplex;\n  exports.Transform = Stream.Transform;\n  exports.PassThrough = Stream.PassThrough;\n  exports.Stream = Stream;\n} else {\n  exports = module.exports = require('./lib/_stream_readable.js');\n  exports.Stream = Stream || exports;\n  exports.Readable = exports;\n  exports.Writable = require('./lib/_stream_writable.js');\n  exports.Duplex = require('./lib/_stream_duplex.js');\n  exports.Transform = require('./lib/_stream_transform.js');\n  exports.PassThrough = require('./lib/_stream_passthrough.js');\n}\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","/* eslint-disable node/no-deprecated-api */\n\n'use strict'\n\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\nvar safer = {}\n\nvar key\n\nfor (key in buffer) {\n  if (!buffer.hasOwnProperty(key)) continue\n  if (key === 'SlowBuffer' || key === 'Buffer') continue\n  safer[key] = buffer[key]\n}\n\nvar Safer = safer.Buffer = {}\nfor (key in Buffer) {\n  if (!Buffer.hasOwnProperty(key)) continue\n  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue\n  Safer[key] = Buffer[key]\n}\n\nsafer.Buffer.prototype = Buffer.prototype\n\nif (!Safer.from || Safer.from === Uint8Array.from) {\n  Safer.from = function (value, encodingOrOffset, length) {\n    if (typeof value === 'number') {\n      throw new TypeError('The \"value\" argument must not be of type number. Received type ' + typeof value)\n    }\n    if (value && typeof value.length === 'undefined') {\n      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)\n    }\n    return Buffer(value, encodingOrOffset, length)\n  }\n}\n\nif (!Safer.alloc) {\n  Safer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('The \"size\" argument must be of type number. Received type ' + typeof size)\n    }\n    if (size < 0 || size >= 2 * (1 << 30)) {\n      throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n    }\n    var buf = Buffer(size)\n    if (!fill || fill.length === 0) {\n      buf.fill(0)\n    } else if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n    return buf\n  }\n}\n\nif (!safer.kStringMaxLength) {\n  try {\n    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength\n  } catch (e) {\n    // we can't determine kStringMaxLength in environments where process.binding\n    // is unsupported, so let's not set it\n  }\n}\n\nif (!safer.constants) {\n  safer.constants = {\n    MAX_LENGTH: safer.kMaxLength\n  }\n  if (safer.kStringMaxLength) {\n    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength\n  }\n}\n\nmodule.exports = safer\n","exports.quote = function (xs) {\n    return xs.map(function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([A-z]:)?([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '$1\\\\$2');\n        }\n    }).join(' ');\n};\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '\\\\<\\\\(', '>>', '>\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return mapped.reduce(function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(xs.filter(Boolean).map(function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return JSON.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = s.match(chunker).filter(Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return match.map(function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined && key != '')\n            r = '';\n        else if (r === undefined)\n            r = '$';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + JSON.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n","\n;(function (name, root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory()\n    module.exports['default'] = factory()\n  }\n  /* istanbul ignore next */\n  else if (typeof define === 'function' && define.amd) {\n    define(factory)\n  }\n  else {\n    root[name] = factory()\n  }\n}('slugify', this, function () {\n  var charMap = JSON.parse('{\"$\":\"dollar\",\"%\":\"percent\",\"&\":\"and\",\"<\":\"less\",\">\":\"greater\",\"|\":\"or\",\"¢\":\"cent\",\"£\":\"pound\",\"¤\":\"currency\",\"¥\":\"yen\",\"©\":\"(c)\",\"ª\":\"a\",\"®\":\"(r)\",\"º\":\"o\",\"À\":\"A\",\"Á\":\"A\",\"Â\":\"A\",\"Ã\":\"A\",\"Ä\":\"A\",\"Å\":\"A\",\"Æ\":\"AE\",\"Ç\":\"C\",\"È\":\"E\",\"É\":\"E\",\"Ê\":\"E\",\"Ë\":\"E\",\"Ì\":\"I\",\"Í\":\"I\",\"Î\":\"I\",\"Ï\":\"I\",\"Ð\":\"D\",\"Ñ\":\"N\",\"Ò\":\"O\",\"Ó\":\"O\",\"Ô\":\"O\",\"Õ\":\"O\",\"Ö\":\"O\",\"Ø\":\"O\",\"Ù\":\"U\",\"Ú\":\"U\",\"Û\":\"U\",\"Ü\":\"U\",\"Ý\":\"Y\",\"Þ\":\"TH\",\"ß\":\"ss\",\"à\":\"a\",\"á\":\"a\",\"â\":\"a\",\"ã\":\"a\",\"ä\":\"a\",\"å\":\"a\",\"æ\":\"ae\",\"ç\":\"c\",\"è\":\"e\",\"é\":\"e\",\"ê\":\"e\",\"ë\":\"e\",\"ì\":\"i\",\"í\":\"i\",\"î\":\"i\",\"ï\":\"i\",\"ð\":\"d\",\"ñ\":\"n\",\"ò\":\"o\",\"ó\":\"o\",\"ô\":\"o\",\"õ\":\"o\",\"ö\":\"o\",\"ø\":\"o\",\"ù\":\"u\",\"ú\":\"u\",\"û\":\"u\",\"ü\":\"u\",\"ý\":\"y\",\"þ\":\"th\",\"ÿ\":\"y\",\"Ā\":\"A\",\"ā\":\"a\",\"Ă\":\"A\",\"ă\":\"a\",\"Ą\":\"A\",\"ą\":\"a\",\"Ć\":\"C\",\"ć\":\"c\",\"Č\":\"C\",\"č\":\"c\",\"Ď\":\"D\",\"ď\":\"d\",\"Đ\":\"DJ\",\"đ\":\"dj\",\"Ē\":\"E\",\"ē\":\"e\",\"Ė\":\"E\",\"ė\":\"e\",\"Ę\":\"e\",\"ę\":\"e\",\"Ě\":\"E\",\"ě\":\"e\",\"Ğ\":\"G\",\"ğ\":\"g\",\"Ģ\":\"G\",\"ģ\":\"g\",\"Ĩ\":\"I\",\"ĩ\":\"i\",\"Ī\":\"i\",\"ī\":\"i\",\"Į\":\"I\",\"į\":\"i\",\"İ\":\"I\",\"ı\":\"i\",\"Ķ\":\"k\",\"ķ\":\"k\",\"Ļ\":\"L\",\"ļ\":\"l\",\"Ľ\":\"L\",\"ľ\":\"l\",\"Ł\":\"L\",\"ł\":\"l\",\"Ń\":\"N\",\"ń\":\"n\",\"Ņ\":\"N\",\"ņ\":\"n\",\"Ň\":\"N\",\"ň\":\"n\",\"Ō\":\"O\",\"ō\":\"o\",\"Ő\":\"O\",\"ő\":\"o\",\"Œ\":\"OE\",\"œ\":\"oe\",\"Ŕ\":\"R\",\"ŕ\":\"r\",\"Ř\":\"R\",\"ř\":\"r\",\"Ś\":\"S\",\"ś\":\"s\",\"Ş\":\"S\",\"ş\":\"s\",\"Š\":\"S\",\"š\":\"s\",\"Ţ\":\"T\",\"ţ\":\"t\",\"Ť\":\"T\",\"ť\":\"t\",\"Ũ\":\"U\",\"ũ\":\"u\",\"Ū\":\"u\",\"ū\":\"u\",\"Ů\":\"U\",\"ů\":\"u\",\"Ű\":\"U\",\"ű\":\"u\",\"Ų\":\"U\",\"ų\":\"u\",\"Ŵ\":\"W\",\"ŵ\":\"w\",\"Ŷ\":\"Y\",\"ŷ\":\"y\",\"Ÿ\":\"Y\",\"Ź\":\"Z\",\"ź\":\"z\",\"Ż\":\"Z\",\"ż\":\"z\",\"Ž\":\"Z\",\"ž\":\"z\",\"Ə\":\"E\",\"ƒ\":\"f\",\"Ơ\":\"O\",\"ơ\":\"o\",\"Ư\":\"U\",\"ư\":\"u\",\"ǈ\":\"LJ\",\"ǉ\":\"lj\",\"ǋ\":\"NJ\",\"ǌ\":\"nj\",\"Ș\":\"S\",\"ș\":\"s\",\"Ț\":\"T\",\"ț\":\"t\",\"ə\":\"e\",\"˚\":\"o\",\"Ά\":\"A\",\"Έ\":\"E\",\"Ή\":\"H\",\"Ί\":\"I\",\"Ό\":\"O\",\"Ύ\":\"Y\",\"Ώ\":\"W\",\"ΐ\":\"i\",\"Α\":\"A\",\"Β\":\"B\",\"Γ\":\"G\",\"Δ\":\"D\",\"Ε\":\"E\",\"Ζ\":\"Z\",\"Η\":\"H\",\"Θ\":\"8\",\"Ι\":\"I\",\"Κ\":\"K\",\"Λ\":\"L\",\"Μ\":\"M\",\"Ν\":\"N\",\"Ξ\":\"3\",\"Ο\":\"O\",\"Π\":\"P\",\"Ρ\":\"R\",\"Σ\":\"S\",\"Τ\":\"T\",\"Υ\":\"Y\",\"Φ\":\"F\",\"Χ\":\"X\",\"Ψ\":\"PS\",\"Ω\":\"W\",\"Ϊ\":\"I\",\"Ϋ\":\"Y\",\"ά\":\"a\",\"έ\":\"e\",\"ή\":\"h\",\"ί\":\"i\",\"ΰ\":\"y\",\"α\":\"a\",\"β\":\"b\",\"γ\":\"g\",\"δ\":\"d\",\"ε\":\"e\",\"ζ\":\"z\",\"η\":\"h\",\"θ\":\"8\",\"ι\":\"i\",\"κ\":\"k\",\"λ\":\"l\",\"μ\":\"m\",\"ν\":\"n\",\"ξ\":\"3\",\"ο\":\"o\",\"π\":\"p\",\"ρ\":\"r\",\"ς\":\"s\",\"σ\":\"s\",\"τ\":\"t\",\"υ\":\"y\",\"φ\":\"f\",\"χ\":\"x\",\"ψ\":\"ps\",\"ω\":\"w\",\"ϊ\":\"i\",\"ϋ\":\"y\",\"ό\":\"o\",\"ύ\":\"y\",\"ώ\":\"w\",\"Ё\":\"Yo\",\"Ђ\":\"DJ\",\"Є\":\"Ye\",\"І\":\"I\",\"Ї\":\"Yi\",\"Ј\":\"J\",\"Љ\":\"LJ\",\"Њ\":\"NJ\",\"Ћ\":\"C\",\"Џ\":\"DZ\",\"А\":\"A\",\"Б\":\"B\",\"В\":\"V\",\"Г\":\"G\",\"Д\":\"D\",\"Е\":\"E\",\"Ж\":\"Zh\",\"З\":\"Z\",\"И\":\"I\",\"Й\":\"J\",\"К\":\"K\",\"Л\":\"L\",\"М\":\"M\",\"Н\":\"N\",\"О\":\"O\",\"П\":\"P\",\"Р\":\"R\",\"С\":\"S\",\"Т\":\"T\",\"У\":\"U\",\"Ф\":\"F\",\"Х\":\"H\",\"Ц\":\"C\",\"Ч\":\"Ch\",\"Ш\":\"Sh\",\"Щ\":\"Sh\",\"Ъ\":\"U\",\"Ы\":\"Y\",\"Ь\":\"\",\"Э\":\"E\",\"Ю\":\"Yu\",\"Я\":\"Ya\",\"а\":\"a\",\"б\":\"b\",\"в\":\"v\",\"г\":\"g\",\"д\":\"d\",\"е\":\"e\",\"ж\":\"zh\",\"з\":\"z\",\"и\":\"i\",\"й\":\"j\",\"к\":\"k\",\"л\":\"l\",\"м\":\"m\",\"н\":\"n\",\"о\":\"o\",\"п\":\"p\",\"р\":\"r\",\"с\":\"s\",\"т\":\"t\",\"у\":\"u\",\"ф\":\"f\",\"х\":\"h\",\"ц\":\"c\",\"ч\":\"ch\",\"ш\":\"sh\",\"щ\":\"sh\",\"ъ\":\"u\",\"ы\":\"y\",\"ь\":\"\",\"э\":\"e\",\"ю\":\"yu\",\"я\":\"ya\",\"ё\":\"yo\",\"ђ\":\"dj\",\"є\":\"ye\",\"і\":\"i\",\"ї\":\"yi\",\"ј\":\"j\",\"љ\":\"lj\",\"њ\":\"nj\",\"ћ\":\"c\",\"ѝ\":\"u\",\"џ\":\"dz\",\"Ґ\":\"G\",\"ґ\":\"g\",\"Ғ\":\"GH\",\"ғ\":\"gh\",\"Қ\":\"KH\",\"қ\":\"kh\",\"Ң\":\"NG\",\"ң\":\"ng\",\"Ү\":\"UE\",\"ү\":\"ue\",\"Ұ\":\"U\",\"ұ\":\"u\",\"Һ\":\"H\",\"һ\":\"h\",\"Ә\":\"AE\",\"ә\":\"ae\",\"Ө\":\"OE\",\"ө\":\"oe\",\"Ա\":\"A\",\"Բ\":\"B\",\"Գ\":\"G\",\"Դ\":\"D\",\"Ե\":\"E\",\"Զ\":\"Z\",\"Է\":\"E\\'\",\"Ը\":\"Y\\'\",\"Թ\":\"T\\'\",\"Ժ\":\"JH\",\"Ի\":\"I\",\"Լ\":\"L\",\"Խ\":\"X\",\"Ծ\":\"C\\'\",\"Կ\":\"K\",\"Հ\":\"H\",\"Ձ\":\"D\\'\",\"Ղ\":\"GH\",\"Ճ\":\"TW\",\"Մ\":\"M\",\"Յ\":\"Y\",\"Ն\":\"N\",\"Շ\":\"SH\",\"Չ\":\"CH\",\"Պ\":\"P\",\"Ջ\":\"J\",\"Ռ\":\"R\\'\",\"Ս\":\"S\",\"Վ\":\"V\",\"Տ\":\"T\",\"Ր\":\"R\",\"Ց\":\"C\",\"Փ\":\"P\\'\",\"Ք\":\"Q\\'\",\"Օ\":\"O\\'\\'\",\"Ֆ\":\"F\",\"և\":\"EV\",\"฿\":\"baht\",\"ა\":\"a\",\"ბ\":\"b\",\"გ\":\"g\",\"დ\":\"d\",\"ე\":\"e\",\"ვ\":\"v\",\"ზ\":\"z\",\"თ\":\"t\",\"ი\":\"i\",\"კ\":\"k\",\"ლ\":\"l\",\"მ\":\"m\",\"ნ\":\"n\",\"ო\":\"o\",\"პ\":\"p\",\"ჟ\":\"zh\",\"რ\":\"r\",\"ს\":\"s\",\"ტ\":\"t\",\"უ\":\"u\",\"ფ\":\"f\",\"ქ\":\"k\",\"ღ\":\"gh\",\"ყ\":\"q\",\"შ\":\"sh\",\"ჩ\":\"ch\",\"ც\":\"ts\",\"ძ\":\"dz\",\"წ\":\"ts\",\"ჭ\":\"ch\",\"ხ\":\"kh\",\"ჯ\":\"j\",\"ჰ\":\"h\",\"Ẁ\":\"W\",\"ẁ\":\"w\",\"Ẃ\":\"W\",\"ẃ\":\"w\",\"Ẅ\":\"W\",\"ẅ\":\"w\",\"ẞ\":\"SS\",\"Ạ\":\"A\",\"ạ\":\"a\",\"Ả\":\"A\",\"ả\":\"a\",\"Ấ\":\"A\",\"ấ\":\"a\",\"Ầ\":\"A\",\"ầ\":\"a\",\"Ẩ\":\"A\",\"ẩ\":\"a\",\"Ẫ\":\"A\",\"ẫ\":\"a\",\"Ậ\":\"A\",\"ậ\":\"a\",\"Ắ\":\"A\",\"ắ\":\"a\",\"Ằ\":\"A\",\"ằ\":\"a\",\"Ẳ\":\"A\",\"ẳ\":\"a\",\"Ẵ\":\"A\",\"ẵ\":\"a\",\"Ặ\":\"A\",\"ặ\":\"a\",\"Ẹ\":\"E\",\"ẹ\":\"e\",\"Ẻ\":\"E\",\"ẻ\":\"e\",\"Ẽ\":\"E\",\"ẽ\":\"e\",\"Ế\":\"E\",\"ế\":\"e\",\"Ề\":\"E\",\"ề\":\"e\",\"Ể\":\"E\",\"ể\":\"e\",\"Ễ\":\"E\",\"ễ\":\"e\",\"Ệ\":\"E\",\"ệ\":\"e\",\"Ỉ\":\"I\",\"ỉ\":\"i\",\"Ị\":\"I\",\"ị\":\"i\",\"Ọ\":\"O\",\"ọ\":\"o\",\"Ỏ\":\"O\",\"ỏ\":\"o\",\"Ố\":\"O\",\"ố\":\"o\",\"Ồ\":\"O\",\"ồ\":\"o\",\"Ổ\":\"O\",\"ổ\":\"o\",\"Ỗ\":\"O\",\"ỗ\":\"o\",\"Ộ\":\"O\",\"ộ\":\"o\",\"Ớ\":\"O\",\"ớ\":\"o\",\"Ờ\":\"O\",\"ờ\":\"o\",\"Ở\":\"O\",\"ở\":\"o\",\"Ỡ\":\"O\",\"ỡ\":\"o\",\"Ợ\":\"O\",\"ợ\":\"o\",\"Ụ\":\"U\",\"ụ\":\"u\",\"Ủ\":\"U\",\"ủ\":\"u\",\"Ứ\":\"U\",\"ứ\":\"u\",\"Ừ\":\"U\",\"ừ\":\"u\",\"Ử\":\"U\",\"ử\":\"u\",\"Ữ\":\"U\",\"ữ\":\"u\",\"Ự\":\"U\",\"ự\":\"u\",\"Ỳ\":\"Y\",\"ỳ\":\"y\",\"Ỵ\":\"Y\",\"ỵ\":\"y\",\"Ỷ\":\"Y\",\"ỷ\":\"y\",\"Ỹ\":\"Y\",\"ỹ\":\"y\",\"–\":\"-\",\"‘\":\"\\'\",\"’\":\"\\'\",\"“\":\"\\\\\\\"\",\"”\":\"\\\\\\\"\",\"„\":\"\\\\\\\"\",\"†\":\"+\",\"•\":\"*\",\"…\":\"...\",\"₠\":\"ecu\",\"₢\":\"cruzeiro\",\"₣\":\"french franc\",\"₤\":\"lira\",\"₥\":\"mill\",\"₦\":\"naira\",\"₧\":\"peseta\",\"₨\":\"rupee\",\"₩\":\"won\",\"₪\":\"new shequel\",\"₫\":\"dong\",\"€\":\"euro\",\"₭\":\"kip\",\"₮\":\"tugrik\",\"₯\":\"drachma\",\"₰\":\"penny\",\"₱\":\"peso\",\"₲\":\"guarani\",\"₳\":\"austral\",\"₴\":\"hryvnia\",\"₵\":\"cedi\",\"₸\":\"kazakhstani tenge\",\"₹\":\"indian rupee\",\"₺\":\"turkish lira\",\"₽\":\"russian ruble\",\"₿\":\"bitcoin\",\"℠\":\"sm\",\"™\":\"tm\",\"∂\":\"d\",\"∆\":\"delta\",\"∑\":\"sum\",\"∞\":\"infinity\",\"♥\":\"love\",\"元\":\"yuan\",\"円\":\"yen\",\"﷼\":\"rial\"}')\n  var locales = JSON.parse('{\"de\":{\"Ä\":\"AE\",\"ä\":\"ae\",\"Ö\":\"OE\",\"ö\":\"oe\",\"Ü\":\"UE\",\"ü\":\"ue\",\"%\":\"prozent\",\"&\":\"und\",\"|\":\"oder\",\"∑\":\"summe\",\"∞\":\"unendlich\",\"♥\":\"liebe\"},\"es\":{\"%\":\"por ciento\",\"&\":\"y\",\"<\":\"menor que\",\">\":\"mayor que\",\"|\":\"o\",\"¢\":\"centavos\",\"£\":\"libras\",\"¤\":\"moneda\",\"₣\":\"francos\",\"∑\":\"suma\",\"∞\":\"infinito\",\"♥\":\"amor\"},\"fr\":{\"%\":\"pourcent\",\"&\":\"et\",\"<\":\"plus petit\",\">\":\"plus grand\",\"|\":\"ou\",\"¢\":\"centime\",\"£\":\"livre\",\"¤\":\"devise\",\"₣\":\"franc\",\"∑\":\"somme\",\"∞\":\"infini\",\"♥\":\"amour\"},\"pt\":{\"%\":\"porcento\",\"&\":\"e\",\"<\":\"menor\",\">\":\"maior\",\"|\":\"ou\",\"¢\":\"centavo\",\"∑\":\"soma\",\"£\":\"libra\",\"∞\":\"infinito\",\"♥\":\"amor\"},\"uk\":{\"И\":\"Y\",\"и\":\"y\",\"Й\":\"Y\",\"й\":\"y\",\"Ц\":\"Ts\",\"ц\":\"ts\",\"Х\":\"Kh\",\"х\":\"kh\",\"Щ\":\"Shch\",\"щ\":\"shch\",\"Г\":\"H\",\"г\":\"h\"},\"vi\":{\"Đ\":\"D\",\"đ\":\"d\"}}')\n\n  function replace (string, options) {\n    if (typeof string !== 'string') {\n      throw new Error('slugify: string argument expected')\n    }\n\n    options = (typeof options === 'string')\n      ? {replacement: options}\n      : options || {}\n\n    var locale = locales[options.locale] || {}\n\n    var replacement = options.replacement === undefined ? '-' : options.replacement\n\n    var trim = options.trim === undefined ? true : options.trim\n\n    var slug = string.normalize().split('')\n      // replace characters based on charMap\n      .reduce(function (result, ch) {\n        return result + (locale[ch] || charMap[ch] ||  (ch === replacement ? ' ' : ch))\n          // remove not allowed characters\n          .replace(options.remove || /[^\\w\\s$*_+~.()'\"!\\-:@]+/g, '')\n      }, '');\n\n    if (options.strict) {\n      slug = slug.replace(/[^A-Za-z0-9\\s]/g, '');\n    }\n\n    if (trim) {\n      slug = slug.trim()\n    }\n\n    // Replace spaces with replacement character, treating multiple consecutive\n    // spaces as a single space.\n    slug = slug.replace(/\\s+/g, replacement);\n\n    if (options.lower) {\n      slug = slug.toLowerCase()\n    }\n\n    return slug\n  }\n\n  replace.extend = function (customMap) {\n    Object.assign(charMap, customMap)\n  }\n\n  return replace\n}))\n","var fs = require('fs');\n\nmodule.exports = function (filepath, split, encoding) {\n  split = typeof split !== 'undefined' ? split : \"\\n\";\n  encoding = typeof encoding !== 'undefined' ? encoding : \"utf8\";\n\n  var ca = [];\n  var chain = fs.readFileSync(filepath, encoding);\n  if(chain.indexOf(\"-END CERTIFICATE-\") < 0 || chain.indexOf(\"-BEGIN CERTIFICATE-\") < 0){\n    throw Error(\"File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'\");\n  }\n  chain = chain.split(split);\n  var cert = [];\n  var _i, _len;\n  for (_i = 0, _len = chain.length; _i < _len; _i++) {\n    var line = chain[_i];\n    if (!(line.length !== 0)) {\n      continue;\n    }\n    cert.push(line);\n    if (line.match(/-END CERTIFICATE-/)) {\n      ca.push(cert.join(split));\n      cert = [];\n    }\n  }\n  return ca;\n}\n","module.exports = {\n  SFTPStream: require('./lib/sftp'),\n  SSH2Stream: require('./lib/ssh'),\n  utils: require('./lib/utils'),\n  constants: require('./lib/constants')\n};","module.exports = {\n  readUInt32BE: function readUInt32BE(buf, offset) {\n    return buf[offset++] * 16777216\n           + buf[offset++] * 65536\n           + buf[offset++] * 256\n           + buf[offset];\n  },\n  writeUInt32BE: function writeUInt32BE(buf, value, offset) {\n    buf[offset++] = (value >>> 24);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = value;\n    return offset;\n  },\n  writeUInt32LE: function writeUInt32LE(buf, value, offset) {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  }\n};\n","var i;\nvar keys;\nvar len;\n\nvar crypto = require('crypto');\nvar eddsaSupported = (function() {\n  if (typeof crypto.sign === 'function'\n      && typeof crypto.verify === 'function') {\n    var key = '-----BEGIN PRIVATE KEY-----\\r\\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD'\n              + '/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\\r\\n-----END PRIVATE KEY-----';\n    var data = Buffer.from('a');\n    var sig;\n    var verified;\n    try {\n      sig = crypto.sign(null, data, key);\n      verified = crypto.verify(null, data, key, sig);\n    } catch (ex) {}\n    return (Buffer.isBuffer(sig) && sig.length === 64 && verified === true);\n  }\n\n  return false;\n})();\n\nvar curve25519Supported = (typeof crypto.diffieHellman === 'function'\n                           && typeof crypto.generateKeyPairSync === 'function'\n                           && typeof crypto.createPublicKey === 'function');\n\nvar MESSAGE = exports.MESSAGE = {\n  // Transport layer protocol -- generic (1-19)\n  DISCONNECT: 1,\n  IGNORE: 2,\n  UNIMPLEMENTED: 3,\n  DEBUG: 4,\n  SERVICE_REQUEST: 5,\n  SERVICE_ACCEPT: 6,\n\n  // Transport layer protocol -- algorithm negotiation (20-29)\n  KEXINIT: 20,\n  NEWKEYS: 21,\n\n  // Transport layer protocol -- key exchange method-specific (30-49)\n\n  // User auth protocol -- generic (50-59)\n  USERAUTH_REQUEST: 50,\n  USERAUTH_FAILURE: 51,\n  USERAUTH_SUCCESS: 52,\n  USERAUTH_BANNER: 53,\n\n  // User auth protocol -- user auth method-specific (60-79)\n\n  // Connection protocol -- generic (80-89)\n  GLOBAL_REQUEST: 80,\n  REQUEST_SUCCESS: 81,\n  REQUEST_FAILURE: 82,\n\n  // Connection protocol -- channel-related (90-127)\n  CHANNEL_OPEN: 90,\n  CHANNEL_OPEN_CONFIRMATION: 91,\n  CHANNEL_OPEN_FAILURE: 92,\n  CHANNEL_WINDOW_ADJUST: 93,\n  CHANNEL_DATA: 94,\n  CHANNEL_EXTENDED_DATA: 95,\n  CHANNEL_EOF: 96,\n  CHANNEL_CLOSE: 97,\n  CHANNEL_REQUEST: 98,\n  CHANNEL_SUCCESS: 99,\n  CHANNEL_FAILURE: 100\n\n  // Reserved for client protocols (128-191)\n\n  // Local extensions (192-155)\n};\nfor (i = 0, keys = Object.keys(MESSAGE), len = keys.length; i < len; ++i)\n  MESSAGE[MESSAGE[keys[i]]] = keys[i];\n// context-specific message codes:\nMESSAGE.KEXDH_INIT = 30;\nMESSAGE.KEXDH_REPLY = 31;\nMESSAGE.KEXDH_GEX_REQUEST = 34;\nMESSAGE.KEXDH_GEX_GROUP = 31;\nMESSAGE.KEXDH_GEX_INIT = 32;\nMESSAGE.KEXDH_GEX_REPLY = 33;\nMESSAGE.KEXECDH_INIT = 30; // included here for completeness\nMESSAGE.KEXECDH_REPLY = 31; // included here for completeness\nMESSAGE.USERAUTH_PASSWD_CHANGEREQ = 60;\nMESSAGE.USERAUTH_PK_OK = 60;\nMESSAGE.USERAUTH_INFO_REQUEST = 60;\nMESSAGE.USERAUTH_INFO_RESPONSE = 61;\n\nvar DYNAMIC_KEXDH_MESSAGE = exports.DYNAMIC_KEXDH_MESSAGE = {};\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_GROUP] = 'KEXDH_GEX_GROUP';\nDYNAMIC_KEXDH_MESSAGE[MESSAGE.KEXDH_GEX_REPLY] = 'KEXDH_GEX_REPLY';\n\nvar KEXDH_MESSAGE = exports.KEXDH_MESSAGE = {};\nKEXDH_MESSAGE[MESSAGE.KEXDH_INIT] = 'KEXDH_INIT';\nKEXDH_MESSAGE[MESSAGE.KEXDH_REPLY] = 'KEXDH_REPLY';\n\nvar DISCONNECT_REASON = exports.DISCONNECT_REASON = {\n  HOST_NOT_ALLOWED_TO_CONNECT: 1,\n  PROTOCOL_ERROR: 2,\n  KEY_EXCHANGE_FAILED: 3,\n  RESERVED: 4,\n  MAC_ERROR: 5,\n  COMPRESSION_ERROR: 6,\n  SERVICE_NOT_AVAILABLE: 7,\n  PROTOCOL_VERSION_NOT_SUPPORTED: 8,\n  HOST_KEY_NOT_VERIFIABLE: 9,\n  CONNECTION_LOST: 10,\n  BY_APPLICATION: 11,\n  TOO_MANY_CONNECTIONS: 12,\n  AUTH_CANCELED_BY_USER: 13,\n  NO_MORE_AUTH_METHODS_AVAILABLE: 14,\n  ILLEGAL_USER_NAME: 15\n};\nfor (i = 0, keys = Object.keys(DISCONNECT_REASON), len = keys.length;\n     i < len;\n     ++i) {\n  DISCONNECT_REASON[DISCONNECT_REASON[keys[i]]] = keys[i];\n}\n\nvar CHANNEL_OPEN_FAILURE = exports.CHANNEL_OPEN_FAILURE = {\n  ADMINISTRATIVELY_PROHIBITED: 1,\n  CONNECT_FAILED: 2,\n  UNKNOWN_CHANNEL_TYPE: 3,\n  RESOURCE_SHORTAGE: 4\n};\nfor (i = 0, keys = Object.keys(CHANNEL_OPEN_FAILURE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_OPEN_FAILURE[CHANNEL_OPEN_FAILURE[keys[i]]] = keys[i];\n}\n\nvar TERMINAL_MODE = exports.TERMINAL_MODE = {\n  TTY_OP_END: 0,        // Indicates end of options.\n  VINTR: 1,             // Interrupt character; 255 if none. Similarly for the\n                        //  other characters.  Not all of these characters are\n                        //  supported on all systems.\n  VQUIT: 2,             // The quit character (sends SIGQUIT signal on POSIX\n                        //  systems).\n  VERASE: 3,            // Erase the character to left of the cursor.\n  VKILL: 4,             // Kill the current input line.\n  VEOF: 5,              // End-of-file character (sends EOF from the terminal).\n  VEOL: 6,              // End-of-line character in addition to carriage return\n                        //  and/or linefeed.\n  VEOL2: 7,             // Additional end-of-line character.\n  VSTART: 8,            // Continues paused output (normally control-Q).\n  VSTOP: 9,             // Pauses output (normally control-S).\n  VSUSP: 10,            // Suspends the current program.\n  VDSUSP: 11,           // Another suspend character.\n  VREPRINT: 12,         // Reprints the current input line.\n  VWERASE: 13,          // Erases a word left of cursor.\n  VLNEXT: 14,           // Enter the next character typed literally, even if it\n                        //  is a special character\n  VFLUSH: 15,           // Character to flush output.\n  VSWTCH: 16,           // Switch to a different shell layer.\n  VSTATUS: 17,          // Prints system status line (load, command, pid, etc).\n  VDISCARD: 18,         // Toggles the flushing of terminal output.\n  IGNPAR: 30,           // The ignore parity flag.  The parameter SHOULD be 0\n                        //  if this flag is FALSE, and 1 if it is TRUE.\n  PARMRK: 31,           // Mark parity and framing errors.\n  INPCK: 32,            // Enable checking of parity errors.\n  ISTRIP: 33,           // Strip 8th bit off characters.\n  INLCR: 34,            // Map NL into CR on input.\n  IGNCR: 35,            // Ignore CR on input.\n  ICRNL: 36,            // Map CR to NL on input.\n  IUCLC: 37,            // Translate uppercase characters to lowercase.\n  IXON: 38,             // Enable output flow control.\n  IXANY: 39,            // Any char will restart after stop.\n  IXOFF: 40,            // Enable input flow control.\n  IMAXBEL: 41,          // Ring bell on input queue full.\n  ISIG: 50,             // Enable signals INTR, QUIT, [D]SUSP.\n  ICANON: 51,           // Canonicalize input lines.\n  XCASE: 52,            // Enable input and output of uppercase characters by\n                        //  preceding their lowercase equivalents with \"\\\".\n  ECHO: 53,             // Enable echoing.\n  ECHOE: 54,            // Visually erase chars.\n  ECHOK: 55,            // Kill character discards current line.\n  ECHONL: 56,           // Echo NL even if ECHO is off.\n  NOFLSH: 57,           // Don't flush after interrupt.\n  TOSTOP: 58,           // Stop background jobs from output.\n  IEXTEN: 59,           // Enable extensions.\n  ECHOCTL: 60,          // Echo control characters as ^(Char).\n  ECHOKE: 61,           // Visual erase for line kill.\n  PENDIN: 62,           // Retype pending input.\n  OPOST: 70,            // Enable output processing.\n  OLCUC: 71,            // Convert lowercase to uppercase.\n  ONLCR: 72,            // Map NL to CR-NL.\n  OCRNL: 73,            // Translate carriage return to newline (output).\n  ONOCR: 74,            // Translate newline to carriage return-newline\n                        // (output).\n  ONLRET: 75,           // Newline performs a carriage return (output).\n  CS7: 90,              // 7 bit mode.\n  CS8: 91,              // 8 bit mode.\n  PARENB: 92,           // Parity enable.\n  PARODD: 93,           // Odd parity, else even.\n  TTY_OP_ISPEED: 128,   // Specifies the input baud rate in bits per second.\n  TTY_OP_OSPEED: 129    // Specifies the output baud rate in bits per second.\n};\nfor (i = 0, keys = Object.keys(TERMINAL_MODE), len = keys.length; i < len; ++i)\n  TERMINAL_MODE[TERMINAL_MODE[keys[i]]] = keys[i];\n\nvar CHANNEL_EXTENDED_DATATYPE = exports.CHANNEL_EXTENDED_DATATYPE = {\n  STDERR: 1\n};\nfor (i = 0, keys = Object.keys(CHANNEL_EXTENDED_DATATYPE), len = keys.length;\n     i < len;\n     ++i) {\n  CHANNEL_EXTENDED_DATATYPE[CHANNEL_EXTENDED_DATATYPE[keys[i]]] = keys[i];\n}\n\nexports.SIGNALS = ['ABRT', 'ALRM', 'FPE', 'HUP', 'ILL', 'INT',\n                   'QUIT', 'SEGV', 'TERM', 'USR1', 'USR2', 'KILL',\n                   'PIPE'];\n\nvar DEFAULT_KEX = [\n  // https://tools.ietf.org/html/rfc5656#section-10.1\n  'ecdh-sha2-nistp256',\n  'ecdh-sha2-nistp384',\n  'ecdh-sha2-nistp521',\n\n  // https://tools.ietf.org/html/rfc4419#section-4\n  'diffie-hellman-group-exchange-sha256',\n\n  'diffie-hellman-group14-sha256',\n  'diffie-hellman-group16-sha512',\n  'diffie-hellman-group18-sha512',\n\n  'diffie-hellman-group14-sha1', // REQUIRED\n];\nif (curve25519Supported) {\n  DEFAULT_KEX.unshift('curve25519-sha256');\n  DEFAULT_KEX.unshift('curve25519-sha256@libssh.org');\n}\nvar SUPPORTED_KEX = [\n  // https://tools.ietf.org/html/rfc4419#section-4\n  'diffie-hellman-group-exchange-sha1',\n\n  'diffie-hellman-group1-sha1'  // REQUIRED\n];\nvar KEX_BUF = Buffer.from(DEFAULT_KEX.join(','), 'ascii');\nSUPPORTED_KEX = DEFAULT_KEX.concat(SUPPORTED_KEX);\n\nvar DEFAULT_SERVER_HOST_KEY = [\n  'ecdsa-sha2-nistp256',\n  'ecdsa-sha2-nistp384',\n  'ecdsa-sha2-nistp521',\n  'ssh-rsa',\n];\nif (eddsaSupported)\n  DEFAULT_SERVER_HOST_KEY.unshift('ssh-ed25519');\nvar SUPPORTED_SERVER_HOST_KEY = [\n  'ssh-dss'\n];\nvar SERVER_HOST_KEY_BUF = Buffer.from(DEFAULT_SERVER_HOST_KEY.join(','),\n                                      'ascii');\nSUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat(\n  SUPPORTED_SERVER_HOST_KEY\n);\n\nvar DEFAULT_CIPHER = [\n  // http://tools.ietf.org/html/rfc4344#section-4\n  'aes128-ctr',\n  'aes192-ctr',\n  'aes256-ctr',\n\n  // http://tools.ietf.org/html/rfc5647\n  'aes128-gcm',\n  'aes128-gcm@openssh.com',\n  'aes256-gcm',\n  'aes256-gcm@openssh.com'\n];\nvar SUPPORTED_CIPHER = [\n  'aes256-cbc',\n  'aes192-cbc',\n  'aes128-cbc',\n  'blowfish-cbc',\n  '3des-cbc',\n\n  // http://tools.ietf.org/html/rfc4345#section-4:\n  'arcfour256',\n  'arcfour128',\n\n  'cast128-cbc',\n  'arcfour'\n];\nvar CIPHER_BUF = Buffer.from(DEFAULT_CIPHER.join(','), 'ascii');\nSUPPORTED_CIPHER = DEFAULT_CIPHER.concat(SUPPORTED_CIPHER);\n\nvar DEFAULT_HMAC = [\n  'hmac-sha2-256',\n  'hmac-sha2-512',\n  'hmac-sha1',\n];\nvar SUPPORTED_HMAC = [\n  'hmac-md5',\n  'hmac-sha2-256-96', // first 96 bits of HMAC-SHA256\n  'hmac-sha2-512-96', // first 96 bits of HMAC-SHA512\n  'hmac-ripemd160',\n  'hmac-sha1-96',     // first 96 bits of HMAC-SHA1\n  'hmac-md5-96'       // first 96 bits of HMAC-MD5\n];\nvar HMAC_BUF = Buffer.from(DEFAULT_HMAC.join(','), 'ascii');\nSUPPORTED_HMAC = DEFAULT_HMAC.concat(SUPPORTED_HMAC);\n\nvar DEFAULT_COMPRESS = [\n  'none',\n  'zlib@openssh.com', // ZLIB (LZ77) compression, except\n                      // compression/decompression does not start until after\n                      // successful user authentication\n  'zlib'              // ZLIB (LZ77) compression\n];\nvar SUPPORTED_COMPRESS = [];\nvar COMPRESS_BUF = Buffer.from(DEFAULT_COMPRESS.join(','), 'ascii');\nSUPPORTED_COMPRESS = DEFAULT_COMPRESS.concat(SUPPORTED_COMPRESS);\n\nfunction makeCipherInfo(blockLen, keyLen, ivLen, authLen, discardLen, stream) {\n  return {\n    blockLen: blockLen,\n    keyLen: keyLen,\n    ivLen: ivLen === 0 ? blockLen : ivLen,\n    authLen: authLen,\n    discardLen: discardLen,\n    stream: stream,\n  };\n}\nexports.CIPHER_INFO = {\n  'aes128-gcm': makeCipherInfo(16, 16, 12, 16, 0, false),\n  'aes256-gcm': makeCipherInfo(16, 32, 12, 16, 0, false),\n  'aes128-gcm@openssh.com': makeCipherInfo(16, 16, 12, 16, 0, false),\n  'aes256-gcm@openssh.com': makeCipherInfo(16, 32, 12, 16, 0, false),\n\n  'aes128-cbc': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'aes192-cbc': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'aes256-cbc': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'rijndael-cbc@lysator.liu.se': makeCipherInfo(16, 32, 0, 0, 0, false),\n  '3des-cbc': makeCipherInfo(8, 24, 0, 0, 0, false),\n  'blowfish-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'idea-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'cast128-cbc': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'camellia128-cbc': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-cbc': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-cbc': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'camellia128-cbc@openssh.com': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-cbc@openssh.com': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-cbc@openssh.com': makeCipherInfo(16, 32, 0, 0, 0, false),\n\n  'aes128-ctr': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'aes192-ctr': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'aes256-ctr': makeCipherInfo(16, 32, 0, 0, 0, false),\n  '3des-ctr': makeCipherInfo(8, 24, 0, 0, 0, false),\n  'blowfish-ctr': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'cast128-ctr': makeCipherInfo(8, 16, 0, 0, 0, false),\n  'camellia128-ctr': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-ctr': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-ctr': makeCipherInfo(16, 32, 0, 0, 0, false),\n  'camellia128-ctr@openssh.com': makeCipherInfo(16, 16, 0, 0, 0, false),\n  'camellia192-ctr@openssh.com': makeCipherInfo(16, 24, 0, 0, 0, false),\n  'camellia256-ctr@openssh.com': makeCipherInfo(16, 32, 0, 0, 0, false),\n\n  /* The \"arcfour128\" algorithm is the RC4 cipher, as described in\n     [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream\n     generated by the cipher MUST be discarded, and the first byte of the\n     first encrypted packet MUST be encrypted using the 1537th byte of\n     keystream.\n\n     -- http://tools.ietf.org/html/rfc4345#section-4 */\n  'arcfour': makeCipherInfo(8, 16, 0, 0, 1536, true),\n  'arcfour128': makeCipherInfo(8, 16, 0, 0, 1536, true),\n  'arcfour256': makeCipherInfo(8, 32, 0, 0, 1536, true),\n  'arcfour512': makeCipherInfo(8, 64, 0, 0, 1536, true),\n};\n\nfunction makeHMACInfo(len, actualLen) {\n  return { len: len, actualLen: actualLen };\n}\nexports.HMAC_INFO = {\n  'hmac-md5': makeHMACInfo(16, 16),\n  'hmac-md5-96': makeHMACInfo(16, 12),\n  'hmac-ripemd160': makeHMACInfo(20, 20),\n  'hmac-sha1': makeHMACInfo(20, 20),\n  'hmac-sha1-96': makeHMACInfo(20, 12),\n  'hmac-sha2-256': makeHMACInfo(32, 32),\n  'hmac-sha2-256-96': makeHMACInfo(32, 12),\n  'hmac-sha2-512': makeHMACInfo(64, 64),\n  'hmac-sha2-512-96': makeHMACInfo(64, 12),\n};\n\nexports.ALGORITHMS = {\n  KEX: DEFAULT_KEX,\n  KEX_BUF: KEX_BUF,\n  SUPPORTED_KEX: SUPPORTED_KEX,\n\n  SERVER_HOST_KEY: DEFAULT_SERVER_HOST_KEY,\n  SERVER_HOST_KEY_BUF: SERVER_HOST_KEY_BUF,\n  SUPPORTED_SERVER_HOST_KEY: SUPPORTED_SERVER_HOST_KEY,\n\n  CIPHER: DEFAULT_CIPHER,\n  CIPHER_BUF: CIPHER_BUF,\n  SUPPORTED_CIPHER: SUPPORTED_CIPHER,\n\n  HMAC: DEFAULT_HMAC,\n  HMAC_BUF: HMAC_BUF,\n  SUPPORTED_HMAC: SUPPORTED_HMAC,\n\n  COMPRESS: DEFAULT_COMPRESS,\n  COMPRESS_BUF: COMPRESS_BUF,\n  SUPPORTED_COMPRESS: SUPPORTED_COMPRESS\n};\nexports.SSH_TO_OPENSSL = {\n  // ECDH key exchange\n  'ecdh-sha2-nistp256': 'prime256v1', // OpenSSL's name for 'secp256r1'\n  'ecdh-sha2-nistp384': 'secp384r1',\n  'ecdh-sha2-nistp521': 'secp521r1',\n  // Ciphers\n  'aes128-gcm': 'aes-128-gcm',\n  'aes256-gcm': 'aes-256-gcm',\n  'aes128-gcm@openssh.com': 'aes-128-gcm',\n  'aes256-gcm@openssh.com': 'aes-256-gcm',\n  '3des-cbc': 'des-ede3-cbc',\n  'blowfish-cbc': 'bf-cbc',\n  'aes256-cbc': 'aes-256-cbc',\n  'aes192-cbc': 'aes-192-cbc',\n  'aes128-cbc': 'aes-128-cbc',\n  'idea-cbc': 'idea-cbc',\n  'cast128-cbc': 'cast-cbc',\n  'rijndael-cbc@lysator.liu.se': 'aes-256-cbc',\n  'arcfour128': 'rc4',\n  'arcfour256': 'rc4',\n  'arcfour512': 'rc4',\n  'arcfour': 'rc4',\n  'camellia128-cbc': 'camellia-128-cbc',\n  'camellia192-cbc': 'camellia-192-cbc',\n  'camellia256-cbc': 'camellia-256-cbc',\n  'camellia128-cbc@openssh.com': 'camellia-128-cbc',\n  'camellia192-cbc@openssh.com': 'camellia-192-cbc',\n  'camellia256-cbc@openssh.com': 'camellia-256-cbc',\n  '3des-ctr': 'des-ede3',\n  'blowfish-ctr': 'bf-ecb',\n  'aes256-ctr': 'aes-256-ctr',\n  'aes192-ctr': 'aes-192-ctr',\n  'aes128-ctr': 'aes-128-ctr',\n  'cast128-ctr': 'cast5-ecb',\n  'camellia128-ctr': 'camellia-128-ecb',\n  'camellia192-ctr': 'camellia-192-ecb',\n  'camellia256-ctr': 'camellia-256-ecb',\n  'camellia128-ctr@openssh.com': 'camellia-128-ecb',\n  'camellia192-ctr@openssh.com': 'camellia-192-ecb',\n  'camellia256-ctr@openssh.com': 'camellia-256-ecb',\n  // HMAC\n  'hmac-sha1-96': 'sha1',\n  'hmac-sha1': 'sha1',\n  'hmac-sha2-256': 'sha256',\n  'hmac-sha2-256-96': 'sha256',\n  'hmac-sha2-512': 'sha512',\n  'hmac-sha2-512-96': 'sha512',\n  'hmac-md5-96': 'md5',\n  'hmac-md5': 'md5',\n  'hmac-ripemd160': 'ripemd160'\n};\n\nvar BUGS = exports.BUGS = {\n  BAD_DHGEX: 1,\n  OLD_EXIT: 2,\n  DYN_RPORT_BUG: 4\n};\n\nexports.BUGGY_IMPLS = [\n  [ 'Cisco-1.25', BUGS.BAD_DHGEX ],\n  [ /^[0-9.]+$/, BUGS.OLD_EXIT ], // old SSH.com implementations\n  [ /^OpenSSH_5\\.\\d+/, BUGS.DYN_RPORT_BUG ]\n];\n\nexports.EDDSA_SUPPORTED = eddsaSupported;\nexports.CURVE25519_SUPPORTED = curve25519Supported;\n","// Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Basic JavaScript BN library - subset useful for RSA encryption.\n\n// Bits per digit\nvar dbits;\n\n// JavaScript engine analysis\nvar canary = 0xdeadbeefcafe;\nvar j_lm = ((canary&0xffffff)==0xefcafe);\n\n// (public) Constructor\nfunction BigInteger(a,b,c) {\n  if(a != null)\n    if(\"number\" == typeof a) this.fromNumber(a,b,c);\n    else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n    else this.fromString(a,b);\n}\n\n// return new, unset BigInteger\nfunction nbi() { return new BigInteger(null); }\n\n// am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n\n// Set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\nfunction am3(i,x,w,j,c,n) {\n  var xl = x&0x3fff, xh = x>>14;\n  while(--n >= 0) {\n    var l = this[i]&0x3fff;\n    var h = this[i++]>>14;\n    var m = xh*l+h*xl;\n    l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n    c = (l>>28)+(m>>14)+xh*h;\n    w[j++] = l&0xfffffff;\n  }\n  return c;\n}\nBigInteger.prototype.am = am3;\ndbits = 28;\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = ((1<<dbits)-1);\nBigInteger.prototype.DV = (1<<dbits);\n\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2,BI_FP);\nBigInteger.prototype.F1 = BI_FP-dbits;\nBigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n// Digit conversions\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr,vv;\nrr = \"0\".charCodeAt(0);\nfor(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\nrr = \"a\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\nrr = \"A\".charCodeAt(0);\nfor(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\nfunction int2char(n) { return BI_RM.charAt(n); }\nfunction intAt(s,i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return (c==null)?-1:c;\n}\n\n// (protected) copy this to r\nfunction bnpCopyTo(r) {\n  for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n  r.t = this.t;\n  r.s = this.s;\n}\n\n// (protected) set from integer value x, -DV <= x < DV\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = (x<0)?-1:0;\n  if(x > 0) this[0] = x;\n  else if(x < -1) this[0] = x+this.DV;\n  else this.t = 0;\n}\n\n// return bigint initialized to value\nfunction nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n// (protected) set from string and radix\nfunction bnpFromString(s,b) {\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 256) k = 8; // byte array\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else { this.fromRadix(s,b); return; }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length, mi = false, sh = 0;\n  while(--i >= 0) {\n    var x = (k==8)?s[i]&0xff:intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n    mi = false;\n    if(sh == 0)\n      this[this.t++] = x;\n    else if(sh+k > this.DB) {\n      this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n      this[this.t++] = (x>>(this.DB-sh));\n    }\n    else\n      this[this.t-1] |= x<<sh;\n    sh += k;\n    if(sh >= this.DB) sh -= this.DB;\n  }\n  if(k == 8 && (s[0]&0x80) != 0) {\n    this.s = -1;\n    if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n  }\n  this.clamp();\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) clamp off excess high words\nfunction bnpClamp() {\n  var c = this.s&this.DM;\n  while(this.t > 0 && this[this.t-1] == c) --this.t;\n}\n\n// (public) return string representation in given radix\nfunction bnToString(b) {\n  if(this.s < 0) return \"-\"+this.negate().toString(b);\n  var k;\n  if(b == 16) k = 4;\n  else if(b == 8) k = 3;\n  else if(b == 2) k = 1;\n  else if(b == 32) k = 5;\n  else if(b == 4) k = 2;\n  else return this.toRadix(b);\n  var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n  var p = this.DB-(i*this.DB)%k;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n    while(i >= 0) {\n      if(p < k) {\n        d = (this[i]&((1<<p)-1))<<(k-p);\n        d |= this[--i]>>(p+=this.DB-k);\n      }\n      else {\n        d = (this[i]>>(p-=k))&km;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if(d > 0) m = true;\n      if(m) r += int2char(d);\n    }\n  }\n  return m?r:\"0\";\n}\n\n// (public) -this\nfunction bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n// (public) |this|\nfunction bnAbs() { return (this.s<0)?this.negate():this; }\n\n// (public) return + if this > a, - if this < a, 0 if equal\nfunction bnCompareTo(a) {\n  var r = this.s-a.s;\n  if(r != 0) return r;\n  var i = this.t;\n  r = i-a.t;\n  if(r != 0) return (this.s<0)?-r:r;\n  while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n  return 0;\n}\n\n// returns bit length of the integer x\nfunction nbits(x) {\n  var r = 1, t;\n  if((t=x>>>16) != 0) { x = t; r += 16; }\n  if((t=x>>8) != 0) { x = t; r += 8; }\n  if((t=x>>4) != 0) { x = t; r += 4; }\n  if((t=x>>2) != 0) { x = t; r += 2; }\n  if((t=x>>1) != 0) { x = t; r += 1; }\n  return r;\n}\n\n// (public) return the number of bits in \"this\"\nfunction bnBitLength() {\n  if(this.t <= 0) return 0;\n  return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n}\n\n// (protected) r = this << n*DB\nfunction bnpDLShiftTo(n,r) {\n  var i;\n  for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n  for(i = n-1; i >= 0; --i) r[i] = 0;\n  r.t = this.t+n;\n  r.s = this.s;\n}\n\n// (protected) r = this >> n*DB\nfunction bnpDRShiftTo(n,r) {\n  for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n  r.t = Math.max(this.t-n,0);\n  r.s = this.s;\n}\n\n// (protected) r = this << n\nfunction bnpLShiftTo(n,r) {\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<cbs)-1;\n  var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n  for(i = this.t-1; i >= 0; --i) {\n    r[i+ds+1] = (this[i]>>cbs)|c;\n    c = (this[i]&bm)<<bs;\n  }\n  for(i = ds-1; i >= 0; --i) r[i] = 0;\n  r[ds] = c;\n  r.t = this.t+ds+1;\n  r.s = this.s;\n  r.clamp();\n}\n\n// (protected) r = this >> n\nfunction bnpRShiftTo(n,r) {\n  r.s = this.s;\n  var ds = Math.floor(n/this.DB);\n  if(ds >= this.t) { r.t = 0; return; }\n  var bs = n%this.DB;\n  var cbs = this.DB-bs;\n  var bm = (1<<bs)-1;\n  r[0] = this[ds]>>bs;\n  for(var i = ds+1; i < this.t; ++i) {\n    r[i-ds-1] |= (this[i]&bm)<<cbs;\n    r[i-ds] = this[i]>>bs;\n  }\n  if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n  r.t = this.t-ds;\n  r.clamp();\n}\n\n// (protected) r = this - a\nfunction bnpSubTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]-a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c -= a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c -= a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c -= a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c < -1) r[i++] = this.DV+c;\n  else if(c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n}\n\n// (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyTo(a,r) {\n  var x = this.abs(), y = a.abs();\n  var i = x.t;\n  r.t = i+y.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n  r.s = 0;\n  r.clamp();\n  if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n}\n\n// (protected) r = this^2, r != this (HAC 14.16)\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2*x.t;\n  while(--i >= 0) r[i] = 0;\n  for(i = 0; i < x.t-1; ++i) {\n    var c = x.am(i,x[i],r,2*i,0,1);\n    if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n      r[i+x.t] -= x.DV;\n      r[i+x.t+1] = 1;\n    }\n  }\n  if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n  r.s = 0;\n  r.clamp();\n}\n\n// (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\nfunction bnpDivRemTo(m,q,r) {\n  var pm = m.abs();\n  if(pm.t <= 0) return;\n  var pt = this.abs();\n  if(pt.t < pm.t) {\n    if(q != null) q.fromInt(0);\n    if(r != null) this.copyTo(r);\n    return;\n  }\n  if(r == null) r = nbi();\n  var y = nbi(), ts = this.s, ms = m.s;\n  var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n  if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n  else { pm.copyTo(y); pt.copyTo(r); }\n  var ys = y.t;\n  var y0 = y[ys-1];\n  if(y0 == 0) return;\n  var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n  var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n  var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n  y.dlShiftTo(j,t);\n  if(r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t,r);\n  }\n  BigInteger.ONE.dlShiftTo(ys,t);\n  t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n  while(y.t < ys) y[y.t++] = 0;\n  while(--j >= 0) {\n    // Estimate quotient digit\n    var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n    if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n      y.dlShiftTo(j,t);\n      r.subTo(t,r);\n      while(r[i] < --qd) r.subTo(t,r);\n    }\n  }\n  if(q != null) {\n    r.drShiftTo(ys,q);\n    if(ts != ms) BigInteger.ZERO.subTo(q,q);\n  }\n  r.t = ys;\n  r.clamp();\n  if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n  if(ts < 0) BigInteger.ZERO.subTo(r,r);\n}\n\n// (public) this mod a\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a,null,r);\n  if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n  return r;\n}\n\n// Modular reduction using \"classic\" algorithm\nfunction Classic(m) { this.m = m; }\nfunction cConvert(x) {\n  if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n  else return x;\n}\nfunction cRevert(x) { return x; }\nfunction cReduce(x) { x.divRemTo(this.m,null,x); }\nfunction cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\nfunction cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo;\n\n// (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\nfunction bnpInvDigit() {\n  if(this.t < 1) return 0;\n  var x = this[0];\n  if((x&1) == 0) return 0;\n  var y = x&3;       // y == 1/x mod 2^2\n  y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n  y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n  y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n  y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n  return (y>0)?this.DV-y:-y;\n}\n\n// Montgomery reduction\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp&0x7fff;\n  this.mph = this.mp>>15;\n  this.um = (1<<(m.DB-15))-1;\n  this.mt2 = 2*m.t;\n}\n\n// xR mod m\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t,r);\n  r.divRemTo(this.m,null,r);\n  if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n  return r;\n}\n\n// x/R mod m\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n}\n\n// x = x/R mod m (HAC 14.32)\nfunction montReduce(x) {\n  while(x.t <= this.mt2) // pad x so am has enough room later\n    x[x.t++] = 0;\n  for(var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i]&0x7fff;\n    var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n    // use am to combine the multiply-shift-add into one call\n    j = i+this.m.t;\n    x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n    // propagate carry\n    while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n  }\n  x.clamp();\n  x.drShiftTo(this.m.t,x);\n  if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = \"x^2/R mod m\"; x != r\nfunction montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = \"xy/R mod m\"; x,y != r\nfunction montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo;\n\n// (protected) true iff this is even\nfunction bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n// (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\nfunction bnpExp(e,z) {\n  if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n  g.copyTo(r);\n  while(--i >= 0) {\n    z.sqrTo(r,r2);\n    if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n    else { var t = r; r = r2; r2 = t; }\n  }\n  return z.revert(r);\n}\n\n// (public) this^e % m, 0 <= e < 2^32\nfunction bnModPowInt(e,m) {\n  var z;\n  if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n  return this.exp(e,z);\n}\n\n// protected\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp;\n\n// public\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt;\n\n// \"constants\"\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1);\n\n// Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n\n// Extended JavaScript BN functions, required for RSA private ops.\n\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n\n// (public)\nfunction bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n// (public) return value as integer\nfunction bnIntValue() {\n  if(this.s < 0) {\n    if(this.t == 1) return this[0]-this.DV;\n    else if(this.t == 0) return -1;\n  }\n  else if(this.t == 1) return this[0];\n  else if(this.t == 0) return 0;\n  // assumes 16 < DB < 32\n  return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n}\n\n// (public) return value as byte\nfunction bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n// (public) return value as short (assumes DB>=16)\nfunction bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n// (protected) return x s.t. r^x < DV\nfunction bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n// (public) 0 if this == 0, 1 if this > 0\nfunction bnSigNum() {\n  if(this.s < 0) return -1;\n  else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n  else return 1;\n}\n\n// (protected) convert to radix string\nfunction bnpToRadix(b) {\n  if(b == null) b = 10;\n  if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b,cs);\n  var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n  this.divRemTo(d,y,z);\n  while(y.signum() > 0) {\n    r = (a+z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d,y,z);\n  }\n  return z.intValue().toString(b) + r;\n}\n\n// (protected) convert from radix string\nfunction bnpFromRadix(s,b) {\n  this.fromInt(0);\n  if(b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n  for(var i = 0; i < s.length; ++i) {\n    var x = intAt(s,i);\n    if(x < 0) {\n      if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n    w = b*w+x;\n    if(++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w,0);\n      j = 0;\n      w = 0;\n    }\n  }\n  if(j > 0) {\n    this.dMultiply(Math.pow(b,j));\n    this.dAddOffset(w,0);\n  }\n  if(mi) BigInteger.ZERO.subTo(this,this);\n}\n\n// (protected) alternate constructor\nfunction bnpFromNumber(a,b,c) {\n  if(\"number\" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if(a < 2) this.fromInt(1);\n    else {\n      this.fromNumber(a,c);\n      if(!this.testBit(a-1))  // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n      if(this.isEven()) this.dAddOffset(1,0); // force odd\n      while(!this.isProbablePrime(b)) {\n        this.dAddOffset(2,0);\n        if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n      }\n    }\n  }\n  else {\n    // new BigInteger(int,RNG)\n    var x = new Array(), t = a&7;\n    x.length = (a>>3)+1;\n    b.nextBytes(x);\n    if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n    this.fromString(x,256);\n  }\n}\n\n// (public) convert to bigendian byte array\nfunction bnToByteArray() {\n  var i = this.t, r = new Array();\n  r[0] = this.s;\n  var p = this.DB-(i*this.DB)%8, d, k = 0;\n  if(i-- > 0) {\n    if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n      r[k++] = d|(this.s<<(this.DB-p));\n    while(i >= 0) {\n      if(p < 8) {\n        d = (this[i]&((1<<p)-1))<<(8-p);\n        d |= this[--i]>>(p+=this.DB-8);\n      }\n      else {\n        d = (this[i]>>(p-=8))&0xff;\n        if(p <= 0) { p += this.DB; --i; }\n      }\n      if((d&0x80) != 0) d |= -256;\n      if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n      if(k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n  return r;\n}\n\nfunction bnEquals(a) { return(this.compareTo(a)==0); }\nfunction bnMin(a) { return(this.compareTo(a)<0)?this:a; }\nfunction bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n// (protected) r = this op a (bitwise)\nfunction bnpBitwiseTo(a,op,r) {\n  var i, f, m = Math.min(a.t,this.t);\n  for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n  if(a.t < this.t) {\n    f = a.s&this.DM;\n    for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n    r.t = this.t;\n  }\n  else {\n    f = this.s&this.DM;\n    for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n    r.t = a.t;\n  }\n  r.s = op(this.s,a.s);\n  r.clamp();\n}\n\n// (public) this & a\nfunction op_and(x,y) { return x&y; }\nfunction bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n// (public) this | a\nfunction op_or(x,y) { return x|y; }\nfunction bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n// (public) this ^ a\nfunction op_xor(x,y) { return x^y; }\nfunction bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n// (public) this & ~a\nfunction op_andnot(x,y) { return x&~y; }\nfunction bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n// (public) ~this\nfunction bnNot() {\n  var r = nbi();\n  for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n}\n\n// (public) this << n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n  return r;\n}\n\n// (public) this >> n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n  return r;\n}\n\n// return index of lowest 1-bit in x, x < 2^31\nfunction lbit(x) {\n  if(x == 0) return -1;\n  var r = 0;\n  if((x&0xffff) == 0) { x >>= 16; r += 16; }\n  if((x&0xff) == 0) { x >>= 8; r += 8; }\n  if((x&0xf) == 0) { x >>= 4; r += 4; }\n  if((x&3) == 0) { x >>= 2; r += 2; }\n  if((x&1) == 0) ++r;\n  return r;\n}\n\n// (public) returns index of lowest 1-bit (or -1 if none)\nfunction bnGetLowestSetBit() {\n  for(var i = 0; i < this.t; ++i)\n    if(this[i] != 0) return i*this.DB+lbit(this[i]);\n  if(this.s < 0) return this.t*this.DB;\n  return -1;\n}\n\n// return number of 1 bits in x\nfunction cbit(x) {\n  var r = 0;\n  while(x != 0) { x &= x-1; ++r; }\n  return r;\n}\n\n// (public) return number of set bits\nfunction bnBitCount() {\n  var r = 0, x = this.s&this.DM;\n  for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n  return r;\n}\n\n// (public) true iff nth bit is set\nfunction bnTestBit(n) {\n  var j = Math.floor(n/this.DB);\n  if(j >= this.t) return(this.s!=0);\n  return((this[j]&(1<<(n%this.DB)))!=0);\n}\n\n// (protected) this op (1<<n)\nfunction bnpChangeBit(n,op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r,op,r);\n  return r;\n}\n\n// (public) this | (1<<n)\nfunction bnSetBit(n) { return this.changeBit(n,op_or); }\n\n// (public) this & ~(1<<n)\nfunction bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n// (public) this ^ (1<<n)\nfunction bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n// (protected) r = this + a\nfunction bnpAddTo(a,r) {\n  var i = 0, c = 0, m = Math.min(a.t,this.t);\n  while(i < m) {\n    c += this[i]+a[i];\n    r[i++] = c&this.DM;\n    c >>= this.DB;\n  }\n  if(a.t < this.t) {\n    c += a.s;\n    while(i < this.t) {\n      c += this[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += this.s;\n  }\n  else {\n    c += this.s;\n    while(i < a.t) {\n      c += a[i];\n      r[i++] = c&this.DM;\n      c >>= this.DB;\n    }\n    c += a.s;\n  }\n  r.s = (c<0)?-1:0;\n  if(c > 0) r[i++] = c;\n  else if(c < -1) r[i++] = this.DV+c;\n  r.t = i;\n  r.clamp();\n}\n\n// (public) this + a\nfunction bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n// (public) this - a\nfunction bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n// (public) this * a\nfunction bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n// (public) this^2\nfunction bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n// (public) this / a\nfunction bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n// (public) this % a\nfunction bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n// (public) [this/a,this%a]\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(), r = nbi();\n  this.divRemTo(a,q,r);\n  return new Array(q,r);\n}\n\n// (protected) this *= n, this >= 0, 1 < n < DV\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0,n-1,this,0,0,this.t);\n  ++this.t;\n  this.clamp();\n}\n\n// (protected) this += n << w words, this >= 0\nfunction bnpDAddOffset(n,w) {\n  if(n == 0) return;\n  while(this.t <= w) this[this.t++] = 0;\n  this[w] += n;\n  while(this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if(++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n}\n\n// A \"null\" reducer\nfunction NullExp() {}\nfunction nNop(x) { return x; }\nfunction nMulTo(x,y,r) { x.multiplyTo(y,r); }\nfunction nSqrTo(x,r) { x.squareTo(r); }\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo;\n\n// (public) this^e\nfunction bnPow(e) { return this.exp(e,new NullExp()); }\n\n// (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyLowerTo(a,n,r) {\n  var i = Math.min(this.t+a.t,n);\n  r.s = 0; // assumes a,this >= 0\n  r.t = i;\n  while(i > 0) r[--i] = 0;\n  var j;\n  for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n  for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n  r.clamp();\n}\n\n// (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\nfunction bnpMultiplyUpperTo(a,n,r) {\n  --n;\n  var i = r.t = this.t+a.t-n;\n  r.s = 0; // assumes a,this >= 0\n  while(--i >= 0) r[i] = 0;\n  for(i = Math.max(n-this.t,0); i < a.t; ++i)\n    r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n  r.clamp();\n  r.drShiftTo(1,r);\n}\n\n// Barrett modular reduction\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n  else if(x.compareTo(this.m) < 0) return x;\n  else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n}\n\nfunction barrettRevert(x) { return x; }\n\n// x = x mod m (HAC 14.42)\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t-1,this.r2);\n  if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n  this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n  this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n  while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n  x.subTo(this.r2,x);\n  while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n}\n\n// r = x^2 mod m; x != r\nfunction barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n// r = x*y mod m; x,y != r\nfunction barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo;\n\n// (public) this^e % m (HAC 14.85)\nfunction bnModPow(e,m) {\n  var i = e.bitLength(), k, r = nbv(1), z;\n  if(i <= 0) return r;\n  else if(i < 18) k = 1;\n  else if(i < 48) k = 3;\n  else if(i < 144) k = 4;\n  else if(i < 768) k = 5;\n  else k = 6;\n  if(i < 8)\n    z = new Classic(m);\n  else if(m.isEven())\n    z = new Barrett(m);\n  else\n    z = new Montgomery(m);\n\n  // precomputation\n  var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n  g[1] = z.convert(this);\n  if(k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1],g2);\n    while(n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2,g[n-2],g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n  i = nbits(e[j])-1;\n  while(j >= 0) {\n    if(i >= k1) w = (e[j]>>(i-k1))&km;\n    else {\n      w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n      if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n    }\n\n    n = k;\n    while((w&1) == 0) { w >>= 1; --n; }\n    if((i -= n) < 0) { i += this.DB; --j; }\n    if(is1) {  // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    }\n    else {\n      while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n      if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n      z.mulTo(r2,g[w],r);\n    }\n\n    while(j >= 0 && (e[j]&(1<<i)) == 0) {\n      z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n      if(--i < 0) { i = this.DB-1; --j; }\n    }\n  }\n  return z.revert(r);\n}\n\n// (public) gcd(this,a) (HAC 14.54)\nfunction bnGCD(a) {\n  var x = (this.s<0)?this.negate():this.clone();\n  var y = (a.s<0)?a.negate():a.clone();\n  if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n  var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n  if(g < 0) return x;\n  if(i < g) g = i;\n  if(g > 0) {\n    x.rShiftTo(g,x);\n    y.rShiftTo(g,y);\n  }\n  while(x.signum() > 0) {\n    if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n    if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n    if(x.compareTo(y) >= 0) {\n      x.subTo(y,x);\n      x.rShiftTo(1,x);\n    }\n    else {\n      y.subTo(x,y);\n      y.rShiftTo(1,y);\n    }\n  }\n  if(g > 0) y.lShiftTo(g,y);\n  return y;\n}\n\n// (protected) this % n, n < 2^26\nfunction bnpModInt(n) {\n  if(n <= 0) return 0;\n  var d = this.DV%n, r = (this.s<0)?n-1:0;\n  if(this.t > 0)\n    if(d == 0) r = this[0]%n;\n    else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n  return r;\n}\n\n// (public) 1/this % m (HAC 14.61)\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(), v = this.clone();\n  var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n  while(u.signum() != 0) {\n    while(u.isEven()) {\n      u.rShiftTo(1,u);\n      if(ac) {\n        if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n        a.rShiftTo(1,a);\n      }\n      else if(!b.isEven()) b.subTo(m,b);\n      b.rShiftTo(1,b);\n    }\n    while(v.isEven()) {\n      v.rShiftTo(1,v);\n      if(ac) {\n        if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n        c.rShiftTo(1,c);\n      }\n      else if(!d.isEven()) d.subTo(m,d);\n      d.rShiftTo(1,d);\n    }\n    if(u.compareTo(v) >= 0) {\n      u.subTo(v,u);\n      if(ac) a.subTo(c,a);\n      b.subTo(d,b);\n    }\n    else {\n      v.subTo(u,v);\n      if(ac) c.subTo(a,c);\n      d.subTo(b,d);\n    }\n  }\n  if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if(d.compareTo(m) >= 0) return d.subtract(m);\n  if(d.signum() < 0) d.addTo(m,d); else return d;\n  if(d.signum() < 0) return d.add(m); else return d;\n}\n\nvar lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\nvar lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n// (public) test primality with certainty >= 1-.5^t\nfunction bnIsProbablePrime(t) {\n  var i, x = this.abs();\n  if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n    for(i = 0; i < lowprimes.length; ++i)\n      if(x[0] == lowprimes[i]) return true;\n    return false;\n  }\n  if(x.isEven()) return false;\n  i = 1;\n  while(i < lowprimes.length) {\n    var m = lowprimes[i], j = i+1;\n    while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n    m = x.modInt(m);\n    while(i < j) if(m%lowprimes[i++] == 0) return false;\n  }\n  return x.millerRabin(t);\n}\n\n// (protected) true if probably prime (HAC 4.24, Miller-Rabin)\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if(k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = (t+1)>>1;\n  if(t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n  for(var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n    var y = a.modPow(r,this);\n    if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n      while(j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2,this);\n        if(y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n      if(y.compareTo(n1) != 0) return false;\n    }\n  }\n  return true;\n}\n\n// protected\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin;\n\n// public\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n// JSBN-specific extension\nBigInteger.prototype.square = bnSquare;\n\n// Expose the Barrett function\nBigInteger.prototype.Barrett = Barrett\n\n// BigInteger interfaces not implemented in jsbn:\n\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n\nmodule.exports = BigInteger;\n\n","// TODO:\n//    * utilize `crypto.create(Private|Public)Key()` and `keyObject.export()`\n//    * handle multi-line header values (OpenSSH)?\n//    * more thorough validation?\n\nvar crypto = require('crypto');\nvar cryptoSign = crypto.sign;\nvar cryptoVerify = crypto.verify;\nvar createSign = crypto.createSign;\nvar createVerify = crypto.createVerify;\nvar createDecipheriv = crypto.createDecipheriv;\nvar createHash = crypto.createHash;\nvar createHmac = crypto.createHmac;\nvar supportedOpenSSLCiphers = crypto.getCiphers();\n\nvar utils;\nvar Ber = require('asn1').Ber;\nvar bcrypt_pbkdf = require('bcrypt-pbkdf').pbkdf;\n\nvar bufferHelpers = require('./buffer-helpers');\nvar readUInt32BE = bufferHelpers.readUInt32BE;\nvar writeUInt32BE = bufferHelpers.writeUInt32BE;\nvar constants = require('./constants');\nvar SUPPORTED_CIPHER = constants.ALGORITHMS.SUPPORTED_CIPHER;\nvar CIPHER_INFO = constants.CIPHER_INFO;\nvar SSH_TO_OPENSSL = constants.SSH_TO_OPENSSL;\nvar EDDSA_SUPPORTED = constants.EDDSA_SUPPORTED;\n\nvar SYM_HASH_ALGO = Symbol('Hash Algorithm');\nvar SYM_PRIV_PEM = Symbol('Private key PEM');\nvar SYM_PUB_PEM = Symbol('Public key PEM');\nvar SYM_PUB_SSH = Symbol('Public key SSH');\nvar SYM_DECRYPTED = Symbol('Decrypted Key');\n\n// Create OpenSSL cipher name -> SSH cipher name conversion table\nvar CIPHER_INFO_OPENSSL = Object.create(null);\n(function() {\n  var keys = Object.keys(CIPHER_INFO);\n  for (var i = 0; i < keys.length; ++i) {\n    var cipherName = SSH_TO_OPENSSL[keys[i]];\n    if (!cipherName || CIPHER_INFO_OPENSSL[cipherName])\n      continue;\n    CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];\n  }\n})();\n\nvar trimStart = (function() {\n  if (typeof String.prototype.trimStart === 'function') {\n    return function trimStart(str) {\n      return str.trimStart();\n    };\n  }\n\n  return function trimStart(str) {\n    var start = 0;\n    for (var i = 0; i < str.length; ++i) {\n      switch (str.charCodeAt(i)) {\n        case 32: // ' '\n        case 9: // '\\t'\n        case 13: // '\\r'\n        case 10: // '\\n'\n        case 12: // '\\f'\n          ++start;\n          continue;\n      }\n      break;\n    }\n    if (start === 0)\n      return str;\n    return str.slice(start);\n  };\n})();\n\nfunction makePEM(type, data) {\n  data = data.toString('base64');\n  return '-----BEGIN ' + type + ' KEY-----\\n'\n         + data.replace(/.{64}/g, '$&\\n')\n         + (data.length % 64 ? '\\n' : '')\n         + '-----END ' + type + ' KEY-----';\n}\n\nfunction combineBuffers(buf1, buf2) {\n  var result = Buffer.allocUnsafe(buf1.length + buf2.length);\n  buf1.copy(result, 0);\n  buf2.copy(result, buf1.length);\n  return result;\n}\n\nfunction skipFields(buf, nfields) {\n  var bufLen = buf.length;\n  var pos = (buf._pos || 0);\n  for (var i = 0; i < nfields; ++i) {\n    var left = (bufLen - pos);\n    if (pos >= bufLen || left < 4)\n      return false;\n    var len = readUInt32BE(buf, pos);\n    if (left < 4 + len)\n      return false;\n    pos += 4 + len;\n  }\n  buf._pos = pos;\n  return true;\n}\n\nfunction genOpenSSLRSAPub(n, e) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.113549.1.1.1'); // rsaEncryption\n      // algorithm parameters (RSA has none)\n      asnWriter.writeNull();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(n, Ber.Integer);\n        asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHRSAPub(n, e) {\n  var publicKey = Buffer.allocUnsafe(4 + 7 // \"ssh-rsa\"\n                                     + 4 + n.length\n                                     + 4 + e.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.write('ssh-rsa', 4, 7, 'ascii');\n\n  var i = 4 + 7;\n  writeUInt32BE(publicKey, e.length, i);\n  e.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, n.length, i += e.length);\n  n.copy(publicKey, i + 4);\n\n  return publicKey;\n}\n\nvar genOpenSSLRSAPriv = (function() {\n  function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {\n    var asnWriter = new Ber.Writer();\n    asnWriter.startSequence();\n      asnWriter.writeInt(0x00, Ber.Integer);\n      asnWriter.writeBuffer(n, Ber.Integer);\n      asnWriter.writeBuffer(e, Ber.Integer);\n      asnWriter.writeBuffer(d, Ber.Integer);\n      asnWriter.writeBuffer(p, Ber.Integer);\n      asnWriter.writeBuffer(q, Ber.Integer);\n      asnWriter.writeBuffer(dmp1, Ber.Integer);\n      asnWriter.writeBuffer(dmq1, Ber.Integer);\n      asnWriter.writeBuffer(iqmp, Ber.Integer);\n    asnWriter.endSequence();\n    return asnWriter.buffer;\n  }\n\n  function bigIntFromBuffer(buf) {\n    return BigInt('0x' + buf.toString('hex'));\n  }\n\n  function bigIntToBuffer(bn) {\n    var hex = bn.toString(16);\n    if ((hex.length & 1) !== 0) {\n      hex = '0' + hex;\n    } else {\n      var sigbit = hex.charCodeAt(0);\n      // BER/DER integers require leading zero byte to denote a positive value\n      // when first byte >= 0x80\n      if (sigbit === 56 || (sigbit >= 97 && sigbit <= 102))\n        hex = '00' + hex;\n    }\n    return Buffer.from(hex, 'hex');\n  }\n\n  // Feature detect native BigInt availability and use it when possible\n  try {\n    var code = [\n      'return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {',\n      '  var bn_d = bigIntFromBuffer(d);',\n      '  var dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));',\n      '  var dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));',\n      '  return makePEM(\\'RSA PRIVATE\\', '\n        + 'genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));',\n      '};'\n    ].join('\\n');\n    return new Function(\n      'bigIntFromBuffer, bigIntToBuffer, makePEM, genRSAASN1Buf',\n      code\n    )(bigIntFromBuffer, bigIntToBuffer, makePEM, genRSAASN1Buf);\n  } catch (ex) {\n    return (function() {\n      var BigInteger = require('./jsbn.js');\n      return function genOpenSSLRSAPriv(n, e, d, iqmp, p, q) {\n        var pbi = new BigInteger(p, 256);\n        var qbi = new BigInteger(q, 256);\n        var dbi = new BigInteger(d, 256);\n        var dmp1bi = dbi.mod(pbi.subtract(BigInteger.ONE));\n        var dmq1bi = dbi.mod(qbi.subtract(BigInteger.ONE));\n        var dmp1 = Buffer.from(dmp1bi.toByteArray());\n        var dmq1 = Buffer.from(dmq1bi.toByteArray());\n        return makePEM('RSA PRIVATE',\n                       genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));\n      };\n    })();\n  }\n})();\n\nfunction genOpenSSLDSAPub(p, q, g, y) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10040.4.1'); // id-dsa\n      // algorithm parameters\n      asnWriter.startSequence();\n        asnWriter.writeBuffer(p, Ber.Integer);\n        asnWriter.writeBuffer(q, Ber.Integer);\n        asnWriter.writeBuffer(g, Ber.Integer);\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHDSAPub(p, q, g, y) {\n  var publicKey = Buffer.allocUnsafe(4 + 7 // ssh-dss\n                                     + 4 + p.length\n                                     + 4 + q.length\n                                     + 4 + g.length\n                                     + 4 + y.length);\n\n  writeUInt32BE(publicKey, 7, 0);\n  publicKey.write('ssh-dss', 4, 7, 'ascii');\n\n  var i = 4 + 7;\n  writeUInt32BE(publicKey, p.length, i);\n  p.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, q.length, i += p.length);\n  q.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, g.length, i += q.length);\n  g.copy(publicKey, i += 4);\n\n  writeUInt32BE(publicKey, y.length, i += g.length);\n  y.copy(publicKey, i + 4);\n\n  return publicKey;\n}\n\nfunction genOpenSSLDSAPriv(p, q, g, y, x) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    asnWriter.writeInt(0x00, Ber.Integer);\n    asnWriter.writeBuffer(p, Ber.Integer);\n    asnWriter.writeBuffer(q, Ber.Integer);\n    asnWriter.writeBuffer(g, Ber.Integer);\n    asnWriter.writeBuffer(y, Ber.Integer);\n    asnWriter.writeBuffer(x, Ber.Integer);\n  asnWriter.endSequence();\n  return makePEM('DSA PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLEdPub(pub) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(pub.length);\n      pub.copy(asnWriter._buf, asnWriter._offset, 0, pub.length);\n      asnWriter._offset += pub.length;\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHEdPub(pub) {\n  var publicKey = Buffer.allocUnsafe(4 + 11 // ssh-ed25519\n                                     + 4 + pub.length);\n\n  writeUInt32BE(publicKey, 11, 0);\n  publicKey.write('ssh-ed25519', 4, 11, 'ascii');\n\n  writeUInt32BE(publicKey, pub.length, 15);\n  pub.copy(publicKey, 19);\n\n  return publicKey;\n}\n\nfunction genOpenSSLEdPriv(priv) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x00, Ber.Integer);\n\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.3.101.112'); // id-Ed25519\n    asnWriter.endSequence();\n\n    // PrivateKey\n    asnWriter.startSequence(Ber.OctetString);\n      asnWriter.writeBuffer(priv, Ber.OctetString);\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPub(oid, Q) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // algorithm\n    asnWriter.startSequence();\n      asnWriter.writeOID('1.2.840.10045.2.1'); // id-ecPublicKey\n      // algorithm parameters (namedCurve)\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n\n    // subjectPublicKey\n    asnWriter.startSequence(Ber.BitString);\n      asnWriter.writeByte(0x00);\n      // XXX: hack to write a raw buffer without a tag -- yuck\n      asnWriter._ensure(Q.length);\n      Q.copy(asnWriter._buf, asnWriter._offset, 0, Q.length);\n      asnWriter._offset += Q.length;\n      // end hack\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('PUBLIC', asnWriter.buffer);\n}\n\nfunction genOpenSSHECDSAPub(oid, Q) {\n  var curveName;\n  switch (oid) {\n    case '1.2.840.10045.3.1.7':\n      // prime256v1/secp256r1\n      curveName = 'nistp256';\n      break;\n    case '1.3.132.0.34':\n      // secp384r1\n      curveName = 'nistp384';\n      break;\n    case '1.3.132.0.35':\n      // secp521r1\n      curveName = 'nistp521';\n      break;\n    default:\n      return;\n  }\n\n  var publicKey = Buffer.allocUnsafe(4 + 19 // ecdsa-sha2-<curve name>\n                                     + 4 + 8 // <curve name>\n                                     + 4 + Q.length);\n\n  writeUInt32BE(publicKey, 19, 0);\n  publicKey.write('ecdsa-sha2-' + curveName, 4, 19, 'ascii');\n\n  writeUInt32BE(publicKey, 8, 23);\n  publicKey.write(curveName, 27, 8, 'ascii');\n\n  writeUInt32BE(publicKey, Q.length, 35);\n  Q.copy(publicKey, 39);\n\n  return publicKey;\n}\n\nfunction genOpenSSLECDSAPriv(oid, pub, priv) {\n  var asnWriter = new Ber.Writer();\n  asnWriter.startSequence();\n    // version\n    asnWriter.writeInt(0x01, Ber.Integer);\n    // privateKey\n    asnWriter.writeBuffer(priv, Ber.OctetString);\n    // parameters (optional)\n    asnWriter.startSequence(0xA0);\n      asnWriter.writeOID(oid);\n    asnWriter.endSequence();\n    // publicKey (optional)\n    asnWriter.startSequence(0xA1);\n      asnWriter.startSequence(Ber.BitString);\n        asnWriter.writeByte(0x00);\n        // XXX: hack to write a raw buffer without a tag -- yuck\n        asnWriter._ensure(pub.length);\n        pub.copy(asnWriter._buf, asnWriter._offset, 0, pub.length);\n        asnWriter._offset += pub.length;\n        // end hack\n      asnWriter.endSequence();\n    asnWriter.endSequence();\n  asnWriter.endSequence();\n  return makePEM('EC PRIVATE', asnWriter.buffer);\n}\n\nfunction genOpenSSLECDSAPubFromPriv(curveName, priv) {\n  var tempECDH = crypto.createECDH(curveName);\n  tempECDH.setPrivateKey(priv);\n  return tempECDH.getPublicKey();\n}\n\nvar baseKeySign = (function() {\n  if (typeof cryptoSign === 'function') {\n    return function sign(data) {\n      var pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      try {\n        return cryptoSign(this[SYM_HASH_ALGO], data, pem);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  } else {\n    function trySign(signature, privKey) {\n      try {\n        return signature.sign(privKey);\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    return function sign(data) {\n      var pem = this[SYM_PRIV_PEM];\n      if (pem === null)\n        return new Error('No private key available');\n      var signature = createSign(this[SYM_HASH_ALGO]);\n      signature.update(data);\n      return trySign(signature, pem);\n    };\n  }\n})();\n\nvar baseKeyVerify = (function() {\n  if (typeof cryptoVerify === 'function') {\n    return function verify(data, signature) {\n      var pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      try {\n        return cryptoVerify(this[SYM_HASH_ALGO], data, pem, signature);\n      } catch (ex) {\n        return ex;\n      }\n    };\n  } else {\n    function tryVerify(verifier, pubKey, signature) {\n      try {\n        return verifier.verify(pubKey, signature);\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    return function verify(data, signature) {\n      var pem = this[SYM_PUB_PEM];\n      if (pem === null)\n        return new Error('No public key available');\n      var verifier = createVerify(this[SYM_HASH_ALGO]);\n      verifier.update(data);\n      return tryVerify(verifier, pem, signature);\n    };\n  }\n})();\n\nvar BaseKey = {\n  sign: baseKeySign,\n  verify: baseKeyVerify,\n  getPrivatePEM: function getPrivatePEM() {\n    return this[SYM_PRIV_PEM];\n  },\n  getPublicPEM: function getPublicPEM() {\n    return this[SYM_PUB_PEM];\n  },\n  getPublicSSH: function getPublicSSH() {\n    return this[SYM_PUB_SSH];\n  },\n};\n\n\n\nfunction OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Private.prototype = BaseKey;\n(function() {\n  var regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\\r\\n|\\n)([\\s\\S]+)(?:\\r\\n|\\n)-----END OPENSSH PRIVATE KEY-----$/;\n  OpenSSH_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    var ret;\n    var data = Buffer.from(m[1], 'base64');\n    if (data.length < 31) // magic (+ magic null term.) + minimum field lengths\n      return new Error('Malformed OpenSSH private key');\n    var magic = data.toString('ascii', 0, 15);\n    if (magic !== 'openssh-key-v1\\0')\n      return new Error('Unsupported OpenSSH key magic: ' + magic);\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var cipherName = utils.readString(data, 15, 'ascii');\n    if (cipherName === false)\n      return new Error('Malformed OpenSSH private key');\n    if (cipherName !== 'none' && SUPPORTED_CIPHER.indexOf(cipherName) === -1)\n      return new Error('Unsupported cipher for OpenSSH key: ' + cipherName);\n\n    var kdfName = utils.readString(data, data._pos, 'ascii');\n    if (kdfName === false)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfName !== 'none') {\n      if (cipherName === 'none')\n        return new Error('Malformed OpenSSH private key');\n      if (kdfName !== 'bcrypt')\n        return new Error('Unsupported kdf name for OpenSSH key: ' + kdfName);\n      if (!passphrase) {\n        return new Error(\n          'Encrypted private OpenSSH key detected, but no passphrase given'\n        );\n      }\n    } else if (cipherName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    var encInfo;\n    var cipherKey;\n    var cipherIV;\n    if (cipherName !== 'none')\n      encInfo = CIPHER_INFO[cipherName];\n    var kdfOptions = utils.readString(data, data._pos);\n    if (kdfOptions === false)\n      return new Error('Malformed OpenSSH private key');\n    if (kdfOptions.length) {\n      switch (kdfName) {\n        case 'none':\n          return new Error('Malformed OpenSSH private key');\n        case 'bcrypt':\n          /*\n            string salt\n            uint32 rounds\n          */\n          var salt = utils.readString(kdfOptions, 0);\n          if (salt === false || kdfOptions._pos + 4 > kdfOptions.length)\n            return new Error('Malformed OpenSSH private key');\n          var rounds = readUInt32BE(kdfOptions, kdfOptions._pos);\n          var gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);\n          var r = bcrypt_pbkdf(passphrase,\n                               passphrase.length,\n                               salt,\n                               salt.length,\n                               gen,\n                               gen.length,\n                               rounds);\n          if (r !== 0)\n            return new Error('Failed to generate information to decrypt key');\n          cipherKey = gen.slice(0, encInfo.keyLen);\n          cipherIV = gen.slice(encInfo.keyLen);\n          break;\n      }\n    } else if (kdfName !== 'none') {\n      return new Error('Malformed OpenSSH private key');\n    }\n\n    var keyCount = utils.readInt(data, data._pos);\n    if (keyCount === false)\n      return new Error('Malformed OpenSSH private key');\n    data._pos += 4;\n\n    if (keyCount > 0) {\n      // TODO: place sensible limit on max `keyCount`\n\n      // Read public keys first\n      for (var i = 0; i < keyCount; ++i) {\n        var pubData = utils.readString(data, data._pos);\n        if (pubData === false)\n          return new Error('Malformed OpenSSH private key');\n        var type = utils.readString(pubData, 0, 'ascii');\n        if (type === false)\n          return new Error('Malformed OpenSSH private key');\n      }\n\n      var privBlob = utils.readString(data, data._pos);\n      if (privBlob === false)\n        return new Error('Malformed OpenSSH private key');\n\n      if (cipherKey !== undefined) {\n        // encrypted private key(s)\n        if (privBlob.length < encInfo.blockLen\n            || (privBlob.length % encInfo.blockLen) !== 0) {\n          return new Error('Malformed OpenSSH private key');\n        }\n        try {\n          var options = { authTagLength: encInfo.authLen };\n          var decipher = createDecipheriv(SSH_TO_OPENSSL[cipherName],\n                                          cipherKey,\n                                          cipherIV,\n                                          options);\n          if (encInfo.authLen > 0) {\n            if (data.length - data._pos < encInfo.authLen)\n              return new Error('Malformed OpenSSH private key');\n            decipher.setAuthTag(\n              data.slice(data._pos, data._pos += encInfo.authLen)\n            );\n          }\n          privBlob = combineBuffers(decipher.update(privBlob),\n                                    decipher.final());\n        } catch (ex) {\n          return ex;\n        }\n      }\n      // Nothing should we follow the private key(s), except a possible\n      // authentication tag for relevant ciphers\n      if (data._pos !== data.length)\n        return new Error('Malformed OpenSSH private key');\n\n      ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== undefined);\n    } else {\n      ret = [];\n    }\n    return ret;\n  };\n\n  function parseOpenSSHPrivKeys(data, nkeys, decrypted) {\n    var keys = [];\n    /*\n      uint32\tcheckint\n      uint32\tcheckint\n      string\tprivatekey1\n      string\tcomment1\n      string\tprivatekey2\n      string\tcomment2\n      ...\n      string\tprivatekeyN\n      string\tcommentN\n      char\t1\n      char\t2\n      char\t3\n      ...\n      char\tpadlen % 255\n    */\n    if (data.length < 8)\n      return new Error('Malformed OpenSSH private key');\n    var check1 = readUInt32BE(data, 0);\n    var check2 = readUInt32BE(data, 4);\n    if (check1 !== check2) {\n      if (decrypted)\n        return new Error('OpenSSH key integrity check failed -- bad passphrase?');\n      return new Error('OpenSSH key integrity check failed');\n    }\n    data._pos = 8;\n    var i;\n    var oid;\n    for (i = 0; i < nkeys; ++i) {\n      var algo = undefined;\n      var privPEM = undefined;\n      var pubPEM = undefined;\n      var pubSSH = undefined;\n      // The OpenSSH documentation for the key format actually lies, the entirety\n      // of the private key content is not contained with a string field, it's\n      // actually the literal contents of the private key, so to be able to find\n      // the end of the key data you need to know the layout/format of each key\n      // type ...\n      var type = utils.readString(data, data._pos, 'ascii');\n      if (type === false)\n        return new Error('Malformed OpenSSH private key');\n\n      switch (type) {\n        case 'ssh-rsa':\n          /*\n            string  n -- public\n            string  e -- public\n            string  d -- private\n            string  iqmp -- private\n            string  p -- private\n            string  q -- private\n          */\n          var n = utils.readString(data, data._pos);\n          if (n === false)\n            return new Error('Malformed OpenSSH private key');\n          var e = utils.readString(data, data._pos);\n          if (e === false)\n            return new Error('Malformed OpenSSH private key');\n          var d = utils.readString(data, data._pos);\n          if (d === false)\n            return new Error('Malformed OpenSSH private key');\n          var iqmp = utils.readString(data, data._pos);\n          if (iqmp === false)\n            return new Error('Malformed OpenSSH private key');\n          var p = utils.readString(data, data._pos);\n          if (p === false)\n            return new Error('Malformed OpenSSH private key');\n          var q = utils.readString(data, data._pos);\n          if (q === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n          privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n          algo = 'sha1';\n          break;\n        case 'ssh-dss':\n          /*\n            string  p -- public\n            string  q -- public\n            string  g -- public\n            string  y -- public\n            string  x -- private\n          */\n          var p = utils.readString(data, data._pos);\n          if (p === false)\n            return new Error('Malformed OpenSSH private key');\n          var q = utils.readString(data, data._pos);\n          if (q === false)\n            return new Error('Malformed OpenSSH private key');\n          var g = utils.readString(data, data._pos);\n          if (g === false)\n            return new Error('Malformed OpenSSH private key');\n          var y = utils.readString(data, data._pos);\n          if (y === false)\n            return new Error('Malformed OpenSSH private key');\n          var x = utils.readString(data, data._pos);\n          if (x === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n          privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n          algo = 'sha1';\n          break;\n        case 'ssh-ed25519':\n          if (!EDDSA_SUPPORTED)\n            return new Error('Unsupported OpenSSH private key type: ' + type);\n          /*\n            * string  public key\n            * string  private key + public key\n          */\n          var edpub = utils.readString(data, data._pos);\n          if (edpub === false || edpub.length !== 32)\n            return new Error('Malformed OpenSSH private key');\n          var edpriv = utils.readString(data, data._pos);\n          if (edpriv === false || edpriv.length !== 64)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLEdPub(edpub);\n          pubSSH = genOpenSSHEdPub(edpub);\n          privPEM = genOpenSSLEdPriv(edpriv.slice(0, 32));\n          algo = null;\n          break;\n        case 'ecdsa-sha2-nistp256':\n          algo = 'sha256';\n          oid = '1.2.840.10045.3.1.7';\n        case 'ecdsa-sha2-nistp384':\n          if (algo === undefined) {\n            algo = 'sha384';\n            oid = '1.3.132.0.34';\n          }\n        case 'ecdsa-sha2-nistp521':\n          if (algo === undefined) {\n            algo = 'sha512';\n            oid = '1.3.132.0.35';\n          }\n          /*\n            string  curve name\n            string  Q -- public\n            string  d -- private\n          */\n          // TODO: validate curve name against type\n          if (!skipFields(data, 1)) // Skip curve name\n            return new Error('Malformed OpenSSH private key');\n          var ecpub = utils.readString(data, data._pos);\n          if (ecpub === false)\n            return new Error('Malformed OpenSSH private key');\n          var ecpriv = utils.readString(data, data._pos);\n          if (ecpriv === false)\n            return new Error('Malformed OpenSSH private key');\n\n          pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n          pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n          privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);\n          break;\n        default:\n          return new Error('Unsupported OpenSSH private key type: ' + type);\n      }\n\n      var privComment = utils.readString(data, data._pos, 'utf8');\n      if (privComment === false)\n        return new Error('Malformed OpenSSH private key');\n\n      keys.push(\n        new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo,\n                            decrypted)\n      );\n    }\n    var cnt = 0;\n    for (i = data._pos; i < data.length; ++i) {\n      if (data[i] !== (++cnt % 255))\n        return new Error('Malformed OpenSSH private key');\n    }\n\n    return keys;\n  }\n})();\n\n\n\nfunction OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nOpenSSH_Old_Private.prototype = BaseKey;\n(function() {\n  var regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\\r\\n|\\n)((?:[^:]+:\\s*[\\S].*(?:\\r\\n|\\n))*)([\\s\\S]+)(?:\\r\\n|\\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;\n  OpenSSH_Old_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    var privBlob = Buffer.from(m[3], 'base64');\n    var headers = m[2];\n    var decrypted = false;\n    if (headers !== undefined) {\n      // encrypted key\n      headers = headers.split(/\\r\\n|\\n/g);\n      for (var i = 0; i < headers.length; ++i) {\n        var header = headers[i];\n        var sepIdx = header.indexOf(':');\n        if (header.slice(0, sepIdx) === 'DEK-Info') {\n          var val = header.slice(sepIdx + 2);\n          sepIdx = val.indexOf(',');\n          if (sepIdx === -1)\n            continue;\n          var cipherName = val.slice(0, sepIdx).toLowerCase();\n          if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {\n            return new Error(\n              'Cipher ('\n              + cipherName\n              + ') not supported for encrypted OpenSSH private key'\n            );\n          }\n          var encInfo = CIPHER_INFO_OPENSSL[cipherName];\n          if (!encInfo) {\n            return new Error(\n              'Cipher ('\n              + cipherName\n              + ') not supported for encrypted OpenSSH private key'\n            );\n          }\n          var cipherIV = Buffer.from(val.slice(sepIdx + 1), 'hex');\n          if (cipherIV.length !== encInfo.ivLen)\n            return new Error('Malformed encrypted OpenSSH private key');\n          if (!passphrase) {\n            return new Error(\n              'Encrypted OpenSSH private key detected, but no passphrase given'\n            );\n          }\n          var cipherKey = createHash('md5')\n                            .update(passphrase)\n                            .update(cipherIV.slice(0, 8))\n                            .digest();\n          while (cipherKey.length < encInfo.keyLen) {\n            cipherKey = combineBuffers(\n              cipherKey,\n              (createHash('md5')\n                .update(cipherKey)\n                .update(passphrase)\n                .update(cipherIV)\n                .digest()).slice(0, 8)\n            );\n          }\n          if (cipherKey.length > encInfo.keyLen)\n            cipherKey = cipherKey.slice(0, encInfo.keyLen);\n          try {\n            var decipher = createDecipheriv(cipherName, cipherKey, cipherIV);\n            decipher.setAutoPadding(false);\n            privBlob = combineBuffers(decipher.update(privBlob),\n                                      decipher.final());\n            decrypted = true;\n          } catch (ex) {\n            return ex;\n          }\n        }\n      }\n    }\n\n    var type;\n    var privPEM;\n    var pubPEM;\n    var pubSSH;\n    var algo;\n    var reader;\n    var errMsg = 'Malformed OpenSSH private key';\n    if (decrypted)\n      errMsg += '. Bad passphrase?';\n    switch (m[1]) {\n      case 'RSA':\n        type = 'ssh-rsa';\n        privPEM = makePEM('RSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          var n = reader.readString(Ber.Integer, true);\n          if (n === null)\n            return new Error(errMsg);\n          var e = reader.readString(Ber.Integer, true);\n          if (e === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLRSAPub(n, e);\n          pubSSH = genOpenSSHRSAPub(n, e);\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'DSA':\n        type = 'ssh-dss';\n        privPEM = makePEM('DSA PRIVATE', privBlob);\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          var p = reader.readString(Ber.Integer, true);\n          if (p === null)\n            return new Error(errMsg);\n          var q = reader.readString(Ber.Integer, true);\n          if (q === null)\n            return new Error(errMsg);\n          var g = reader.readString(Ber.Integer, true);\n          if (g === null)\n            return new Error(errMsg);\n          var y = reader.readString(Ber.Integer, true);\n          if (y === null)\n            return new Error(errMsg);\n          pubPEM = genOpenSSLDSAPub(p, q, g, y);\n          pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        algo = 'sha1';\n        break;\n      case 'EC':\n        var ecSSLName;\n        var ecPriv;\n        try {\n          reader = new Ber.Reader(privBlob);\n          reader.readSequence();\n          reader.readInt(); // skip version\n          ecPriv = reader.readString(Ber.OctetString, true);\n          reader.readByte(); // Skip \"complex\" context type byte\n          var offset = reader.readLength(); // Skip context length\n          if (offset !== null) {\n            reader._offset = offset;\n            var oid = reader.readOID();\n            if (oid === null)\n              return new Error(errMsg);\n            switch (oid) {\n              case '1.2.840.10045.3.1.7':\n                // prime256v1/secp256r1\n                ecSSLName = 'prime256v1';\n                type = 'ecdsa-sha2-nistp256';\n                algo = 'sha256';\n                break;\n              case '1.3.132.0.34':\n                // secp384r1\n                ecSSLName = 'secp384r1';\n                type = 'ecdsa-sha2-nistp384';\n                algo = 'sha384';\n                break;\n              case '1.3.132.0.35':\n                // secp521r1\n                ecSSLName = 'secp521r1';\n                type = 'ecdsa-sha2-nistp521';\n                algo = 'sha512';\n                break;\n              default:\n                return new Error('Unsupported private key EC OID: ' + oid);\n            }\n          } else {\n            return new Error(errMsg);\n          }\n        } catch (ex) {\n          return new Error(errMsg);\n        }\n        privPEM = makePEM('EC PRIVATE', privBlob);\n        var pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);\n        pubPEM = genOpenSSLECDSAPub(oid, pubBlob);\n        pubSSH = genOpenSSHECDSAPub(oid, pubBlob);\n        break;\n    }\n\n    return new OpenSSH_Old_Private(type, '', privPEM, pubPEM, pubSSH, algo,\n                                   decrypted);\n  };\n})();\n\n\n\nfunction PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = privPEM;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = decrypted;\n}\nPPK_Private.prototype = BaseKey;\n(function() {\n  var EMPTY_PASSPHRASE = Buffer.alloc(0);\n  var PPK_IV = Buffer.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n  var PPK_PP1 = Buffer.from([0, 0, 0, 0]);\n  var PPK_PP2 = Buffer.from([0, 0, 0, 1]);\n  var regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\\r?\\nEncryption: (aes256-cbc|none)\\r?\\nComment: ([^\\r\\n]*)\\r?\\nPublic-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-Lines: \\d+\\r?\\n([\\s\\S]+?)\\r?\\nPrivate-MAC: ([^\\r\\n]+)/;\n  PPK_Private.parse = function(str, passphrase) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = key type\n    // m[2] = encryption type\n    // m[3] = comment\n    // m[4] = base64-encoded public key data:\n    //         for \"ssh-rsa\":\n    //          string \"ssh-rsa\"\n    //          mpint  e    (public exponent)\n    //          mpint  n    (modulus)\n    //         for \"ssh-dss\":\n    //          string \"ssh-dss\"\n    //          mpint p     (modulus)\n    //          mpint q     (prime)\n    //          mpint g     (base number)\n    //          mpint y     (public key parameter: g^x mod p)\n    // m[5] = base64-encoded private key data:\n    //         for \"ssh-rsa\":\n    //          mpint  d    (private exponent)\n    //          mpint  p    (prime 1)\n    //          mpint  q    (prime 2)\n    //          mpint  iqmp ([inverse of q] mod p)\n    //         for \"ssh-dss\":\n    //          mpint x     (private key parameter)\n    // m[6] = SHA1 HMAC over:\n    //          string  name of algorithm (\"ssh-dss\", \"ssh-rsa\")\n    //          string  encryption type\n    //          string  comment\n    //          string  public key data\n    //          string  private-plaintext (including the final padding)\n    var cipherName = m[2];\n    var encrypted = (cipherName !== 'none');\n    if (encrypted && !passphrase) {\n      return new Error(\n        'Encrypted PPK private key detected, but no passphrase given'\n      );\n    }\n\n    var privBlob = Buffer.from(m[5], 'base64');\n\n    if (encrypted) {\n      var encInfo = CIPHER_INFO[cipherName];\n      var cipherKey = combineBuffers(\n        createHash('sha1').update(PPK_PP1).update(passphrase).digest(),\n        createHash('sha1').update(PPK_PP2).update(passphrase).digest()\n      );\n      if (cipherKey.length > encInfo.keyLen)\n        cipherKey = cipherKey.slice(0, encInfo.keyLen);\n      try {\n        var decipher = createDecipheriv(SSH_TO_OPENSSL[cipherName],\n                                        cipherKey,\n                                        PPK_IV);\n        decipher.setAutoPadding(false);\n        privBlob = combineBuffers(decipher.update(privBlob),\n                                  decipher.final());\n        decrypted = true;\n      } catch (ex) {\n        return ex;\n      }\n    }\n\n    var type = m[1];\n    var comment = m[3];\n    var pubBlob = Buffer.from(m[4], 'base64');\n\n    var mac = m[6];\n    var typeLen = type.length;\n    var cipherNameLen = cipherName.length;\n    var commentLen = Buffer.byteLength(comment);\n    var pubLen = pubBlob.length;\n    var privLen = privBlob.length;\n    var macData = Buffer.allocUnsafe(4 + typeLen\n                                     + 4 + cipherNameLen\n                                     + 4 + commentLen\n                                     + 4 + pubLen\n                                     + 4 + privLen);\n    var p = 0;\n\n    writeUInt32BE(macData, typeLen, p);\n    macData.write(type, p += 4, typeLen, 'ascii');\n    writeUInt32BE(macData, cipherNameLen, p += typeLen);\n    macData.write(cipherName, p += 4, cipherNameLen, 'ascii');\n    writeUInt32BE(macData, commentLen, p += cipherNameLen);\n    macData.write(comment, p += 4, commentLen, 'utf8');\n    writeUInt32BE(macData, pubLen, p += commentLen);\n    pubBlob.copy(macData, p += 4);\n    writeUInt32BE(macData, privLen, p += pubLen);\n    privBlob.copy(macData, p + 4);\n\n    if (!passphrase)\n      passphrase = EMPTY_PASSPHRASE;\n\n    var calcMAC = createHmac('sha1',\n                             createHash('sha1')\n                               .update('putty-private-key-file-mac-key')\n                               .update(passphrase)\n                               .digest())\n                    .update(macData)\n                    .digest('hex');\n\n    if (calcMAC !== mac) {\n      if (encrypted) {\n        return new Error(\n          'PPK private key integrity check failed -- bad passphrase?'\n        );\n      } else {\n        return new Error('PPK private key integrity check failed');\n      }\n    }\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var pubPEM;\n    var pubSSH;\n    var privPEM;\n    pubBlob._pos = 0;\n    skipFields(pubBlob, 1); // skip (duplicate) key type\n    switch (type) {\n      case 'ssh-rsa':\n        var e = utils.readString(pubBlob, pubBlob._pos);\n        if (e === false)\n          return new Error('Malformed PPK public key');\n        var n = utils.readString(pubBlob, pubBlob._pos);\n        if (n === false)\n          return new Error('Malformed PPK public key');\n        var d = utils.readString(privBlob, 0);\n        if (d === false)\n          return new Error('Malformed PPK private key');\n        var p = utils.readString(privBlob, privBlob._pos);\n        if (p === false)\n          return new Error('Malformed PPK private key');\n        var q = utils.readString(privBlob, privBlob._pos);\n        if (q === false)\n          return new Error('Malformed PPK private key');\n        var iqmp = utils.readString(privBlob, privBlob._pos);\n        if (iqmp === false)\n          return new Error('Malformed PPK private key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);\n        break;\n      case 'ssh-dss':\n        var p = utils.readString(pubBlob, pubBlob._pos);\n        if (p === false)\n          return new Error('Malformed PPK public key');\n        var q = utils.readString(pubBlob, pubBlob._pos);\n        if (q === false)\n          return new Error('Malformed PPK public key');\n        var g = utils.readString(pubBlob, pubBlob._pos);\n        if (g === false)\n          return new Error('Malformed PPK public key');\n        var y = utils.readString(pubBlob, pubBlob._pos);\n        if (y === false)\n          return new Error('Malformed PPK public key');\n        var x = utils.readString(privBlob, 0);\n        if (x === false)\n          return new Error('Malformed PPK private key');\n\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        privPEM = genOpenSSLDSAPriv(p, q, g, y, x);\n        break;\n    }\n\n    return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, 'sha1',\n                           encrypted);\n  };\n})();\n\n\nfunction parseDER(data, baseType, comment, fullType) {\n  // avoid cyclic require by requiring on first use\n  if (!utils)\n    utils = require('./utils');\n\n  var algo;\n  var pubPEM = null;\n  var pubSSH = null;\n  switch (baseType) {\n    case 'ssh-rsa':\n      var e = utils.readString(data, data._pos);\n      if (e === false)\n        return new Error('Malformed OpenSSH public key');\n      var n = utils.readString(data, data._pos);\n      if (n === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLRSAPub(n, e);\n      pubSSH = genOpenSSHRSAPub(n, e);\n      algo = 'sha1';\n      break;\n    case 'ssh-dss':\n      var p = utils.readString(data, data._pos);\n      if (p === false)\n        return new Error('Malformed OpenSSH public key');\n      var q = utils.readString(data, data._pos);\n      if (q === false)\n        return new Error('Malformed OpenSSH public key');\n      var g = utils.readString(data, data._pos);\n      if (g === false)\n        return new Error('Malformed OpenSSH public key');\n      var y = utils.readString(data, data._pos);\n      if (y === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLDSAPub(p, q, g, y);\n      pubSSH = genOpenSSHDSAPub(p, q, g, y);\n      algo = 'sha1';\n      break;\n    case 'ssh-ed25519':\n      var edpub = utils.readString(data, data._pos);\n      if (edpub === false || edpub.length !== 32)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLEdPub(edpub);\n      pubSSH = genOpenSSHEdPub(edpub);\n      algo = null;\n      break;\n    case 'ecdsa-sha2-nistp256':\n      algo = 'sha256';\n      oid = '1.2.840.10045.3.1.7';\n    case 'ecdsa-sha2-nistp384':\n      if (algo === undefined) {\n        algo = 'sha384';\n        oid = '1.3.132.0.34';\n      }\n    case 'ecdsa-sha2-nistp521':\n      if (algo === undefined) {\n        algo = 'sha512';\n        oid = '1.3.132.0.35';\n      }\n      // TODO: validate curve name against type\n      if (!skipFields(data, 1)) // Skip curve name\n        return new Error('Malformed OpenSSH public key');\n      var ecpub = utils.readString(data, data._pos);\n      if (ecpub === false)\n        return new Error('Malformed OpenSSH public key');\n      pubPEM = genOpenSSLECDSAPub(oid, ecpub);\n      pubSSH = genOpenSSHECDSAPub(oid, ecpub);\n      break;\n    default:\n      return new Error('Unsupported OpenSSH public key type: ' + baseType);\n  }\n\n  return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);\n}\nfunction OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nOpenSSH_Public.prototype = BaseKey;\n(function() {\n  var regexp;\n  if (EDDSA_SUPPORTED)\n    regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  else\n    regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z\\/+=]+)(?:$|\\s+([\\S].*)?)$/;\n  OpenSSH_Public.parse = function(str) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = full type\n    // m[2] = base type\n    // m[3] = base64-encoded public key\n    // m[4] = comment\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var fullType = m[1];\n    var baseType = m[2];\n    var data = Buffer.from(m[3], 'base64');\n    var comment = (m[4] || '');\n\n    var type = utils.readString(data, data._pos, 'ascii');\n    if (type === false || type.indexOf(baseType) !== 0)\n      return new Error('Malformed OpenSSH public key');\n\n    return parseDER(data, baseType, comment, fullType);\n  };\n})();\n\n\n\nfunction RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {\n  this.type = type;\n  this.comment = comment;\n  this[SYM_PRIV_PEM] = null;\n  this[SYM_PUB_PEM] = pubPEM;\n  this[SYM_PUB_SSH] = pubSSH;\n  this[SYM_HASH_ALGO] = algo;\n  this[SYM_DECRYPTED] = false;\n}\nRFC4716_Public.prototype = BaseKey;\n(function() {\n  var regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\\r\\n|\\n)((?:(?:[\\x21-\\x7E]+?):(?:(?:.*?\\\\\\r?\\n)*.*)(?:\\r\\n|\\n))*)((?:[A-Z0-9a-z\\/+=]+(?:\\r\\n|\\n))+)---- END SSH2 PUBLIC KEY ----$/;\n  var RE_HEADER = /^([\\x21-\\x7E]+?):((?:.*?\\\\\\r?\\n)*.*)$/gm;\n  var RE_HEADER_ENDS = /\\\\\\r?\\n/g;\n  RFC4716_Public.parse = function(str) {\n    var m = regexp.exec(str);\n    if (m === null)\n      return null;\n    // m[1] = header(s)\n    // m[2] = base64-encoded public key\n\n    var headers = m[1];\n    var data = Buffer.from(m[2], 'base64');\n    var comment = '';\n\n    if (headers !== undefined) {\n      while (m = RE_HEADER.exec(headers)) {\n        if (m[1].toLowerCase() === 'comment') {\n          comment = trimStart(m[2].replace(RE_HEADER_ENDS, ''));\n          if (comment.length > 1\n              && comment.charCodeAt(0) === 34/*'\"'*/\n              && comment.charCodeAt(comment.length - 1) === 34/*'\"'*/) {\n            comment = comment.slice(1, -1);\n          }\n        }\n      }\n    }\n\n    // avoid cyclic require by requiring on first use\n    if (!utils)\n      utils = require('./utils');\n\n    var type = utils.readString(data, 0, 'ascii');\n    if (type === false)\n      return new Error('Malformed RFC4716 public key');\n\n    var pubPEM = null;\n    var pubSSH = null;\n    switch (type) {\n      case 'ssh-rsa':\n        var e = utils.readString(data, data._pos);\n        if (e === false)\n          return new Error('Malformed RFC4716 public key');\n        var n = utils.readString(data, data._pos);\n        if (n === false)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLRSAPub(n, e);\n        pubSSH = genOpenSSHRSAPub(n, e);\n        break;\n      case 'ssh-dss':\n        var p = utils.readString(data, data._pos);\n        if (p === false)\n          return new Error('Malformed RFC4716 public key');\n        var q = utils.readString(data, data._pos);\n        if (q === false)\n          return new Error('Malformed RFC4716 public key');\n        var g = utils.readString(data, data._pos);\n        if (g === false)\n          return new Error('Malformed RFC4716 public key');\n        var y = utils.readString(data, data._pos);\n        if (y === false)\n          return new Error('Malformed RFC4716 public key');\n        pubPEM = genOpenSSLDSAPub(p, q, g, y);\n        pubSSH = genOpenSSHDSAPub(p, q, g, y);\n        break;\n      default:\n        return new Error('Malformed RFC4716 public key');\n    }\n\n    return new RFC4716_Public(type, comment, pubPEM, pubSSH, 'sha1');\n  };\n})();\n\n\n\nmodule.exports = {\n  parseDERKey: function parseDERKey(data, type) {\n    return parseDER(data, type, '', type);\n  },\n  parseKey: function parseKey(data, passphrase) {\n    if (Buffer.isBuffer(data))\n      data = data.toString('utf8').trim();\n    else if (typeof data !== 'string')\n      return new Error('Key data must be a Buffer or string');\n    else\n      data = data.trim();\n\n    // intentional !=\n    if (passphrase != undefined) {\n      if (typeof passphrase === 'string')\n        passphrase = Buffer.from(passphrase);\n      else if (!Buffer.isBuffer(passphrase))\n        return new Error('Passphrase must be a string or Buffer when supplied');\n    }\n\n    var ret;\n\n    // Private keys\n    if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null)\n      return ret;\n    if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null)\n      return ret;\n    if ((ret = PPK_Private.parse(data, passphrase)) !== null)\n      return ret;\n\n    // Public keys\n    if ((ret = OpenSSH_Public.parse(data)) !== null)\n      return ret;\n    if ((ret = RFC4716_Public.parse(data)) !== null)\n      return ret;\n\n    return new Error('Unsupported key format');\n  }\n}\n","'use strict';\n\nvar inspect = require('util').inspect;\n\nfunction assert(value, message) {\n  if (!value)\n    throw new ERR_INTERNAL_ASSERTION(message);\n}\nassert.fail = function fail(message) {\n  throw new ERR_INTERNAL_ASSERTION(message);\n};\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  var res = '';\n  var i = val.length;\n  var start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3)\n    res = `_${val.slice(i - 3, i)}${res}`;\n  return `${val.slice(0, i)}${res}`;\n}\n\nfunction oneOf(expected, thing) {\n  assert(typeof thing === 'string', '`thing` has to be of type string');\n  if (Array.isArray(expected)) {\n    var len = expected.length;\n    assert(len > 0, 'At least one expected value needs to be specified');\n    expected = expected.map((i) => String(i));\n    if (len > 2) {\n      return `one of ${thing} ${expected.slice(0, len - 1).join(', ')}, or `\n              + expected[len - 1];\n    } else if (len === 2) {\n      return `one of ${thing} ${expected[0]} or ${expected[1]}`;\n    } else {\n      return `of ${thing} ${expected[0]}`;\n    }\n  } else {\n    return `of ${thing} ${String(expected)}`;\n  }\n}\n\n\n\nexports.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {\n  constructor(message) {\n    super();\n    Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);\n\n    var suffix = 'This is caused by either a bug in ssh2-streams '\n                 + 'or incorrect usage of ssh2-streams internals.\\n'\n                 + 'Please open an issue with this stack trace at '\n                 + 'https://github.com/mscdex/ssh2-streams/issues\\n';\n\n    this.message = (message === undefined ? suffix : `${message}\\n${suffix}`);\n  }\n};\n\nvar MAX_32BIT_INT = Math.pow(2, 32);\nvar MAX_32BIT_BIGINT = (function() {\n  try {\n    return new Function('return 2n ** 32n')();\n  } catch (ex) {}\n})();\nexports.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {\n  constructor(str, range, input, replaceDefaultBoolean) {\n    super();\n    Error.captureStackTrace(this, ERR_OUT_OF_RANGE);\n\n    assert(range, 'Missing \"range\" argument');\n    var msg = (replaceDefaultBoolean\n               ? str\n               : `The value of \"${str}\" is out of range.`);\n    var received;\n    if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT)\n        received = addNumericalSeparator(received);\n      received += 'n';\n    } else {\n      received = inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n\n    this.message = msg;\n  }\n};\n\nexports.ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE extends TypeError {\n  constructor(name, expected, actual) {\n    super();\n    Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE);\n\n    assert(typeof name === 'string', `'name' must be a string`);\n\n    // determiner: 'must be' or 'must not be'\n    var determiner;\n    if (typeof expected === 'string' && expected.startsWith('not ')) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n\n    var msg;\n    if (name.endsWith(' argument')) {\n      // For cases like 'first argument'\n      msg = `The ${name} ${determiner} ${oneOf(expected, 'type')}`;\n    } else {\n      var type = (name.includes('.') ? 'property' : 'argument');\n      msg = `The \"${name}\" ${type} ${determiner} ${oneOf(expected, 'type')}`;\n    }\n\n    msg += `. Received type ${typeof actual}`;\n\n    this.message = msg;\n  }\n};\n\nexports.validateNumber = function validateNumber(value, name) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name, 'number', value);\n};\n\n\n// =============================================================================\n// Following code is only needed to support node v6.x ....\n\n// Undocumented cb() API, needed for core, not for public API\nexports.destroyImpl = function destroy(err, cb) {\n  const readableDestroyed = this._readableState &&\n    this._readableState.destroyed;\n  const writableDestroyed = this._writableState &&\n    this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorNT, this, err);\n      }\n    }\n\n    return this;\n  }\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // If this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, (err) => {\n    if (!cb && err) {\n      if (!this._writableState) {\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else if (!this._writableState.errorEmitted) {\n        this._writableState.errorEmitted = true;\n        process.nextTick(emitErrorAndCloseNT, this, err);\n      } else {\n        process.nextTick(emitCloseNT, this);\n      }\n    } else if (cb) {\n      process.nextTick(emitCloseNT, this);\n      cb(err);\n    } else {\n      process.nextTick(emitCloseNT, this);\n    }\n  });\n\n  return this;\n};\n\nfunction emitErrorAndCloseNT(self, err) {\n  emitErrorNT(self, err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  if (self._writableState && !self._writableState.emitClose)\n    return;\n  if (self._readableState && !self._readableState.emitClose)\n    return;\n  self.emit('close');\n}\n// =============================================================================\n","// TODO: support EXTENDED request packets\n\nvar TransformStream = require('stream').Transform;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\nvar constants = require('fs').constants || process.binding('constants');\nvar util = require('util');\nvar inherits = util.inherits;\nvar isDate = util.isDate;\nvar listenerCount = require('events').EventEmitter.listenerCount;\nvar fs = require('fs');\n\nvar readString = require('./utils').readString;\nvar readInt = require('./utils').readInt;\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\nvar ATTR = {\n  SIZE: 0x00000001,\n  UIDGID: 0x00000002,\n  PERMISSIONS: 0x00000004,\n  ACMODTIME: 0x00000008,\n  EXTENDED: 0x80000000\n};\n\nvar STATUS_CODE = {\n  OK: 0,\n  EOF: 1,\n  NO_SUCH_FILE: 2,\n  PERMISSION_DENIED: 3,\n  FAILURE: 4,\n  BAD_MESSAGE: 5,\n  NO_CONNECTION: 6,\n  CONNECTION_LOST: 7,\n  OP_UNSUPPORTED: 8\n};\nObject.keys(STATUS_CODE).forEach(function(key) {\n  STATUS_CODE[STATUS_CODE[key]] = key;\n});\nvar STATUS_CODE_STR = {\n  0: 'No error',\n  1: 'End of file',\n  2: 'No such file or directory',\n  3: 'Permission denied',\n  4: 'Failure',\n  5: 'Bad message',\n  6: 'No connection',\n  7: 'Connection lost',\n  8: 'Operation unsupported'\n};\nSFTPStream.STATUS_CODE = STATUS_CODE;\n\nvar REQUEST = {\n  INIT: 1,\n  OPEN: 3,\n  CLOSE: 4,\n  READ: 5,\n  WRITE: 6,\n  LSTAT: 7,\n  FSTAT: 8,\n  SETSTAT: 9,\n  FSETSTAT: 10,\n  OPENDIR: 11,\n  READDIR: 12,\n  REMOVE: 13,\n  MKDIR: 14,\n  RMDIR: 15,\n  REALPATH: 16,\n  STAT: 17,\n  RENAME: 18,\n  READLINK: 19,\n  SYMLINK: 20,\n  EXTENDED: 200\n};\nObject.keys(REQUEST).forEach(function(key) {\n  REQUEST[REQUEST[key]] = key;\n});\n\nvar RESPONSE = {\n  VERSION: 2,\n  STATUS: 101,\n  HANDLE: 102,\n  DATA: 103,\n  NAME: 104,\n  ATTRS: 105,\n  EXTENDED: 201\n};\nObject.keys(RESPONSE).forEach(function(key) {\n  RESPONSE[RESPONSE[key]] = key;\n});\n\nvar OPEN_MODE = {\n  READ: 0x00000001,\n  WRITE: 0x00000002,\n  APPEND: 0x00000004,\n  CREAT: 0x00000008,\n  TRUNC: 0x00000010,\n  EXCL: 0x00000020\n};\nSFTPStream.OPEN_MODE = OPEN_MODE;\n\nvar MAX_PKT_LEN = 34000;\nvar MAX_REQID = Math.pow(2, 32) - 1;\nvar CLIENT_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */,\n                                         REQUEST.INIT,\n                                         0, 0, 0, 3 /* version */]);\nvar SERVER_VERSION_BUFFER = Buffer.from([0, 0, 0, 5 /* length */,\n                                         RESPONSE.VERSION,\n                                         0, 0, 0, 3 /* version */]);\n/*\n  http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02:\n\n     The maximum size of a packet is in practice determined by the client\n     (the maximum size of read or write requests that it sends, plus a few\n     bytes of packet overhead).  All servers SHOULD support packets of at\n     least 34000 bytes (where the packet size refers to the full length,\n     including the header above).  This should allow for reads and writes\n     of at most 32768 bytes.\n\n  OpenSSH caps this to 256kb instead of the ~34kb as mentioned in the sftpv3\n  spec.\n*/\nvar RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;\nvar OPENSSH_MAX_DATA_LEN = (256 * 1024) - (2 * 1024)/*account for header data*/;\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SFTPStream(cfg, remoteIdentRaw) {\n  if (typeof cfg === 'string' && !remoteIdentRaw) {\n    remoteIdentRaw = cfg;\n    cfg = undefined;\n  }\n  if (typeof cfg !== 'object' || !cfg)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server ? true : false);\n  this._isOpenSSH = (remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw));\n  this._needContinue = false;\n  this._state = {\n    // common\n    status: 'packet_header',\n    writeReqid: -1,\n    pktLeft: undefined,\n    pktHdrBuf: Buffer.allocUnsafe(9), // room for pktLen + pktType + req id\n    pktBuf: undefined,\n    pktType: undefined,\n    version: undefined,\n    extensions: {},\n\n    // client\n    maxDataLen: (this._isOpenSSH ? OPENSSH_MAX_DATA_LEN : 32768),\n    requests: {}\n  };\n\n  var self = this;\n  this.on('end', function() {\n    self.readable = false;\n  }).on('finish', onFinish)\n    .on('prefinish', onFinish);\n  function onFinish() {\n    self.writable = false;\n    self._cleanup(false);\n  }\n\n  if (!this.server)\n    this.push(CLIENT_VERSION_BUFFER);\n}\ninherits(SFTPStream, TransformStream);\n\nSFTPStream.prototype.__read = TransformStream.prototype._read;\nSFTPStream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSFTPStream.prototype.__push = TransformStream.prototype.push;\nSFTPStream.prototype.push = function(chunk, encoding) {\n  if (!this.readable)\n    return false;\n  if (chunk === null)\n    this.readable = false;\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSFTPStream.prototype._cleanup = function(callback) {\n  var state = this._state;\n\n  state.pktBuf = undefined; // give GC something to do\n\n  var requests = state.requests;\n  var keys = Object.keys(requests);\n  var len = keys.length;\n  if (len) {\n    if (this.readable) {\n      var err = new Error('SFTP session ended early');\n      for (var i = 0, cb; i < len; ++i)\n        (cb = requests[keys[i]].cb) && cb(err);\n    }\n    state.requests = {};\n  }\n\n  if (this.readable)\n    this.push(null);\n  if (!this._readableState.endEmitted && !this._readableState.flowing) {\n    // Ugh!\n    this.resume();\n  }\n  if (callback !== false) {\n    this.debug('DEBUG[SFTP]: Parser: Malformed packet');\n    callback && callback(new Error('Malformed packet'));\n  }\n};\n\nSFTPStream.prototype._transform = function(chunk, encoding, callback) {\n  var state = this._state;\n  var server = this.server;\n  var status = state.status;\n  var pktType = state.pktType;\n  var pktBuf = state.pktBuf;\n  var pktLeft = state.pktLeft;\n  var version = state.version;\n  var pktHdrBuf = state.pktHdrBuf;\n  var requests = state.requests;\n  var debug = this.debug;\n  var chunkLen = chunk.length;\n  var chunkPos = 0;\n  var buffer;\n  var chunkLeft;\n  var id;\n\n  while (true) {\n    if (status === 'discard') {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        status = 'packet_header';\n        buffer = pktBuf = undefined;\n      } else {\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (pktBuf !== undefined) {\n      chunkLeft = (chunkLen - chunkPos);\n      if (pktLeft <= chunkLeft) {\n        chunk.copy(pktBuf,\n                   pktBuf.length - pktLeft,\n                   chunkPos,\n                   chunkPos + pktLeft);\n        chunkPos += pktLeft;\n        pktLeft = 0;\n        buffer = pktBuf;\n        pktBuf = undefined;\n        continue;\n      } else {\n        chunk.copy(pktBuf, pktBuf.length - pktLeft, chunkPos);\n        pktLeft -= chunkLeft;\n        break;\n      }\n    } else if (status === 'packet_header') {\n      if (!buffer) {\n        pktLeft = 5;\n        pktBuf = pktHdrBuf;\n      } else {\n        // here we read the right-most 5 bytes from buffer (pktHdrBuf)\n        pktLeft = readUInt32BE(buffer, 4) - 1; // account for type byte\n        pktType = buffer[8];\n\n        if (server) {\n          if (version === undefined && pktType !== REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected packet before init');\n            this._cleanup(false);\n            return callback(new Error('Unexpected packet before init'));\n          } else if (version !== undefined && pktType === REQUEST.INIT) {\n            debug('DEBUG[SFTP]: Parser: Unexpected duplicate init');\n            status = 'bad_pkt';\n          } else if (pktLeft > MAX_PKT_LEN) {\n            var msg = 'Packet length ('\n                      + pktLeft\n                      + ') exceeds max length ('\n                      + MAX_PKT_LEN\n                      + ')';\n            debug('DEBUG[SFTP]: Parser: ' + msg);\n            this._cleanup(false);\n            return callback(new Error(msg));\n          } else if (pktType === REQUEST.EXTENDED) {\n            status = 'bad_pkt';\n          } else if (REQUEST[pktType] === undefined) {\n            debug('DEBUG[SFTP]: Parser: Unsupported packet type: ' + pktType);\n            status = 'discard';\n          }\n        } else if (version === undefined && pktType !== RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected packet before version');\n          this._cleanup(false);\n          return callback(new Error('Unexpected packet before version'));\n        } else if (version !== undefined && pktType === RESPONSE.VERSION) {\n          debug('DEBUG[SFTP]: Parser: Unexpected duplicate version');\n          status = 'bad_pkt';\n        } else if (RESPONSE[pktType] === undefined) {\n          status = 'discard';\n        }\n\n        if (status === 'bad_pkt') {\n          // Copy original packet info to left of pktHdrBuf\n          writeUInt32BE(pktHdrBuf, pktLeft + 1, 0);\n          pktHdrBuf[4] = pktType;\n\n          pktLeft = 4;\n          pktBuf = pktHdrBuf;\n        } else {\n          pktBuf = Buffer.allocUnsafe(pktLeft);\n          status = 'payload';\n        }\n      }\n    } else if (status === 'payload') {\n      if (pktType === RESPONSE.VERSION || pktType === REQUEST.INIT) {\n        /*\n          uint32 version\n          <extension data>\n        */\n        version = state.version = readInt(buffer, 0, this, callback);\n        if (version === false)\n          return;\n        if (version < 3) {\n          this._cleanup(false);\n          return callback(new Error('Incompatible SFTP version: ' + version));\n        } else if (server)\n          this.push(SERVER_VERSION_BUFFER);\n\n        var buflen = buffer.length;\n        var extname;\n        var extdata;\n        buffer._pos = 4;\n        while (buffer._pos < buflen) {\n          extname = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extname === false)\n            return;\n          extdata = readString(buffer, buffer._pos, 'ascii', this, callback);\n          if (extdata === false)\n            return;\n          if (state.extensions[extname])\n            state.extensions[extname].push(extdata);\n          else\n            state.extensions[extname] = [ extdata ];\n        }\n\n        this.emit('ready');\n      } else {\n        /*\n          All other packets (client and server) begin with a (client) request\n          id:\n          uint32     id\n        */\n        id = readInt(buffer, 0, this, callback);\n        if (id === false)\n          return;\n\n        var filename;\n        var attrs;\n        var handle;\n        var data;\n\n        if (!server) {\n          var req = requests[id];\n          var cb = req && req.cb;\n          debug('DEBUG[SFTP]: Parser: Response: ' + RESPONSE[pktType]);\n          if (req && cb) {\n            if (pktType === RESPONSE.STATUS) {\n              /*\n                uint32     error/status code\n                string     error message (ISO-10646 UTF-8)\n                string     language tag\n              */\n              var code = readInt(buffer, 4, this, callback);\n              if (code === false)\n                return;\n              if (code === STATUS_CODE.OK) {\n                cb();\n              } else {\n                // We borrow OpenSSH behavior here, specifically we make the\n                // message and language fields optional, despite the\n                // specification requiring them (even if they are empty). This\n                // helps to avoid problems with buggy implementations that do\n                // not fully conform to the SFTP(v3) specification.\n                var msg;\n                var lang = '';\n                if (buffer.length >= 12) {\n                  msg = readString(buffer, 8, 'utf8', this, callback);\n                  if (msg === false)\n                    return;\n                  if ((buffer._pos + 4) < buffer.length) {\n                    lang = readString(buffer,\n                                      buffer._pos,\n                                      'ascii',\n                                      this,\n                                      callback);\n                    if (lang === false)\n                      return;\n                  }\n                }\n                var err = new Error(msg\n                                    || STATUS_CODE_STR[code]\n                                    || 'Unknown status');\n                err.code = code;\n                err.lang = lang;\n                cb(err);\n              }\n            } else if (pktType === RESPONSE.HANDLE) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              cb(undefined, handle);\n            } else if (pktType === RESPONSE.DATA) {\n              /*\n                string     data\n              */\n              if (req.buffer) {\n                // we have already pre-allocated space to store the data\n                var dataLen = readInt(buffer, 4, this, callback);\n                if (dataLen === false)\n                  return;\n                var reqBufLen = req.buffer.length;\n                if (dataLen > reqBufLen) {\n                  // truncate response data to fit expected size\n                  writeUInt32BE(buffer, reqBufLen, 4);\n                }\n                data = readString(buffer, 4, req.buffer, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data, dataLen);\n              } else {\n                data = readString(buffer, 4, this, callback);\n                if (data === false)\n                  return;\n                cb(undefined, data);\n              }\n            } else if (pktType === RESPONSE.NAME) {\n              /*\n                uint32     count\n                repeats count times:\n                        string     filename\n                        string     longname\n                        ATTRS      attrs\n              */\n              var namesLen = readInt(buffer, 4, this, callback);\n              if (namesLen === false)\n                return;\n              var names = [],\n                  longname;\n              buffer._pos = 8;\n              for (var i = 0; i < namesLen; ++i) {\n                // we are going to assume UTF-8 for filenames despite the SFTPv3\n                // spec not specifying an encoding because the specs for newer\n                // versions of the protocol all explicitly specify UTF-8 for\n                // filenames\n                filename = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (filename === false)\n                  return;\n                // `longname` only exists in SFTPv3 and since it typically will\n                // contain the filename, we assume it is also UTF-8\n                longname = readString(buffer,\n                                      buffer._pos,\n                                      'utf8',\n                                      this,\n                                      callback);\n                if (longname === false)\n                  return;\n                attrs = readAttrs(buffer, buffer._pos, this, callback);\n                if (attrs === false)\n                  return;\n                names.push({\n                  filename: filename,\n                  longname: longname,\n                  attrs: attrs\n                });\n              }\n              cb(undefined, names);\n            } else if (pktType === RESPONSE.ATTRS) {\n              /*\n                ATTRS      attrs\n              */\n              attrs = readAttrs(buffer, 4, this, callback);\n              if (attrs === false)\n                return;\n              cb(undefined, attrs);\n            } else if (pktType === RESPONSE.EXTENDED) {\n              if (req.extended) {\n                switch (req.extended) {\n                  case 'statvfs@openssh.com':\n                  case 'fstatvfs@openssh.com':\n                    /*\n                      uint64    f_bsize   // file system block size\n                      uint64    f_frsize  // fundamental fs block size\n                      uint64    f_blocks  // number of blocks (unit f_frsize)\n                      uint64    f_bfree   // free blocks in file system\n                      uint64    f_bavail  // free blocks for non-root\n                      uint64    f_files   // total file inodes\n                      uint64    f_ffree   // free file inodes\n                      uint64    f_favail  // free file inodes for to non-root\n                      uint64    f_fsid    // file system id\n                      uint64    f_flag    // bit mask of f_flag values\n                      uint64    f_namemax // maximum filename length\n                    */\n                    var stats = {\n                      f_bsize: undefined,\n                      f_frsize: undefined,\n                      f_blocks: undefined,\n                      f_bfree: undefined,\n                      f_bavail: undefined,\n                      f_files: undefined,\n                      f_ffree: undefined,\n                      f_favail: undefined,\n                      f_sid: undefined,\n                      f_flag: undefined,\n                      f_namemax: undefined\n                    };\n                    stats.f_bsize = readUInt64BE(buffer, 4, this, callback);\n                    if (stats.f_bsize === false)\n                      return;\n                    stats.f_frsize = readUInt64BE(buffer, 12, this, callback);\n                    if (stats.f_frsize === false)\n                      return;\n                    stats.f_blocks = readUInt64BE(buffer, 20, this, callback);\n                    if (stats.f_blocks === false)\n                      return;\n                    stats.f_bfree = readUInt64BE(buffer, 28, this, callback);\n                    if (stats.f_bfree === false)\n                      return;\n                    stats.f_bavail = readUInt64BE(buffer, 36, this, callback);\n                    if (stats.f_bavail === false)\n                      return;\n                    stats.f_files = readUInt64BE(buffer, 44, this, callback);\n                    if (stats.f_files === false)\n                      return;\n                    stats.f_ffree = readUInt64BE(buffer, 52, this, callback);\n                    if (stats.f_ffree === false)\n                      return;\n                    stats.f_favail = readUInt64BE(buffer, 60, this, callback);\n                    if (stats.f_favail === false)\n                      return;\n                    stats.f_sid = readUInt64BE(buffer, 68, this, callback);\n                    if (stats.f_sid === false)\n                      return;\n                    stats.f_flag = readUInt64BE(buffer, 76, this, callback);\n                    if (stats.f_flag === false)\n                      return;\n                    stats.f_namemax = readUInt64BE(buffer, 84, this, callback);\n                    if (stats.f_namemax === false)\n                      return;\n                    cb(undefined, stats);\n                  break;\n                }\n              }\n              // XXX: at least provide the raw buffer data to the callback in\n              // case of unexpected extended response?\n              cb();\n            }\n          }\n          if (req)\n            delete requests[id];\n        } else {\n          // server\n          var evName = REQUEST[pktType];\n          var offset;\n          var path;\n\n          debug('DEBUG[SFTP]: Parser: Request: ' + evName);\n          if (listenerCount(this, evName)) {\n            if (pktType === REQUEST.OPEN) {\n              /*\n                string        filename\n                uint32        pflags\n                ATTRS         attrs\n              */\n              filename = readString(buffer, 4, 'utf8', this, callback);\n              if (filename === false)\n                return;\n              var pflags = readInt(buffer, buffer._pos, this, callback);\n              if (pflags === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos + 4, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, filename, pflags, attrs);\n            } else if (pktType === REQUEST.CLOSE\n                       || pktType === REQUEST.FSTAT\n                       || pktType === REQUEST.READDIR) {\n              /*\n                string     handle\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              this.emit(evName, id, handle);\n            } else if (pktType === REQUEST.READ) {\n              /*\n                string     handle\n                uint64     offset\n                uint32     len\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              var len = readInt(buffer, buffer._pos, this, callback);\n              if (len === false)\n                return;\n              this.emit(evName, id, handle, offset, len);\n            } else if (pktType === REQUEST.WRITE) {\n              /*\n                string     handle\n                uint64     offset\n                string     data\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              offset = readUInt64BE(buffer, buffer._pos, this, callback);\n              if (offset === false)\n                return;\n              data = readString(buffer, buffer._pos, this, callback);\n              if (data === false)\n                return;\n              this.emit(evName, id, handle, offset, data);\n            } else if (pktType === REQUEST.LSTAT\n                       || pktType === REQUEST.STAT\n                       || pktType === REQUEST.OPENDIR\n                       || pktType === REQUEST.REMOVE\n                       || pktType === REQUEST.RMDIR\n                       || pktType === REQUEST.REALPATH\n                       || pktType === REQUEST.READLINK) {\n              /*\n                string     path\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              this.emit(evName, id, path);\n            } else if (pktType === REQUEST.SETSTAT\n                       || pktType === REQUEST.MKDIR) {\n              /*\n                string     path\n                ATTRS      attrs\n              */\n              path = readString(buffer, 4, 'utf8', this, callback);\n              if (path === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, path, attrs);\n            } else if (pktType === REQUEST.FSETSTAT) {\n              /*\n                string     handle\n                ATTRS      attrs\n              */\n              handle = readString(buffer, 4, this, callback);\n              if (handle === false)\n                return;\n              attrs = readAttrs(buffer, buffer._pos, this, callback);\n              if (attrs === false)\n                return;\n              this.emit(evName, id, handle, attrs);\n            } else if (pktType === REQUEST.RENAME\n                       || pktType === REQUEST.SYMLINK) {\n              /*\n                RENAME:\n                  string     oldpath\n                  string     newpath\n                SYMLINK:\n                  string     linkpath\n                  string     targetpath\n              */\n              var str1;\n              var str2;\n              str1 = readString(buffer, 4, 'utf8', this, callback);\n              if (str1 === false)\n                return;\n              str2 = readString(buffer, buffer._pos, 'utf8', this, callback);\n              if (str2 === false)\n                return;\n              if (pktType === REQUEST.SYMLINK && this._isOpenSSH) {\n                // OpenSSH has linkpath and targetpath positions switched\n                this.emit(evName, id, str2, str1);\n              } else\n                this.emit(evName, id, str1, str2);\n            }\n          } else {\n            // automatically reject request if no handler for request type\n            this.status(id, STATUS_CODE.OP_UNSUPPORTED);\n          }\n        }\n      }\n\n      // prepare for next packet\n      status = 'packet_header';\n      buffer = pktBuf = undefined;\n    } else if (status === 'bad_pkt') {\n      if (server && buffer[4] !== REQUEST.INIT) {\n        var errCode = (buffer[4] === REQUEST.EXTENDED\n                       ? STATUS_CODE.OP_UNSUPPORTED\n                       : STATUS_CODE.FAILURE);\n\n        // no request id for init/version packets, so we have no way to send a\n        // status response, so we just close up shop ...\n        if (buffer[4] === REQUEST.INIT || buffer[4] === RESPONSE.VERSION)\n          return this._cleanup(callback);\n\n        id = readInt(buffer, 5, this, callback);\n        if (id === false)\n          return;\n        this.status(id, errCode);\n      }\n\n      // by this point we have already read the type byte and the id bytes, so\n      // we subtract those from the number of bytes to skip\n      pktLeft = readUInt32BE(buffer, 0) - 5;\n\n      status = 'discard';\n    }\n\n    if (chunkPos >= chunkLen)\n      break;\n  }\n\n  state.status = status;\n  state.pktType = pktType;\n  state.pktBuf = pktBuf;\n  state.pktLeft = pktLeft;\n  state.version = version;\n\n  callback();\n};\n\n// client\nSFTPStream.prototype.createReadStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new ReadStream(this, path, options);\n};\nSFTPStream.prototype.createWriteStream = function(path, options) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  return new WriteStream(this, path, options);\n};\nSFTPStream.prototype.open = function(path, flags_, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n\n  var flags = (typeof flags_ === 'number' ? flags_ : stringToFlags(flags_));\n  if (flags === null)\n    throw new Error('Unknown flags string: ' + flags_);\n\n  var attrFlags = 0;\n  var attrBytes = 0;\n  if (typeof attrs === 'string' || typeof attrs === 'number') {\n    attrs = { mode: attrs };\n  }\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    attrFlags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32        id\n    string        filename\n    uint32        pflags\n    ATTRS         attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.OPEN;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  writeUInt32BE(buf, attrFlags, p += 4);\n  if (attrs && attrFlags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPEN');\n  return this.push(buf);\n};\nSFTPStream.prototype.close = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.CLOSE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing CLOSE');\n  return this.push(buf);\n};\nSFTPStream.prototype.readData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off >= buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    uint32     len\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var pos = position;\n  var out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 8 + 4);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.READ;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handlelen, p);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = pos & 0xFF;\n    pos /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n\n  state.requests[reqid] = {\n    cb: function(err, data, nb) {\n      if (err) {\n        if (cb._wantEOFError || err.code !== STATUS_CODE.EOF)\n          return cb(err);\n      } else if (nb > len) {\n        return cb(new Error('Received more data than requested'));\n      }\n      cb(undefined, nb || 0, data, position);\n    },\n    buffer: buf.slice(off, off + len)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READ');\n  return this.push(out);\n};\nSFTPStream.prototype.writeData = function(handle, buf, off, len, position, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n  else if (!Buffer.isBuffer(buf))\n    throw new Error('buffer is not a Buffer');\n  else if (off > buf.length)\n    throw new Error('offset is out of bounds');\n  else if (off + len > buf.length)\n    throw new Error('length extends beyond buffer');\n  else if (position === null)\n    throw new Error('null position currently unsupported');\n\n  var self = this;\n  var state = this._state;\n\n  if (!len) {\n    cb && process.nextTick(function() { cb(undefined, 0); });\n    return;\n  }\n\n  var overflow = (len > state.maxDataLen\n                  ? len - state.maxDataLen\n                  : 0);\n  var origPosition = position;\n\n  if (overflow)\n    len = state.maxDataLen;\n\n  /*\n    uint32     id\n    string     handle\n    uint64     offset\n    string     data\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 8 + 4 + len);\n\n  writeUInt32BE(out, out.length - 4, 0);\n  out[4] = REQUEST.WRITE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(out, reqid, 5);\n\n  writeUInt32BE(out, handlelen, p);\n  handle.copy(out, p += 4);\n  p += handlelen;\n  for (var i = 7; i >= 0; --i) {\n    out[p + i] = position & 0xFF;\n    position /= 256;\n  }\n  writeUInt32BE(out, len, p += 8);\n  buf.copy(out, p += 4, off, off + len);\n\n  state.requests[reqid] = {\n    cb: function(err) {\n      if (err)\n        cb && cb(err);\n      else if (overflow) {\n        self.writeData(handle,\n                       buf,\n                       off + len,\n                       overflow,\n                       origPosition + len,\n                       cb);\n      } else\n        cb && cb(undefined, off + len);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing WRITE');\n  return this.push(out);\n};\nfunction tryCreateBuffer(size) {\n  try {\n    return Buffer.allocUnsafe(size);\n  } catch (ex) {\n    return ex;\n  }\n}\nfunction fastXfer(src, dst, srcPath, dstPath, opts, cb) {\n  var concurrency = 64;\n  var chunkSize = 32768;\n  //var preserve = false;\n  var onstep;\n  var mode;\n  var fileSize;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n  } else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.concurrency === 'number'\n        && opts.concurrency > 0\n        && !isNaN(opts.concurrency))\n      concurrency = opts.concurrency;\n    if (typeof opts.chunkSize === 'number'\n        && opts.chunkSize > 0\n        && !isNaN(opts.chunkSize))\n      chunkSize = opts.chunkSize;\n    if (typeof opts.fileSize === 'number'\n        && opts.fileSize > 0\n        && !isNaN(opts.fileSize))\n      fileSize = opts.fileSize;\n    if (typeof opts.step === 'function')\n      onstep = opts.step;\n    //preserve = (opts.preserve ? true : false);\n    if (typeof opts.mode === 'string' || typeof opts.mode === 'number')\n      mode = modeNum(opts.mode);\n  }\n\n  // internal state variables\n  var fsize;\n  var pdst = 0;\n  var total = 0;\n  var hadError = false;\n  var srcHandle;\n  var dstHandle;\n  var readbuf;\n  var bufsize = chunkSize * concurrency;\n\n  function onerror(err) {\n    if (hadError)\n      return;\n\n    hadError = true;\n\n    var left = 0;\n    var cbfinal;\n\n    if (srcHandle || dstHandle) {\n      cbfinal = function() {\n        if (--left === 0)\n          cb(err);\n      };\n      if (srcHandle && (src === fs || src.writable))\n        ++left;\n      if (dstHandle && (dst === fs || dst.writable))\n        ++left;\n      if (srcHandle && (src === fs || src.writable))\n        src.close(srcHandle, cbfinal);\n      if (dstHandle && (dst === fs || dst.writable))\n        dst.close(dstHandle, cbfinal);\n    } else\n      cb(err);\n  }\n\n  src.open(srcPath, 'r', function(err, sourceHandle) {\n    if (err)\n      return onerror(err);\n\n    srcHandle = sourceHandle;\n\n    if (fileSize === undefined)\n      src.fstat(srcHandle, tryStat);\n    else\n      tryStat(null, { size: fileSize });\n\n    function tryStat(err, attrs) {\n      if (err) {\n        if (src !== fs) {\n          // Try stat() for sftp servers that may not support fstat() for\n          // whatever reason\n          src.stat(srcPath, function(err_, attrs_) {\n            if (err_)\n              return onerror(err);\n            tryStat(null, attrs_);\n          });\n          return;\n        }\n        return onerror(err);\n      }\n      fsize = attrs.size;\n\n      dst.open(dstPath, 'w', function(err, destHandle) {\n        if (err)\n          return onerror(err);\n\n        dstHandle = destHandle;\n\n        if (fsize <= 0)\n          return onerror();\n\n        // Use less memory where possible\n        while (bufsize > fsize) {\n          if (concurrency === 1) {\n            bufsize = fsize;\n            break;\n          }\n          bufsize -= chunkSize;\n          --concurrency;\n        }\n\n        readbuf = tryCreateBuffer(bufsize);\n        if (readbuf instanceof Error)\n          return onerror(readbuf);\n\n        if (mode !== undefined) {\n          dst.fchmod(dstHandle, mode, function tryAgain(err) {\n            if (err) {\n              // Try chmod() for sftp servers that may not support fchmod() for\n              // whatever reason\n              dst.chmod(dstPath, mode, function(err_) {\n                tryAgain();\n              });\n              return;\n            }\n            startReads();\n          });\n        } else {\n          startReads();\n        }\n\n        function onread(err, nb, data, dstpos, datapos, origChunkLen) {\n          if (err)\n            return onerror(err);\n\n          datapos = datapos || 0;\n\n          if (src === fs)\n            dst.writeData(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n          else\n            dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);\n\n          function writeCb(err) {\n            if (err)\n              return onerror(err);\n\n            total += nb;\n            onstep && onstep(total, nb, fsize);\n\n            if (nb < origChunkLen)\n              return singleRead(datapos, dstpos + nb, origChunkLen - nb);\n\n            if (total === fsize) {\n              dst.close(dstHandle, function(err) {\n                dstHandle = undefined;\n                if (err)\n                  return onerror(err);\n                src.close(srcHandle, function(err) {\n                  srcHandle = undefined;\n                  if (err)\n                    return onerror(err);\n                  cb();\n                });\n              });\n              return;\n            }\n\n            if (pdst >= fsize)\n              return;\n\n            var chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(datapos, pdst, chunk);\n            pdst += chunk;\n          }\n        }\n\n        function makeCb(psrc, pdst, chunk) {\n          return function(err, nb, data) {\n            onread(err, nb, data, pdst, psrc, chunk);\n          };\n        }\n\n        function singleRead(psrc, pdst, chunk) {\n          if (src === fs) {\n            src.read(srcHandle,\n                     readbuf,\n                     psrc,\n                     chunk,\n                     pdst,\n                     makeCb(psrc, pdst, chunk));\n          } else {\n            src.readData(srcHandle,\n                         readbuf,\n                         psrc,\n                         chunk,\n                         pdst,\n                         makeCb(psrc, pdst, chunk));\n          }\n        }\n\n        function startReads() {\n          var reads = 0;\n          var psrc = 0;\n          while (pdst < fsize && reads < concurrency) {\n            var chunk = (pdst + chunkSize > fsize ? fsize - pdst : chunkSize);\n            singleRead(psrc, pdst, chunk);\n            psrc += chunk;\n            pdst += chunk;\n            ++reads;\n          }\n        }\n      });\n    }\n  });\n}\nSFTPStream.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(this, fs, remotePath, localPath, opts, cb);\n};\nSFTPStream.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  fastXfer(fs, this, localPath, remotePath, opts, cb);\n};\nSFTPStream.prototype.readFile = function(path, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, flag: 'r' };\n  else if (!options)\n    options = { encoding: null, flag: 'r' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  var encoding = options.encoding;\n  if (encoding && !Buffer.isEncoding(encoding))\n    throw new Error('Unknown encoding: ' + encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var handle;\n\n  // SFTPv3 does not support using -1 for read position, so we have to track\n  // read position manually\n  var bytesRead = 0;\n\n  var flag = options.flag || 'r';\n  this.open(path, flag, 438 /*=0666*/, function(er, handle_) {\n    if (er)\n      return callback && callback(er);\n    handle = handle_;\n\n    self.fstat(handle, function tryStat(er, st) {\n      if (er) {\n        // Try stat() for sftp servers that may not support fstat() for\n        // whatever reason\n        self.stat(path, function(er_, st_) {\n          if (er_) {\n            return self.close(handle, function() {\n              callback && callback(er);\n            });\n          }\n          tryStat(null, st_);\n        });\n        return;\n      }\n\n      size = st.size || 0;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      buffer = Buffer.allocUnsafe(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = Buffer.allocUnsafe(8192);\n      self.readData(handle, buffer, 0, 8192, bytesRead, afterRead);\n    } else {\n      self.readData(handle, buffer, pos, size - pos, bytesRead, afterRead);\n    }\n  }\n\n  function afterRead(er, nbytes) {\n    var eof;\n    if (er) {\n      eof = (er.code === STATUS_CODE.EOF);\n      if (!eof) {\n        return self.close(handle, function() {\n          return callback && callback(er);\n        });\n      }\n    } else {\n      eof = false;\n    }\n\n    if (eof || (size === 0 && nbytes === 0))\n      return close();\n\n    bytesRead += nbytes;\n    pos += nbytes;\n    if (size !== 0) {\n      if (pos === size)\n        close();\n      else\n        read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, nbytes));\n      read();\n    }\n  }\n  afterRead._wantEOFError = true;\n\n  function close() {\n    self.close(handle, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size) {\n        buffer = buffer.slice(0, pos);\n      }\n\n      if (encoding)\n        buffer = buffer.toString(encoding);\n      return callback && callback(er, buffer);\n    });\n  }\n};\nfunction writeAll(self, handle, buffer, offset, length, position, callback_) {\n  var callback = (typeof callback_ === 'function' ? callback_ : undefined);\n\n  self.writeData(handle,\n                 buffer,\n                 offset,\n                 length,\n                 position,\n                 function(writeErr, written) {\n    if (writeErr) {\n      return self.close(handle, function() {\n        callback && callback(writeErr);\n      });\n    }\n    if (written === length)\n      self.close(handle, callback);\n    else {\n      offset += written;\n      length -= written;\n      position += written;\n      writeAll(self, handle, buffer, offset, length, position, callback);\n    }\n  });\n}\nSFTPStream.prototype.writeFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  var self = this;\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'w' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'w' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (options.encoding && !Buffer.isEncoding(options.encoding))\n    throw new Error('Unknown encoding: ' + options.encoding);\n\n  var flag = options.flag || 'w';\n  this.open(path, flag, options.mode, function(openErr, handle) {\n    if (openErr)\n      callback && callback(openErr);\n    else {\n      var buffer = (Buffer.isBuffer(data)\n                    ? data\n                    : Buffer.from('' + data, options.encoding || 'utf8'));\n      var position = (/a/.test(flag) ? null : 0);\n\n      // SFTPv3 does not support the notion of 'current position'\n      // (null position), so we just attempt to append to the end of the file\n      // instead\n      if (position === null) {\n        self.fstat(handle, function tryStat(er, st) {\n          if (er) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            self.stat(path, function(er_, st_) {\n              if (er_) {\n                return self.close(handle, function() {\n                  callback && callback(er);\n                });\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n          writeAll(self, handle, buffer, 0, buffer.length, st.size, callback);\n        });\n        return;\n      }\n      writeAll(self, handle, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\nSFTPStream.prototype.appendFile = function(path, data, options, callback_) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var callback;\n  if (typeof callback_ === 'function') {\n    callback = callback_;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  if (typeof options === 'string')\n    options = { encoding: options, mode: 438, flag: 'a' };\n  else if (!options)\n    options = { encoding: 'utf8', mode: 438 /*=0666*/, flag: 'a' };\n  else if (typeof options !== 'object')\n    throw new TypeError('Bad arguments');\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  this.writeFile(path, data, options, callback);\n};\nSFTPStream.prototype.exists = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  this.stat(path, function(err) {\n    cb && cb(err ? false : true);\n  });\n};\nSFTPStream.prototype.unlink = function(filename, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     filename\n  */\n  var fnamelen = Buffer.byteLength(filename);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnamelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.REMOVE;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, fnamelen, p);\n  buf.write(filename, p += 4, fnamelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REMOVE');\n  return this.push(buf);\n};\nSFTPStream.prototype.rename = function(oldPath, newPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     oldpath\n    string     newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.RENAME;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, oldlen, p);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RENAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.mkdir = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'function') {\n    cb = attrs;\n    attrs = undefined;\n  }\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  }\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.MKDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing MKDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.rmdir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.RMDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing RMDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.readdir = function(where, opts, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n  var doFilter;\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof opts !== 'object' || opts === null)\n    opts = {};\n\n  doFilter = (opts && opts.full ? false : true);\n\n  if (!Buffer.isBuffer(where) && typeof where !== 'string')\n    throw new Error('missing directory handle or path');\n\n  if (typeof where === 'string') {\n    var self = this;\n    var entries = [];\n    var e = 0;\n\n    return this.opendir(where, function reread(err, handle) {\n      if (err)\n        return cb(err);\n\n      self.readdir(handle, opts, function(err, list) {\n        var eof = (err && err.code === STATUS_CODE.EOF);\n\n        if (err && !eof) {\n          return self.close(handle, function() {\n            cb(err);\n          });\n        } else if (eof) {\n          return self.close(handle, function(err) {\n            if (err)\n              return cb(err);\n            cb(undefined, entries);\n          });\n        }\n\n        for (var i = 0, len = list.length; i < len; ++i, ++e)\n          entries[e] = list[i];\n\n        reread(undefined, handle);\n      });\n    });\n  }\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = where.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.READDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  where.copy(buf, p += 4);\n\n  state.requests[reqid] = {\n    cb: (doFilter\n         ? function(err, list) {\n             if (err)\n               return cb(err);\n\n             for (var i = list.length - 1; i >= 0; --i) {\n               if (list[i].filename === '.' || list[i].filename === '..')\n                 list.splice(i, 1);\n             }\n\n             cb(undefined, list);\n           }\n         : cb)\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.fstat = function(handle, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.FSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.stat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.STAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.lstat = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.LSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing LSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.opendir = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.OPENDIR;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing OPENDIR');\n  return this.push(buf);\n};\nSFTPStream.prototype.setstat = function(path, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     path\n    ATTRS      attrs\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.SETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n  writeUInt32BE(buf, flags, p += pathlen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.fsetstat = function(handle, attrs, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var flags = 0;\n  var attrBytes = 0;\n  var state = this._state;\n\n  if (typeof attrs === 'object' && attrs !== null) {\n    attrs = attrsToBytes(attrs);\n    flags = attrs.flags;\n    attrBytes = attrs.nbytes;\n    attrs = attrs.bytes;\n  } else if (typeof attrs === 'function')\n    cb = attrs;\n\n  /*\n    uint32     id\n    string     handle\n    ATTRS      attrs\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handlelen + 4 + attrBytes);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.FSETSTAT;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, handlelen, p);\n  handle.copy(buf, p += 4);\n  writeUInt32BE(buf, flags, p += handlelen);\n  if (flags) {\n    p += 4;\n    for (var i = 0, len = attrs.length; i < len; ++i)\n      for (var j = 0, len2 = attrs[i].length; j < len2; ++j)\n        buf[p++] = attrs[i][j];\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing FSETSTAT');\n  return this.push(buf);\n};\nSFTPStream.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this.fsetstat(handle, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.utimes = function(path, atime, mtime, cb) {\n  return this.setstat(path, {\n    atime: toUnixTimestamp(atime),\n    mtime: toUnixTimestamp(mtime)\n  }, cb);\n};\nSFTPStream.prototype.fchown = function(handle, uid, gid, cb) {\n  return this.fsetstat(handle, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.chown = function(path, uid, gid, cb) {\n  return this.setstat(path, {\n    uid: uid,\n    gid: gid\n  }, cb);\n};\nSFTPStream.prototype.fchmod = function(handle, mode, cb) {\n  return this.fsetstat(handle, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.chmod = function(path, mode, cb) {\n  return this.setstat(path, {\n    mode: mode\n  }, cb);\n};\nSFTPStream.prototype.readlink = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.READLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing link info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing READLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.symlink = function(targetPath, linkPath, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     linkpath\n    string     targetpath\n  */\n  var linklen = Buffer.byteLength(linkPath);\n  var targetlen = Buffer.byteLength(targetPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linklen + 4 + targetlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.SYMLINK;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  if (this._isOpenSSH) {\n    // OpenSSH has linkpath and targetpath positions switched\n    writeUInt32BE(buf, targetlen, p);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n    writeUInt32BE(buf, linklen, p += targetlen);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n  } else {\n    writeUInt32BE(buf, linklen, p);\n    buf.write(linkPath, p += 4, linklen, 'utf8');\n    writeUInt32BE(buf, targetlen, p += linklen);\n    buf.write(targetPath, p += 4, targetlen, 'utf8');\n  }\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing SYMLINK');\n  return this.push(buf);\n};\nSFTPStream.prototype.realpath = function(path, cb) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var state = this._state;\n\n  /*\n    uint32     id\n    string     path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.REALPATH;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    cb: function(err, names) {\n      if (err)\n        return cb(err);\n      else if (!names || !names.length)\n        return cb(new Error('Response missing path info'));\n      cb(undefined, names[0].filename);\n    }\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing REALPATH');\n  return this.push(buf);\n};\n// extended requests\nSFTPStream.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['posix-rename@openssh.com']\n           || state.extensions['posix-rename@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"posix-rename@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 24, p);\n  buf.write('posix-rename@openssh.com', p += 4, 24, 'ascii');\n\n  writeUInt32BE(buf, oldlen, p += 24);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing posix-rename@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_statvfs = function(path, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['statvfs@openssh.com']\n           || state.extensions['statvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"statvfs@openssh.com\"\n    string    path\n  */\n  var pathlen = Buffer.byteLength(path);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 19, p);\n  buf.write('statvfs@openssh.com', p += 4, 19, 'ascii');\n\n  writeUInt32BE(buf, pathlen, p += 19);\n  buf.write(path, p += 4, pathlen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'statvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing statvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fstatvfs@openssh.com']\n           || state.extensions['fstatvfs@openssh.com'].indexOf('2') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fstatvfs@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 20, p);\n  buf.write('fstatvfs@openssh.com', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, handlelen, p += 20);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = {\n    extended: 'fstatvfs@openssh.com',\n    cb: cb\n  };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fstatvfs@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['hardlink@openssh.com']\n           || state.extensions['hardlink@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n\n  /*\n    uint32    id\n    string    \"hardlink@openssh.com\"\n    string    oldpath\n    string    newpath\n  */\n  var oldlen = Buffer.byteLength(oldPath);\n  var newlen = Buffer.byteLength(newPath);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldlen + 4 + newlen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 20, p);\n  buf.write('hardlink@openssh.com', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, oldlen, p += 20);\n  buf.write(oldPath, p += 4, oldlen, 'utf8');\n  writeUInt32BE(buf, newlen, p += oldlen);\n  buf.write(newPath, p += 4, newlen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing hardlink@openssh.com');\n  return this.push(buf);\n};\nSFTPStream.prototype.ext_openssh_fsync = function(handle, cb) {\n  var state = this._state;\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n  else if (!state.extensions['fsync@openssh.com']\n           || state.extensions['fsync@openssh.com'].indexOf('1') === -1)\n    throw new Error('Server does not support this extended request');\n  else if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  /*\n    uint32    id\n    string    \"fsync@openssh.com\"\n    string    handle\n  */\n  var handlelen = handle.length;\n  var p = 9;\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handlelen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = REQUEST.EXTENDED;\n  var reqid = state.writeReqid = (state.writeReqid + 1) % MAX_REQID;\n  writeUInt32BE(buf, reqid, 5);\n  writeUInt32BE(buf, 17, p);\n  buf.write('fsync@openssh.com', p += 4, 17, 'ascii');\n\n  writeUInt32BE(buf, handlelen, p += 17);\n  buf.write(handle, p += 4, handlelen, 'utf8');\n\n  state.requests[reqid] = { cb: cb };\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing fsync@openssh.com');\n  return this.push(buf);\n};\n\n// server\nSFTPStream.prototype.status = function(id, code, message, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!STATUS_CODE[code] || typeof code !== 'number')\n    throw new Error('Bad status code: ' + code);\n\n  message || (message = '');\n  lang || (lang = '');\n\n  var msgLen = Buffer.byteLength(message);\n  var langLen = Buffer.byteLength(lang);\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4 + langLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.STATUS;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, code, 9);\n\n  writeUInt32BE(buf, msgLen, 13);\n  if (msgLen)\n    buf.write(message, 17, msgLen, 'utf8');\n\n  writeUInt32BE(buf, langLen, 17 + msgLen);\n  if (langLen)\n    buf.write(lang, 17 + msgLen + 4, langLen, 'ascii');\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing STATUS');\n  return this.push(buf);\n};\nSFTPStream.prototype.handle = function(id, handle) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Buffer.isBuffer(handle))\n    throw new Error('handle is not a Buffer');\n\n  var handleLen = handle.length;\n\n  if (handleLen > 256)\n    throw new Error('handle too large (> 256 bytes)');\n\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.HANDLE;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, handleLen, 9);\n  if (handleLen)\n    handle.copy(buf, 13);\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing HANDLE');\n  return this.push(buf);\n};\nSFTPStream.prototype.data = function(id, data, encoding) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var isBuffer = Buffer.isBuffer(data);\n\n  if (!isBuffer && typeof data !== 'string')\n    throw new Error('data is not a Buffer or string');\n\n  if (!isBuffer)\n    encoding || (encoding = 'utf8');\n\n  var dataLen = (isBuffer ? data.length : Buffer.byteLength(data, encoding));\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.DATA;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, dataLen, 9);\n  if (dataLen) {\n    if (isBuffer)\n      data.copy(buf, 13);\n    else\n      buf.write(data, 13, dataLen, encoding);\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing DATA');\n  return this.push(buf);\n};\nSFTPStream.prototype.name = function(id, names) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (!Array.isArray(names)) {\n    if (typeof names !== 'object' || names === null)\n      throw new Error('names is not an object or array');\n    names = [ names ];\n  }\n\n  var count = names.length;\n  var namesLen = 0;\n  var nameAttrs;\n  var attrs = [];\n  var name;\n  var filename;\n  var longname;\n  var attr;\n  var len;\n  var len2;\n  var buf;\n  var p;\n  var i;\n  var j;\n  var k;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    namesLen += 4 + Buffer.byteLength(filename);\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    namesLen += 4 + Buffer.byteLength(longname);\n\n    if (typeof name.attrs === 'object' && name.attrs !== null) {\n      nameAttrs = attrsToBytes(name.attrs);\n      namesLen += 4 + nameAttrs.nbytes;\n      attrs.push(nameAttrs);\n    } else {\n      namesLen += 4;\n      attrs.push(null);\n    }\n  }\n\n  buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.NAME;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, count, 9);\n\n  p = 13;\n\n  for (i = 0; i < count; ++i) {\n    name = names[i];\n\n    filename = (!name || !name.filename || typeof name.filename !== 'string'\n                ? ''\n                : name.filename);\n    len = Buffer.byteLength(filename);\n    writeUInt32BE(buf, len, p);\n    p += 4;\n    if (len) {\n      buf.write(filename, p, len, 'utf8');\n      p += len;\n    }\n\n    longname = (!name || !name.longname || typeof name.longname !== 'string'\n                ? ''\n                : name.longname);\n    len = Buffer.byteLength(longname);\n    writeUInt32BE(buf, len, p);\n    p += 4;\n    if (len) {\n      buf.write(longname, p, len, 'utf8');\n      p += len;\n    }\n\n    attr = attrs[i];\n    if (attr) {\n      writeUInt32BE(buf, attr.flags, p);\n      p += 4;\n      if (attr.flags && attr.bytes) {\n        var bytes = attr.bytes;\n        for (j = 0, len = bytes.length; j < len; ++j)\n          for (k = 0, len2 = bytes[j].length; k < len2; ++k)\n            buf[p++] = bytes[j][k];\n      }\n    } else {\n      writeUInt32BE(buf, 0, p);\n      p += 4;\n    }\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing NAME');\n  return this.push(buf);\n};\nSFTPStream.prototype.attrs = function(id, attrs) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (typeof attrs !== 'object' || attrs === null)\n    throw new Error('attrs is not an object');\n\n  var info = attrsToBytes(attrs);\n  var buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + info.nbytes);\n  var p = 13;\n\n  writeUInt32BE(buf, buf.length - 4, 0);\n  buf[4] = RESPONSE.ATTRS;\n  writeUInt32BE(buf, id, 5);\n\n  writeUInt32BE(buf, info.flags, 9);\n\n  if (info.flags && info.bytes) {\n    var bytes = info.bytes;\n    for (var j = 0, len = bytes.length; j < len; ++j)\n      for (var k = 0, len2 = bytes[j].length; k < len2; ++k)\n        buf[p++] = bytes[j][k];\n  }\n\n  this.debug('DEBUG[SFTP]: Outgoing: Writing ATTRS');\n  return this.push(buf);\n};\n\nfunction readAttrs(buf, p, stream, callback) {\n  /*\n    uint32   flags\n    uint64   size           present only if flag SSH_FILEXFER_ATTR_SIZE\n    uint32   uid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   gid            present only if flag SSH_FILEXFER_ATTR_UIDGID\n    uint32   permissions    present only if flag SSH_FILEXFER_ATTR_PERMISSIONS\n    uint32   atime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   mtime          present only if flag SSH_FILEXFER_ACMODTIME\n    uint32   extended_count present only if flag SSH_FILEXFER_ATTR_EXTENDED\n    string   extended_type\n    string   extended_data\n    ...      more extended data (extended_type - extended_data pairs),\n               so that number of pairs equals extended_count\n  */\n  var flags = readUInt32BE(buf, p);\n  var attrs = new Stats();\n\n  p += 4;\n\n  if (flags & ATTR.SIZE) {\n    var size = readUInt64BE(buf, p, stream, callback);\n    if (size === false)\n      return false;\n    attrs.size = size;\n    p += 8;\n  }\n  if (flags & ATTR.UIDGID) {\n    var uid;\n    var gid;\n    uid = readInt(buf, p, this, callback);\n    if (uid === false)\n      return false;\n    attrs.uid = uid;\n    p += 4;\n    gid = readInt(buf, p, this, callback);\n    if (gid === false)\n      return false;\n    attrs.gid = gid;\n    p += 4;\n  }\n  if (flags & ATTR.PERMISSIONS) {\n    var mode = readInt(buf, p, this, callback);\n    if (mode === false)\n      return false;\n    attrs.mode = mode;\n    // backwards compatibility\n    attrs.permissions = mode;\n    p += 4;\n  }\n  if (flags & ATTR.ACMODTIME) {\n    var atime;\n    var mtime;\n    atime = readInt(buf, p, this, callback);\n    if (atime === false)\n      return false;\n    attrs.atime = atime;\n    p += 4;\n    mtime = readInt(buf, p, this, callback);\n    if (mtime === false)\n      return false;\n    attrs.mtime = mtime;\n    p += 4;\n  }\n  if (flags & ATTR.EXTENDED) {\n    // TODO: read/parse extended data\n    var extcount = readInt(buf, p, this, callback);\n    if (extcount === false)\n      return false;\n    p += 4;\n    for (var i = 0, len; i < extcount; ++i) {\n      len = readInt(buf, p, this, callback);\n      if (len === false)\n        return false;\n      p += 4 + len;\n    }\n  }\n\n  buf._pos = p;\n\n  return attrs;\n}\n\nfunction readUInt64BE(buffer, p, stream, callback) {\n  if ((buffer.length - p) < 8) {\n    stream && stream._cleanup(callback);\n    return false;\n  }\n\n  var val = 0;\n\n  for (var len = p + 8; p < len; ++p) {\n    val *= 256;\n    val += buffer[p];\n  }\n\n  buffer._pos = p;\n\n  return val;\n}\n\nfunction attrsToBytes(attrs) {\n  var flags = 0;\n  var attrBytes = 0;\n  var ret = [];\n  var i = 0;\n\n  if (typeof attrs !== 'object' || attrs === null)\n    return { flags: flags, nbytes: attrBytes, bytes: ret };\n\n  if (typeof attrs.size === 'number') {\n    flags |= ATTR.SIZE;\n    attrBytes += 8;\n    var sizeBytes = new Array(8);\n    var val = attrs.size;\n    for (i = 7; i >= 0; --i) {\n      sizeBytes[i] = val & 0xFF;\n      val /= 256;\n    }\n    ret.push(sizeBytes);\n  }\n  if (typeof attrs.uid === 'number' && typeof attrs.gid === 'number') {\n    flags |= ATTR.UIDGID;\n    attrBytes += 8;\n    ret.push([(attrs.uid >> 24) & 0xFF, (attrs.uid >> 16) & 0xFF,\n              (attrs.uid >> 8) & 0xFF, attrs.uid & 0xFF]);\n    ret.push([(attrs.gid >> 24) & 0xFF, (attrs.gid >> 16) & 0xFF,\n              (attrs.gid >> 8) & 0xFF, attrs.gid & 0xFF]);\n  }\n  if (typeof attrs.permissions === 'number'\n      || typeof attrs.permissions === 'string'\n      || typeof attrs.mode === 'number'\n      || typeof attrs.mode === 'string') {\n    var mode = modeNum(attrs.mode || attrs.permissions);\n    flags |= ATTR.PERMISSIONS;\n    attrBytes += 4;\n    ret.push([(mode >> 24) & 0xFF,\n              (mode >> 16) & 0xFF,\n              (mode >> 8) & 0xFF,\n              mode & 0xFF]);\n  }\n  if ((typeof attrs.atime === 'number' || isDate(attrs.atime))\n      && (typeof attrs.mtime === 'number' || isDate(attrs.mtime))) {\n    var atime = toUnixTimestamp(attrs.atime);\n    var mtime = toUnixTimestamp(attrs.mtime);\n\n    flags |= ATTR.ACMODTIME;\n    attrBytes += 8;\n    ret.push([(atime >> 24) & 0xFF, (atime >> 16) & 0xFF,\n              (atime >> 8) & 0xFF, atime & 0xFF]);\n    ret.push([(mtime >> 24) & 0xFF, (mtime >> 16) & 0xFF,\n              (mtime >> 8) & 0xFF, mtime & 0xFF]);\n  }\n  // TODO: extended attributes\n\n  return { flags: flags, nbytes: attrBytes, bytes: ret };\n}\n\nfunction toUnixTimestamp(time) {\n  if (typeof time === 'number' && !isNaN(time))\n    return time;\n  else if (isDate(time))\n    return parseInt(time.getTime() / 1000, 10);\n  throw new Error('Cannot parse time: ' + time);\n}\n\nfunction modeNum(mode) {\n  if (typeof mode === 'number' && !isNaN(mode))\n    return mode;\n  else if (typeof mode === 'string')\n    return modeNum(parseInt(mode, 8));\n  throw new Error('Cannot parse mode: ' + mode);\n}\n\nvar stringFlagMap = {\n  'r': OPEN_MODE.READ,\n  'r+': OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'w': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'wx': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xw': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'w+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'wx+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xw+': OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'a': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,\n  'ax': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'xa': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,\n  'a+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,\n  'ax+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL,\n  'xa+': OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE\n         | OPEN_MODE.EXCL\n};\nvar stringFlagMapKeys = Object.keys(stringFlagMap);\n\nfunction stringToFlags(str) {\n  var flags = stringFlagMap[str];\n  if (flags !== undefined)\n    return flags;\n  return null;\n}\nSFTPStream.stringToFlags = stringToFlags;\n\nfunction flagsToString(flags) {\n  for (var i = 0; i < stringFlagMapKeys.length; ++i) {\n    var key = stringFlagMapKeys[i];\n    if (stringFlagMap[key] === flags)\n      return key;\n  }\n  return null;\n}\nSFTPStream.flagsToString = flagsToString;\n\nfunction Stats(initial) {\n  this.mode = (initial && initial.mode);\n  this.permissions = this.mode; // backwards compatiblity\n  this.uid = (initial && initial.uid);\n  this.gid = (initial && initial.gid);\n  this.size = (initial && initial.size);\n  this.atime = (initial && initial.atime);\n  this.mtime = (initial && initial.mtime);\n}\nStats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\nStats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\nStats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\nStats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\nStats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\nStats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\nStats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\nStats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\nSFTPStream.Stats = Stats;\n\n// =============================================================================\n// ReadStream/WriteStream-related\nvar fsCompat = require('./node-fs-compat');\nvar validateNumber = fsCompat.validateNumber;\nvar destroyImpl = fsCompat.destroyImpl;\nvar ERR_OUT_OF_RANGE = fsCompat.ERR_OUT_OF_RANGE;\nvar ERR_INVALID_ARG_TYPE = fsCompat.ERR_INVALID_ARG_TYPE;\n\nvar kMinPoolSpace = 128;\n\nvar pool;\n// It can happen that we expect to read a large chunk of data, and reserve\n// a large chunk of the pool accordingly, but the read() call only filled\n// a portion of it. If a concurrently executing read() then uses the same pool,\n// the \"reserved\" portion cannot be used, so we allow it to be re-used as a\n// new pool later.\nvar poolFragments = [];\n\nfunction allocNewPool(poolSize) {\n  if (poolFragments.length > 0)\n    pool = poolFragments.pop();\n  else\n    pool = Buffer.allocUnsafe(poolSize);\n  pool.used = 0;\n}\n\n// Check the `this.start` and `this.end` of stream.\nfunction checkPosition(pos, name) {\n  if (!Number.isSafeInteger(pos)) {\n    validateNumber(pos, name);\n    if (!Number.isInteger(pos))\n      throw new ERR_OUT_OF_RANGE(name, 'an integer', pos);\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n  }\n  if (pos < 0)\n    throw new ERR_OUT_OF_RANGE(name, '>= 0 and <= 2 ** 53 - 1', pos);\n}\n\nfunction roundUpToMultipleOf8(n) {\n  return (n + 7) & ~7;  // Align to 8 byte boundary.\n}\n\nfunction ReadStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // A little bit bigger buffer and water marks by default\n  if (options.highWaterMark === undefined)\n    options.highWaterMark = 64 * 1024;\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n\n  ReadableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'r' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.end = options.end;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesRead = 0;\n  this.closed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (this.end === undefined) {\n    this.end = Infinity;\n  } else if (this.end !== Infinity) {\n    checkPosition(this.end, 'end');\n\n    if (this.start !== undefined && this.start > this.end) {\n      throw new ERR_OUT_OF_RANGE(\n        'start',\n        `<= \"end\" (here: ${this.end})`,\n        this.start\n      );\n    }\n  }\n\n  this.on('end', function() {\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(ReadStream, ReadableStream);\n\nReadStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n    this.emit('open', handle);\n    this.emit('ready');\n    // start the flow of data.\n    this.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._read(n);\n    });\n  }\n\n  // XXX: safe to remove this?\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    allocNewPool(this.readableHighWaterMark\n                 || this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (this.end !== undefined)\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // Already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  this.sftp.readData(this.handle,\n                     pool,\n                     pool.used,\n                     toRead,\n                     this.pos,\n                     (er, bytesRead) => {\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n    var b = null;\n\n    // Now that we know how much data we have actually read, re-wind the\n    // 'used' field if we can, and otherwise allow the remainder of our\n    // reservation to be used as a new pool later.\n    if (start + toRead === thisPool.used && thisPool === pool) {\n      var newUsed = thisPool.used + bytesRead - toRead;\n      thisPool.used = roundUpToMultipleOf8(newUsed);\n    } else {\n      // Round down to the next lowest multiple of 8 to ensure the new pool\n      // fragment start and end positions are aligned to an 8 byte boundary.\n      var alignedEnd = (start + toRead) & ~7;\n      var alignedStart = roundUpToMultipleOf8(start + bytesRead);\n      if (alignedEnd - alignedStart >= kMinPoolSpace)\n        poolFragments.push(thisPool.slice(alignedStart, alignedEnd));\n    }\n\n    if (bytesRead > 0) {\n      this.bytesRead += bytesRead;\n      b = thisPool.slice(start, start + bytesRead);\n    }\n\n    // Move the pool positions, and internal position for reading.\n    this.pos += bytesRead;\n\n    this.push(b);\n  });\n\n  pool.used = roundUpToMultipleOf8(pool.used + toRead);\n};\n\nif (typeof ReadableStream.prototype.destroy !== 'function')\n  ReadStream.prototype.destroy = destroyImpl;\n\nReadStream.prototype._destroy = function(err, cb) {\n  if (this._opening && !Buffer.isBuffer(this.handle)) {\n    this.once('open', closeStream.bind(null, this, cb, err));\n    return;\n  }\n\n  closeStream(this, cb, err);\n  this.handle = null;\n  this._opening = false;\n};\n\nfunction closeStream(stream, cb, err) {\n  if (!stream.handle)\n    return onclose();\n\n  stream.sftp.close(stream.handle, onclose);\n\n  function onclose(er) {\n    er = er || err;\n    cb(er);\n    stream.closed = true;\n    if (!er)\n      stream.emit('close');\n  }\n}\n\nReadStream.prototype.close = function(cb) {\n  this.destroy(null, cb);\n};\n\nObject.defineProperty(ReadStream.prototype, 'pending', {\n  get() { return this.handle === null; },\n  configurable: true\n});\n\nfunction WriteStream(sftp, path, options) {\n  if (options === undefined)\n    options = {};\n  else if (typeof options === 'string')\n    options = { encoding: options };\n  else if (options === null || typeof options !== 'object')\n    throw new TypeError('\"options\" argument must be a string or an object');\n  else\n    options = Object.create(options);\n\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n\n  WritableStream.call(this, options);\n\n  this.path = path;\n  this.flags = options.flags === undefined ? 'w' : options.flags;\n  this.mode = options.mode === undefined ? 0o666 : options.mode;\n\n  this.start = options.start;\n  this.autoClose = options.autoClose === undefined ? true : options.autoClose;\n  this.pos = 0;\n  this.bytesWritten = 0;\n  this.closed = false;\n\n  this.handle = options.handle === undefined ? null : options.handle;\n  this.sftp = sftp;\n  this._opening = false;\n\n  if (this.start !== undefined) {\n    checkPosition(this.start, 'start');\n\n    this.pos = this.start;\n  }\n\n  if (options.encoding)\n    this.setDefaultEncoding(options.encoding);\n\n  // Node v6.x only\n  this.on('finish', function() {\n    if (this._writableState.finalCalled)\n      return;\n    if (this.autoClose)\n      this.destroy();\n  });\n\n  if (!Buffer.isBuffer(this.handle))\n    this.open();\n}\ninherits(WriteStream, WritableStream);\n\nWriteStream.prototype._final = function(cb) {\n  if (this.autoClose)\n    this.destroy();\n  cb();\n};\n\nWriteStream.prototype.open = function() {\n  if (this._opening)\n    return;\n\n  this._opening = true;\n\n  this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {\n    this._opening = false;\n\n    if (er) {\n      this.emit('error', er);\n      if (this.autoClose)\n        this.destroy();\n      return;\n    }\n\n    this.handle = handle;\n\n    var tryAgain = (err) => {\n      if (err) {\n        // Try chmod() for sftp servers that may not support fchmod() for\n        // whatever reason\n        this.sftp.chmod(this.path, this.mode, (err_) => {\n          tryAgain();\n        });\n        return;\n      }\n\n      // SFTPv3 requires absolute offsets, no matter the open flag used\n      if (this.flags[0] === 'a') {\n        var tryStat = (err, st) => {\n          if (err) {\n            // Try stat() for sftp servers that may not support fstat() for\n            // whatever reason\n            this.sftp.stat(this.path, (err_, st_) => {\n              if (err_) {\n                this.destroy();\n                this.emit('error', err);\n                return;\n              }\n              tryStat(null, st_);\n            });\n            return;\n          }\n\n          this.pos = st.size;\n          this.emit('open', handle);\n          this.emit('ready');\n        };\n\n        this.sftp.fstat(handle, tryStat);\n        return;\n      }\n\n      this.emit('open', handle);\n      this.emit('ready');\n    };\n\n    this.sftp.fchmod(handle, this.mode, tryAgain);\n  });\n};\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!Buffer.isBuffer(data)) {\n    const err = new ERR_INVALID_ARG_TYPE('data', 'Buffer', data);\n    return this.emit('error', err);\n  }\n\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n  }\n\n  this.sftp.writeData(this.handle,\n                      data,\n                      0,\n                      data.length,\n                      this.pos,\n                      (er, bytes) => {\n    if (er) {\n      if (this.autoClose)\n        this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    cb();\n  });\n\n  this.pos += data.length;\n};\n\nWriteStream.prototype._writev = function(data, cb) {\n  if (!Buffer.isBuffer(this.handle)) {\n    return this.once('open', function() {\n      this._writev(data, cb);\n    });\n  }\n\n  var sftp = this.sftp;\n  var handle = this.handle;\n  var writesLeft = data.length;\n\n  var onwrite = (er, bytes) => {\n    if (er) {\n      this.destroy();\n      return cb(er);\n    }\n    this.bytesWritten += bytes;\n    if (--writesLeft === 0)\n      cb();\n  };\n\n  // TODO: try to combine chunks to reduce number of requests to the server\n  for (var i = 0; i < data.length; ++i) {\n    var chunk = data[i].chunk;\n\n    sftp.writeData(handle, chunk, 0, chunk.length, this.pos, onwrite);\n    this.pos += chunk.length;\n  }\n};\n\nif (typeof WritableStream.prototype.destroy !== 'function')\n  WriteStream.prototype.destroy = ReadStream.prototype.destroy;\n\nWriteStream.prototype._destroy = ReadStream.prototype._destroy;\nWriteStream.prototype.close = function(cb) {\n  if (cb) {\n    if (this.closed) {\n      process.nextTick(cb);\n      return;\n    } else {\n      this.on('close', cb);\n    }\n  }\n\n  // If we are not autoClosing, we should call\n  // destroy on 'finish'.\n  if (!this.autoClose)\n    this.on('finish', this.destroy.bind(this));\n\n  this.end();\n};\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\nObject.defineProperty(WriteStream.prototype, 'pending', {\n  get() { return this.handle === null; },\n  configurable: true\n});\n\nmodule.exports = SFTPStream;\n\n","// TODO: * Automatic re-key every (configurable) n bytes or length of time\n//         - RFC suggests every 1GB of transmitted data or 1 hour, whichever\n//           comes sooner\n//       * Filter control codes from strings\n//         (as per http://tools.ietf.org/html/rfc4251#section-9.2)\n\nvar crypto = require('crypto');\nvar zlib = require('zlib');\nvar TransformStream = require('stream').Transform;\nvar inherits = require('util').inherits;\nvar inspect = require('util').inspect;\n\nvar StreamSearch = require('streamsearch');\nvar Ber = require('asn1').Ber;\n\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\nvar consts = require('./constants');\nvar utils = require('./utils');\nvar iv_inc = utils.iv_inc;\nvar readString = utils.readString;\nvar readInt = utils.readInt;\nvar DSASigBERToBare = utils.DSASigBERToBare;\nvar ECDSASigASN1ToSSH = utils.ECDSASigASN1ToSSH;\nvar sigSSHToASN1 = utils.sigSSHToASN1;\nvar parseDERKey = require('./keyParser').parseDERKey;\n\nvar CIPHER_INFO = consts.CIPHER_INFO;\nvar HMAC_INFO = consts.HMAC_INFO;\nvar MESSAGE = consts.MESSAGE;\nvar DYNAMIC_KEXDH_MESSAGE = consts.DYNAMIC_KEXDH_MESSAGE;\nvar KEXDH_MESSAGE = consts.KEXDH_MESSAGE;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar SSH_TO_OPENSSL = consts.SSH_TO_OPENSSL;\nvar TERMINAL_MODE = consts.TERMINAL_MODE;\nvar SIGNALS = consts.SIGNALS;\nvar EDDSA_SUPPORTED = consts.EDDSA_SUPPORTED;\nvar CURVE25519_SUPPORTED = consts.CURVE25519_SUPPORTED;\nvar BUGS = consts.BUGS;\nvar BUGGY_IMPLS = consts.BUGGY_IMPLS;\nvar BUGGY_IMPLS_LEN = BUGGY_IMPLS.length;\nvar MODULE_VER = require('../package.json').version;\nvar I = 0;\nvar IN_INIT = I++;\nvar IN_GREETING = I++;\nvar IN_HEADER = I++;\nvar IN_PACKETBEFORE = I++;\nvar IN_PACKET = I++;\nvar IN_PACKETDATA = I++;\nvar IN_PACKETDATAVERIFY = I++;\nvar IN_PACKETDATAAFTER = I++;\nvar OUT_INIT = I++;\nvar OUT_READY = I++;\nvar OUT_REKEYING = I++;\nvar MAX_SEQNO = 4294967295;\nvar MAX_PACKET_SIZE = 35000;\nvar MAX_PACKETS_REKEYING = 50;\nvar EXP_TYPE_HEADER = 0;\nvar EXP_TYPE_LF = 1;\nvar EXP_TYPE_BYTES = 2; // Waits until n bytes have been seen\nvar Z_PARTIAL_FLUSH = zlib.Z_PARTIAL_FLUSH;\nvar ZLIB_OPTS = { flush: Z_PARTIAL_FLUSH };\n\nvar RE_NULL = /\\x00/g;\n\nvar IDENT_PREFIX_BUFFER = Buffer.from('SSH-');\nvar EMPTY_BUFFER = Buffer.allocUnsafe(0);\nvar HMAC_COMPUTE = Buffer.allocUnsafe(9);\nvar PING_PACKET = Buffer.from([\n  MESSAGE.GLOBAL_REQUEST,\n  // \"keepalive@openssh.com\"\n  0, 0, 0, 21,\n    107, 101, 101, 112, 97, 108, 105, 118, 101, 64, 111, 112, 101, 110, 115,\n    115, 104, 46, 99, 111, 109,\n  // Request a reply\n  1\n]);\nvar NEWKEYS_PACKET = Buffer.from([MESSAGE.NEWKEYS]);\nvar USERAUTH_SUCCESS_PACKET = Buffer.from([MESSAGE.USERAUTH_SUCCESS]);\nvar REQUEST_SUCCESS_PACKET = Buffer.from([MESSAGE.REQUEST_SUCCESS]);\nvar REQUEST_FAILURE_PACKET = Buffer.from([MESSAGE.REQUEST_FAILURE]);\nvar NO_TERMINAL_MODES_BUFFER = Buffer.from([TERMINAL_MODE.TTY_OP_END]);\nvar KEXDH_GEX_REQ_PACKET = Buffer.from([\n  MESSAGE.KEXDH_GEX_REQUEST,\n  // Minimal size in bits of an acceptable group\n  0, 0, 4, 0, // 1024, modp2\n  // Preferred size in bits of the group the server will send\n  0, 0, 16, 0, // 4096, modp16\n  // Maximal size in bits of an acceptable group\n  0, 0, 32, 0 // 8192, modp18\n]);\n\nfunction DEBUG_NOOP(msg) {}\n\nfunction SSH2Stream(cfg) {\n  if (typeof cfg !== 'object' || cfg === null)\n    cfg = {};\n\n  TransformStream.call(this, {\n    highWaterMark: (typeof cfg.highWaterMark === 'number'\n                    ? cfg.highWaterMark\n                    : 32 * 1024)\n  });\n\n  this._needContinue = false;\n  this.bytesSent = this.bytesReceived = 0;\n  this.debug = (typeof cfg.debug === 'function' ? cfg.debug : DEBUG_NOOP);\n  this.server = (cfg.server === true);\n  this.maxPacketSize = (typeof cfg.maxPacketSize === 'number'\n                        ? cfg.maxPacketSize\n                        : MAX_PACKET_SIZE);\n  // Bitmap that indicates any bugs the remote side has. This is determined\n  // by the reported software version.\n  this.remoteBugs = 0;\n\n  if (this.server) {\n    // TODO: Remove when we support group exchange for server implementation\n    this.remoteBugs = BUGS.BAD_DHGEX;\n  }\n\n  this.readable = true;\n\n  var self = this;\n\n  var hostKeys = cfg.hostKeys;\n  if (this.server && (typeof hostKeys !== 'object' || hostKeys === null))\n    throw new Error('hostKeys must be an object keyed on host key type');\n\n  this.config = {\n    // Server\n    hostKeys: hostKeys, // All keys supported by server\n\n    // Client/Server\n    ident: 'SSH-2.0-'\n           + (cfg.ident\n              || ('ssh2js' + MODULE_VER + (this.server ? 'srv' : ''))),\n    algorithms: {\n      kex: ALGORITHMS.KEX,\n      kexBuf: ALGORITHMS.KEX_BUF,\n      serverHostKey: ALGORITHMS.SERVER_HOST_KEY,\n      serverHostKeyBuf: ALGORITHMS.SERVER_HOST_KEY_BUF,\n      cipher: ALGORITHMS.CIPHER,\n      cipherBuf: ALGORITHMS.CIPHER_BUF,\n      hmac: ALGORITHMS.HMAC,\n      hmacBuf: ALGORITHMS.HMAC_BUF,\n      compress: ALGORITHMS.COMPRESS,\n      compressBuf: ALGORITHMS.COMPRESS_BUF\n    }\n  };\n  // RFC 4253 states the identification string must not contain NULL\n  this.config.ident.replace(RE_NULL, '');\n\n  if (this.config.ident.length + 2 /* Account for \"\\r\\n\" */ > 255)\n    throw new Error('ident too long');\n\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algos = cfg.algorithms;\n    if (Array.isArray(algos.kex) && algos.kex.length > 0) {\n      this.config.algorithms.kex = algos.kex;\n      if (!Buffer.isBuffer(algos.kexBuf))\n        algos.kexBuf = Buffer.from(algos.kex.join(','), 'ascii');\n      this.config.algorithms.kexBuf = algos.kexBuf;\n    }\n    if (Array.isArray(algos.serverHostKey) && algos.serverHostKey.length > 0) {\n      this.config.algorithms.serverHostKey = algos.serverHostKey;\n      if (!Buffer.isBuffer(algos.serverHostKeyBuf)) {\n        algos.serverHostKeyBuf = Buffer.from(algos.serverHostKey.join(','),\n                                             'ascii');\n      }\n      this.config.algorithms.serverHostKeyBuf = algos.serverHostKeyBuf;\n    }\n    if (Array.isArray(algos.cipher) && algos.cipher.length > 0) {\n      this.config.algorithms.cipher = algos.cipher;\n      if (!Buffer.isBuffer(algos.cipherBuf))\n        algos.cipherBuf = Buffer.from(algos.cipher.join(','), 'ascii');\n      this.config.algorithms.cipherBuf = algos.cipherBuf;\n    }\n    if (Array.isArray(algos.hmac) && algos.hmac.length > 0) {\n      this.config.algorithms.hmac = algos.hmac;\n      if (!Buffer.isBuffer(algos.hmacBuf))\n        algos.hmacBuf = Buffer.from(algos.hmac.join(','), 'ascii');\n      this.config.algorithms.hmacBuf = algos.hmacBuf;\n    }\n    if (Array.isArray(algos.compress) && algos.compress.length > 0) {\n      this.config.algorithms.compress = algos.compress;\n      if (!Buffer.isBuffer(algos.compressBuf))\n        algos.compressBuf = Buffer.from(algos.compress.join(','), 'ascii');\n      this.config.algorithms.compressBuf = algos.compressBuf;\n    }\n  }\n\n  this.reset(true);\n\n  // Common events\n  this.on('end', function() {\n    // Let GC collect any Buffers we were previously storing\n    self.readable = false;\n    self._state = undefined;\n    self.reset();\n    self._state.outgoing.bufSeqno = undefined;\n  });\n  this.on('DISCONNECT', function(reason, code, desc, lang) {\n    onDISCONNECT(self, reason, code, desc, lang);\n  });\n  this.on('KEXINIT', function(init, firstFollows) {\n    onKEXINIT(self, init, firstFollows);\n  });\n  this.on('NEWKEYS', function() { onNEWKEYS(self); });\n\n  if (this.server) {\n    // Server-specific events\n    this.on('KEXDH_INIT', function(e) { onKEXDH_INIT(self, e); });\n  } else {\n    // Client-specific events\n    this.on('KEXDH_REPLY', function(info) { onKEXDH_REPLY(self, info); })\n        .on('KEXDH_GEX_GROUP',\n            function(prime, gen) { onKEXDH_GEX_GROUP(self, prime, gen); });\n  }\n\n  if (this.server) {\n    // Greeting displayed before the ssh identification string is sent, this is\n    // usually ignored by most clients\n    if (typeof cfg.greeting === 'string' && cfg.greeting.length) {\n      if (cfg.greeting.slice(-2) === '\\r\\n')\n        this.push(cfg.greeting);\n      else\n        this.push(cfg.greeting + '\\r\\n');\n    }\n    // Banner shown after the handshake completes, but before user\n    // authentication begins\n    if (typeof cfg.banner === 'string' && cfg.banner.length) {\n      if (cfg.banner.slice(-2) === '\\r\\n')\n        this.banner = cfg.banner;\n      else\n        this.banner = cfg.banner + '\\r\\n';\n    }\n  }\n  this.debug('DEBUG: Local ident: ' + inspect(this.config.ident));\n  this.push(this.config.ident + '\\r\\n');\n\n  this._state.incoming.expectedPacket = 'KEXINIT';\n}\ninherits(SSH2Stream, TransformStream);\n\nSSH2Stream.prototype.__read = TransformStream.prototype._read;\nSSH2Stream.prototype._read = function(n) {\n  if (this._needContinue) {\n    this._needContinue = false;\n    this.emit('continue');\n  }\n  return this.__read(n);\n};\nSSH2Stream.prototype.__push = TransformStream.prototype.push;\nSSH2Stream.prototype.push = function(chunk, encoding) {\n  var ret = this.__push(chunk, encoding);\n  this._needContinue = (ret === false);\n  return ret;\n};\n\nSSH2Stream.prototype._cleanup = function(callback) {\n  this.reset();\n  this.debug('DEBUG: Parser: Malformed packet');\n  callback && callback(new Error('Malformed packet'));\n};\n\nSSH2Stream.prototype._transform = function(chunk, encoding, callback, decomp) {\n  var skipDecrypt = false;\n  var decryptAuthMode = false;\n  var state = this._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var expect = instate.expect;\n  var decrypt = instate.decrypt;\n  var decompress = instate.decompress;\n  var chlen = chunk.length;\n  var chleft = 0;\n  var debug = this.debug;\n  var self = this;\n  var i = 0;\n  var p = i;\n  var blockLen;\n  var buffer;\n  var buf;\n  var r;\n\n  this.bytesReceived += chlen;\n\n  while (true) {\n    if (expect.type !== undefined) {\n      if (i >= chlen)\n        break;\n      if (expect.type === EXP_TYPE_BYTES) {\n        chleft = (chlen - i);\n        var pktLeft = (expect.buf.length - expect.ptr);\n        if (pktLeft <= chleft) {\n          chunk.copy(expect.buf, expect.ptr, i, i + pktLeft);\n          i += pktLeft;\n          buffer = expect.buf;\n          expect.buf = undefined;\n          expect.ptr = 0;\n          expect.type = undefined;\n        } else {\n          chunk.copy(expect.buf, expect.ptr, i);\n          expect.ptr += chleft;\n          i += chleft;\n        }\n        continue;\n      } else if (expect.type === EXP_TYPE_HEADER) {\n        i += instate.search.push(chunk);\n        if (expect.type !== undefined)\n          continue;\n      } else if (expect.type === EXP_TYPE_LF) {\n        if (++expect.ptr + 4 /* Account for \"SSH-\" */ > 255) {\n          this.reset();\n          debug('DEBUG: Parser: Identification string exceeded 255 characters');\n          return callback(new Error('Max identification string size exceeded'));\n        }\n        if (chunk[i] === 0x0A) {\n          expect.type = undefined;\n          if (p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          buffer = expect.buf;\n          expect.buf = undefined;\n          ++i;\n        } else {\n          if (++i === chlen && p < i) {\n            if (expect.buf === undefined)\n              expect.buf = chunk.toString('ascii', p, i);\n            else\n              expect.buf += chunk.toString('ascii', p, i);\n          }\n          continue;\n        }\n      }\n    }\n\n    if (instate.status === IN_INIT) {\n      if (!this.readable)\n        return callback();\n      if (this.server) {\n        // Retrieve what should be the start of the protocol version exchange\n        if (!buffer) {\n          debug('DEBUG: Parser: IN_INIT (waiting for identification begin)');\n          expectData(this, EXP_TYPE_BYTES, 4);\n        } else {\n          if (buffer[0] === 0x53       // S\n              && buffer[1] === 0x53    // S\n              && buffer[2] === 0x48    // H\n              && buffer[3] === 0x2D) { // -\n            instate.status = IN_GREETING;\n            debug('DEBUG: Parser: IN_INIT (waiting for rest of identification)');\n          } else {\n            this.reset();\n            debug('DEBUG: Parser: Bad identification start');\n            return callback(new Error('Bad identification start'));\n          }\n        }\n      } else {\n        debug('DEBUG: Parser: IN_INIT');\n        // Retrieve any bytes that may come before the protocol version exchange\n        var ss = instate.search = new StreamSearch(IDENT_PREFIX_BUFFER);\n        ss.on('info', function onInfo(matched, data, start, end) {\n          if (data) {\n            if (instate.greeting === undefined)\n              instate.greeting = data.toString('binary', start, end);\n            else\n              instate.greeting += data.toString('binary', start, end);\n          }\n          if (matched) {\n            expect.type = undefined;\n            instate.search.removeListener('info', onInfo);\n          }\n        });\n        ss.maxMatches = 1;\n        expectData(this, EXP_TYPE_HEADER);\n        instate.status = IN_GREETING;\n      }\n    } else if (instate.status === IN_GREETING) {\n      debug('DEBUG: Parser: IN_GREETING');\n      instate.search = undefined;\n      // Retrieve the identification bytes after the \"SSH-\" header\n      p = i;\n      expectData(this, EXP_TYPE_LF);\n      instate.status = IN_HEADER;\n    } else if (instate.status === IN_HEADER) {\n      debug('DEBUG: Parser: IN_HEADER');\n      if (buffer.charCodeAt(buffer.length - 1) === 13)\n        buffer = buffer.slice(0, -1);\n      var idxDash = buffer.indexOf('-');\n      var idxSpace = buffer.indexOf(' ');\n      var header = {\n        // RFC says greeting SHOULD be utf8\n        greeting: instate.greeting,\n        identRaw: 'SSH-' + buffer,\n        versions: {\n          protocol: buffer.substr(0, idxDash),\n          software: (idxSpace === -1\n                     ? buffer.substring(idxDash + 1)\n                     : buffer.substring(idxDash + 1, idxSpace))\n        },\n        comments: (idxSpace > -1 ? buffer.substring(idxSpace + 1) : undefined)\n      };\n      instate.greeting = undefined;\n\n      if (header.versions.protocol !== '1.99'\n          && header.versions.protocol !== '2.0') {\n        this.reset();\n        debug('DEBUG: Parser: protocol version not supported: '\n              + header.versions.protocol);\n        return callback(new Error('Protocol version not supported'));\n      } else\n        this.emit('header', header);\n\n      if (instate.status === IN_INIT) {\n        // We reset from an event handler, possibly due to an unsupported SSH\n        // protocol version?\n        return;\n      }\n\n      var identRaw = header.identRaw;\n      var software = header.versions.software;\n      this.debug('DEBUG: Remote ident: ' + inspect(identRaw));\n      for (var j = 0, rule; j < BUGGY_IMPLS_LEN; ++j) {\n        rule = BUGGY_IMPLS[j];\n        if (typeof rule[0] === 'string') {\n          if (software === rule[0])\n            this.remoteBugs |= rule[1];\n        } else if (rule[0].test(software))\n          this.remoteBugs |= rule[1];\n      }\n      instate.identRaw = identRaw;\n      // Adjust bytesReceived first otherwise it will have an incorrectly larger\n      // total when we call back into this function after completing KEXINIT\n      this.bytesReceived -= (chlen - i);\n      KEXINIT(this, function() {\n        if (i === chlen)\n          callback();\n        else\n          self._transform(chunk.slice(i), encoding, callback);\n      });\n      instate.status = IN_PACKETBEFORE;\n      return;\n    } else if (instate.status === IN_PACKETBEFORE) {\n      blockLen = (decrypt.instance ? decrypt.info.blockLen : 8);\n      debug('DEBUG: Parser: IN_PACKETBEFORE (expecting ' + blockLen + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(this, EXP_TYPE_BYTES, blockLen, decrypt.buf);\n      instate.status = IN_PACKET;\n    } else if (instate.status === IN_PACKET) {\n      debug('DEBUG: Parser: IN_PACKET');\n      if (decrypt.instance) {\n        decryptAuthMode = (decrypt.info.authLen > 0);\n        if (!decryptAuthMode)\n          buffer = decryptData(this, buffer);\n        blockLen = decrypt.info.blockLen;\n      } else {\n        decryptAuthMode = false;\n        blockLen = 8;\n      }\n\n      r = readInt(buffer, 0, this, callback);\n      if (r === false)\n        return;\n      var hmacInfo = instate.hmac.info;\n      var macSize;\n      if (hmacInfo)\n        macSize = hmacInfo.actualLen;\n      else\n        macSize = 0;\n      var fullPacketLen = r + 4 + macSize;\n      var maxPayloadLen = this.maxPacketSize;\n      if (decompress.instance) {\n        // Account for compressed payloads\n        // This formula is taken from dropbear which derives it from zlib's\n        // documentation. Explanation from dropbear:\n        /* For exact details see http://www.zlib.net/zlib_tech.html\n         * 5 bytes per 16kB block, plus 6 bytes for the stream.\n         * We might allocate 5 unnecessary bytes here if it's an\n         * exact multiple. */\n        maxPayloadLen += (((this.maxPacketSize / 16384) + 1) * 5 + 6);\n      }\n      if (r > maxPayloadLen\n          // TODO: Change 16 to \"MAX(16, decrypt.info.blockLen)\" when/if SSH2\n          // adopts 512-bit ciphers\n          || fullPacketLen < (16 + macSize)\n          || ((r + (decryptAuthMode ? 0 : 4)) % blockLen) !== 0) {\n        this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n        debug('DEBUG: Parser: Bad packet length (' + fullPacketLen + ')');\n        return callback(new Error('Bad packet length'));\n      }\n\n      instate.pktLen = r;\n      var remainLen = instate.pktLen + 4 - blockLen;\n      if (decryptAuthMode) {\n        decrypt.instance.setAAD(buffer.slice(0, 4));\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',remainLen:'\n              + remainLen);\n      } else {\n        instate.padLen = buffer[4];\n        debug('DEBUG: Parser: pktLen:'\n              + instate.pktLen\n              + ',padLen:'\n              + instate.padLen\n              + ',remainLen:'\n              + remainLen);\n      }\n      if (remainLen > 0) {\n        if (decryptAuthMode)\n          instate.pktExtra = buffer.slice(4);\n        else\n          instate.pktExtra = buffer.slice(5);\n        // Grab the rest of the packet\n        expectData(this, EXP_TYPE_BYTES, remainLen);\n        instate.status = IN_PACKETDATA;\n      } else if (remainLen < 0)\n        instate.status = IN_PACKETBEFORE;\n      else {\n        // Entire message fit into one block\n        skipDecrypt = true;\n        instate.status = IN_PACKETDATA;\n        continue;\n      }\n    } else if (instate.status === IN_PACKETDATA) {\n      debug('DEBUG: Parser: IN_PACKETDATA');\n      if (decrypt.instance) {\n        decryptAuthMode = (decrypt.info.authLen > 0);\n        if (!skipDecrypt) {\n          if (!decryptAuthMode)\n            buffer = decryptData(this, buffer);\n        } else {\n          skipDecrypt = false;\n        }\n      } else {\n        decryptAuthMode = false;\n        skipDecrypt = false;\n      }\n      var padStart = instate.pktLen - instate.padLen - 1;\n      // TODO: Allocate a Buffer once that is slightly larger than maxPacketSize\n      // (to accommodate for packet length field and MAC) and re-use that\n      // instead\n      if (instate.pktExtra) {\n        buf = Buffer.allocUnsafe(instate.pktExtra.length + buffer.length);\n        instate.pktExtra.copy(buf);\n        buffer.copy(buf, instate.pktExtra.length);\n        instate.payload = buf.slice(0, padStart);\n      } else {\n        // Entire message fit into one block\n        if (decryptAuthMode)\n          buf = buffer.slice(4);\n        else\n          buf = buffer.slice(5);\n        instate.payload = buffer.slice(5, 5 + padStart);\n      }\n      if (instate.hmac.info !== undefined) {\n        // Wait for hmac hash\n        var inHMACSize = decrypt.info.authLen || instate.hmac.info.actualLen;\n        debug('DEBUG: Parser: HMAC size:' + inHMACSize);\n        expectData(this, EXP_TYPE_BYTES, inHMACSize, instate.hmac.buf);\n        instate.status = IN_PACKETDATAVERIFY;\n        instate.packet = buf;\n      } else\n        instate.status = IN_PACKETDATAAFTER;\n      instate.pktExtra = undefined;\n      buf = undefined;\n    } else if (instate.status === IN_PACKETDATAVERIFY) {\n      debug('DEBUG: Parser: IN_PACKETDATAVERIFY');\n      // Verify packet data integrity\n      if (hmacVerify(this, buffer)) {\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Valid HMAC)');\n        instate.status = IN_PACKETDATAAFTER;\n        instate.packet = undefined;\n      } else {\n        this.reset();\n        debug('DEBUG: Parser: IN_PACKETDATAVERIFY (Invalid HMAC)');\n        return callback(new Error('Invalid HMAC'));\n      }\n    } else if (instate.status === IN_PACKETDATAAFTER) {\n      if (decompress.instance) {\n        if (!decomp) {\n          debug('DEBUG: Parser: Decompressing');\n          decompress.instance.write(instate.payload);\n          var decompBuf = [];\n          var decompBufLen = 0;\n          decompress.instance.on('readable', function() {\n            var buf;\n            while (buf = this.read()) {\n              decompBuf.push(buf);\n              decompBufLen += buf.length;\n            }\n          }).flush(Z_PARTIAL_FLUSH, function() {\n            decompress.instance.removeAllListeners('readable');\n            if (decompBuf.length === 1)\n              instate.payload = decompBuf[0];\n            else\n              instate.payload = Buffer.concat(decompBuf, decompBufLen);\n            decompBuf = null;\n            var nextSlice;\n            if (i === chlen)\n              nextSlice = EMPTY_BUFFER; // Avoid slicing a zero-length buffer\n            else\n              nextSlice = chunk.slice(i);\n            self._transform(nextSlice, encoding, callback, true);\n          });\n          return;\n        } else {\n          // Make sure we reset this after this first time in the loop,\n          // otherwise we could end up trying to interpret as-is another\n          // compressed packet that is within the same chunk\n          decomp = false;\n        }\n      }\n\n      this.emit('packet');\n\n      var ptype = instate.payload[0];\n\n      if (debug !== DEBUG_NOOP) {\n        var msgPacket = 'DEBUG: Parser: IN_PACKETDATAAFTER, packet: ';\n        var authMethod = state.authsQueue[0];\n        var msgPktType = null;\n\n        if (outstate.status === OUT_REKEYING\n            && !(ptype <= 4 || (ptype >= 20 && ptype <= 49)))\n          msgPacket += '(enqueued) ';\n\n        if (ptype === MESSAGE.KEXDH_INIT) {\n          switch (state.kex.type) {\n            case 'group':\n              msgPktType = 'KEXDH_INIT';\n              break;\n            case 'groupex':\n              msgPktType = 'KEXDH_GEX_REQUEST';\n              break;\n            default:\n              msgPktType = 'KEXECDH_INIT';\n          }\n        } else if (ptype === MESSAGE.KEXDH_REPLY) {\n          switch (state.kex.type) {\n            case 'group':\n              msgPktType = 'KEXDH_REPLY';\n              break;\n            case 'groupex':\n              msgPktType = 'KEXDH_GEX_GROUP';\n              break;\n            default:\n              msgPktType = 'KEXECDH_REPLY';\n          }\n        } else if (ptype === MESSAGE.KEXDH_GEX_GROUP) {\n          msgPktType = 'KEXDH_GEX_GROUP';\n        } else if (ptype === MESSAGE.KEXDH_GEX_REPLY) {\n          msgPktType = 'KEXDH_GEX_REPLY';\n        } else if (ptype === 60) {\n          if (authMethod === 'password')\n            msgPktType = 'USERAUTH_PASSWD_CHANGEREQ';\n          else if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_REQUEST';\n          else if (authMethod === 'publickey')\n            msgPktType = 'USERAUTH_PK_OK';\n          else\n            msgPktType = 'UNKNOWN PACKET 60';\n        } else if (ptype === 61) {\n          if (authMethod === 'keyboard-interactive')\n            msgPktType = 'USERAUTH_INFO_RESPONSE';\n          else\n            msgPktType = 'UNKNOWN PACKET 61';\n        }\n\n        if (msgPktType === null)\n          msgPktType = MESSAGE[ptype];\n\n        // Don't write debug output for messages we custom make in parsePacket()\n        if (ptype !== MESSAGE.CHANNEL_OPEN\n            && ptype !== MESSAGE.CHANNEL_REQUEST\n            && ptype !== MESSAGE.CHANNEL_SUCCESS\n            && ptype !== MESSAGE.CHANNEL_FAILURE\n            && ptype !== MESSAGE.CHANNEL_EOF\n            && ptype !== MESSAGE.CHANNEL_CLOSE\n            && ptype !== MESSAGE.CHANNEL_DATA\n            && ptype !== MESSAGE.CHANNEL_EXTENDED_DATA\n            && ptype !== MESSAGE.CHANNEL_WINDOW_ADJUST\n            && ptype !== MESSAGE.DISCONNECT\n            && ptype !== MESSAGE.USERAUTH_REQUEST\n            && ptype !== MESSAGE.GLOBAL_REQUEST)\n          debug(msgPacket + msgPktType);\n      }\n\n      // Only parse packet if we are not re-keying or the packet is not a\n      // transport layer packet needed for re-keying\n      if (outstate.status === OUT_READY\n          || ptype <= 4\n          || (ptype >= 20 && ptype <= 49)) {\n        if (parsePacket(this, callback) === false)\n          return;\n\n        if (instate.status === IN_INIT) {\n          // We were reset due to some error/disagreement ?\n          return;\n        }\n      } else if (outstate.status === OUT_REKEYING) {\n        if (instate.rekeyQueue.length === MAX_PACKETS_REKEYING) {\n          debug('DEBUG: Parser: Max incoming re-key queue length reached');\n          this.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n          return callback(\n            new Error('Incoming re-key queue length limit reached')\n          );\n        }\n\n        // Make sure to record the sequence number in case we need it later on\n        // when we drain the queue (e.g. unknown packet)\n        var seqno = instate.seqno;\n        if (++instate.seqno > MAX_SEQNO)\n          instate.seqno = 0;\n\n        instate.rekeyQueue.push([seqno, instate.payload]);\n      }\n\n      instate.status = IN_PACKETBEFORE;\n      instate.payload = undefined;\n    }\n    if (buffer !== undefined)\n      buffer = undefined;\n  }\n\n  callback();\n};\n\nSSH2Stream.prototype.reset = function(noend) {\n  if (this._state) {\n    var state = this._state;\n    state.incoming.status = IN_INIT;\n    state.outgoing.status = OUT_INIT;\n  } else {\n    this._state = {\n      authsQueue: [],\n      hostkeyFormat: undefined,\n      kex: undefined,\n\n      incoming: {\n        status: IN_INIT,\n        expectedPacket: undefined,\n        search: undefined,\n        greeting: undefined,\n        seqno: 0,\n        pktLen: undefined,\n        padLen: undefined,\n        pktExtra: undefined,\n        payload: undefined,\n        packet: undefined,\n        kexinit: undefined,\n        identRaw: undefined,\n        rekeyQueue: [],\n        ignoreNext: false,\n\n        expect: {\n          amount: undefined,\n          type: undefined,\n          ptr: 0,\n          buf: undefined\n        },\n\n        decrypt: {\n          instance: false,\n          info: undefined,\n          iv: undefined,\n          key: undefined,\n          buf: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          info: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        decompress: {\n          instance: false,\n          type: false\n        }\n      },\n\n      outgoing: {\n        status: OUT_INIT,\n        seqno: 0,\n        bufSeqno: Buffer.allocUnsafe(4),\n        rekeyQueue: [],\n        kexinit: undefined,\n        kexsecret: undefined,\n        pubkey: undefined,\n        exchangeHash: undefined,\n        sessionId: undefined,\n        sentNEWKEYS: false,\n\n        encrypt: {\n          instance: false,\n          info: undefined,\n          iv: undefined,\n          key: undefined,\n          type: undefined\n        },\n\n        hmac: {\n          info: undefined,\n          key: undefined,\n          buf: undefined,\n          type: false\n        },\n\n        compress: {\n          instance: false,\n          type: false,\n          queue: null\n        }\n      }\n    };\n  }\n  if (!noend) {\n    if (this.readable)\n      this.push(null);\n  }\n};\n\n// Common methods\n// Global\nSSH2Stream.prototype.disconnect = function(reason) {\n  /*\n    byte      SSH_MSG_DISCONNECT\n    uint32    reason code\n    string    description in ISO-10646 UTF-8 encoding\n    string    language tag\n  */\n  var buf = Buffer.alloc(1 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.DISCONNECT;\n\n  if (DISCONNECT_REASON[reason] === undefined)\n    reason = DISCONNECT_REASON.BY_APPLICATION;\n  writeUInt32BE(buf, reason, 1);\n\n  this.debug('DEBUG: Outgoing: Writing DISCONNECT ('\n             + DISCONNECT_REASON[reason]\n             + ')');\n  send(this, buf);\n  this.reset();\n\n  return false;\n};\nSSH2Stream.prototype.ping = function() {\n  this.debug('DEBUG: Outgoing: Writing ping (GLOBAL_REQUEST: keepalive@openssh.com)');\n  return send(this, PING_PACKET);\n};\nSSH2Stream.prototype.rekey = function() {\n  var status = this._state.outgoing.status;\n  if (status === OUT_REKEYING)\n    throw new Error('A re-key is already in progress');\n  else if (status !== OUT_READY)\n    throw new Error('Cannot re-key yet');\n\n  this.debug('DEBUG: Outgoing: Starting re-key');\n  return KEXINIT(this);\n};\n\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.requestSuccess = function(data) {\n  var buf;\n  if (Buffer.isBuffer(data)) {\n    buf = Buffer.allocUnsafe(1 + data.length);\n\n    buf[0] = MESSAGE.REQUEST_SUCCESS;\n\n    data.copy(buf, 1);\n  } else\n    buf = REQUEST_SUCCESS_PACKET;\n\n  this.debug('DEBUG: Outgoing: Writing REQUEST_SUCCESS');\n  return send(this, buf);\n};\nSSH2Stream.prototype.requestFailure = function() {\n  this.debug('DEBUG: Outgoing: Writing REQUEST_FAILURE');\n  return send(this, REQUEST_FAILURE_PACKET);\n};\nSSH2Stream.prototype.channelSuccess = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_SUCCESS;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_SUCCESS (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelFailure = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_FAILURE;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_FAILURE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelEOF = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_EOF;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EOF (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelClose = function(chan) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_CLOSE;\n\n  writeUInt32BE(buf, chan, 1);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_CLOSE (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelWindowAdjust = function(chan, amount) {\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_WINDOW_ADJUST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, amount, 5);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_WINDOW_ADJUST ('\n             + chan\n             + ', '\n             + amount\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelData = function(chan, data) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_DATA;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, dataLen, 5);\n  if (dataIsBuffer)\n    data.copy(buf, 9);\n  else\n    buf.write(data, 9, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelExtData = function(chan, data, type) {\n  var dataIsBuffer = Buffer.isBuffer(data);\n  var dataLen = (dataIsBuffer ? data.length : Buffer.byteLength(data));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + dataLen);\n\n  buf[0] = MESSAGE.CHANNEL_EXTENDED_DATA;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, type, 5);\n\n  writeUInt32BE(buf, dataLen, 9);\n  if (dataIsBuffer)\n    data.copy(buf, 13);\n  else\n    buf.write(data, 13, dataLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_EXTENDED_DATA (' + chan + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenConfirm = function(remoteChan, localChan,\n                                                   initWindow, maxPacket) {\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;\n\n  writeUInt32BE(buf, remoteChan, 1);\n\n  writeUInt32BE(buf, localChan, 5);\n\n  writeUInt32BE(buf, initWindow, 9);\n\n  writeUInt32BE(buf, maxPacket, 13);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_CONFIRMATION (r:'\n             + remoteChan\n             + ', l:'\n             + localChan\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.channelOpenFail = function(remoteChan, reason, desc,\n                                                lang) {\n  if (typeof desc !== 'string')\n    desc = '';\n  if (typeof lang !== 'string')\n    lang = '';\n\n  var descLen = Buffer.byteLength(desc);\n  var langLen = Buffer.byteLength(lang);\n  var p = 9;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + descLen + 4 + langLen);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN_FAILURE;\n\n  writeUInt32BE(buf, remoteChan, 1);\n\n  writeUInt32BE(buf, reason, 5);\n\n  writeUInt32BE(buf, descLen, p);\n  p += 4;\n  if (descLen) {\n    buf.write(desc, p, descLen, 'utf8');\n    p += descLen;\n  }\n\n  writeUInt32BE(buf, langLen, p);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN_FAILURE ('\n             + remoteChan\n             + ')');\n  return send(this, buf);\n};\n\n// Client-specific methods\n// Global\nSSH2Stream.prototype.service = function(svcName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var svcNameLen = Buffer.byteLength(svcName);\n  var buf = Buffer.allocUnsafe(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_REQUEST;\n\n  writeUInt32BE(buf, svcNameLen, 1);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_REQUEST (' + svcName + ')');\n  return send(this, buf);\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.tcpipForward = function(bindAddr, bindPort, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = Buffer.allocUnsafe(1 + 4 + 13 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 13, 1);\n  buf.write('tcpip-forward', 5, 13, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, addrlen, 19);\n  buf.write(bindAddr, 23, addrlen, 'ascii');\n\n  writeUInt32BE(buf, bindPort, 23 + addrlen);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.cancelTcpipForward = function(bindAddr, bindPort,\n                                                   wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var addrlen = Buffer.byteLength(bindAddr);\n  var buf = Buffer.allocUnsafe(1 + 4 + 20 + 1 + 4 + addrlen + 4);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 20, 1);\n  buf.write('cancel-tcpip-forward', 5, 20, 'ascii');\n\n  buf[25] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, addrlen, 26);\n  buf.write(bindAddr, 30, addrlen, 'ascii');\n\n  writeUInt32BE(buf, bindPort, 30 + addrlen);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-tcpip-forward)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_streamLocalForward = function(socketPath,\n                                                           wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 31 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 31, 1);\n  buf.write('streamlocal-forward@openssh.com', 5, 31, 'ascii');\n\n  buf[36] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, pathlen, 37);\n  buf.write(socketPath, 41, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_cancelStreamLocalForward = function(socketPath,\n                                                                 wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 38 + 1 + 4 + pathlen);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 38, 1);\n  buf.write('cancel-streamlocal-forward@openssh.com', 5, 38, 'ascii');\n\n  buf[43] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, pathlen, 44);\n  buf.write(socketPath, 48, pathlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.directTcpip = function(chan, initWindow, maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var srclen = Buffer.byteLength(cfg.srcIP);\n  var dstlen = Buffer.byteLength(cfg.dstIP);\n  var p = 29;\n  var buf = Buffer.allocUnsafe(1 + 4 + 12 + 4 + 4 + 4 + 4 + srclen + 4 + 4\n                               + dstlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 12, 1);\n  buf.write('direct-tcpip', 5, 12, 'ascii');\n\n  writeUInt32BE(buf, chan, 17);\n\n  writeUInt32BE(buf, initWindow, 21);\n\n  writeUInt32BE(buf, maxPacket, 25);\n\n  writeUInt32BE(buf, dstlen, p);\n  buf.write(cfg.dstIP, p += 4, dstlen, 'ascii');\n\n  writeUInt32BE(buf, cfg.dstPort, p += dstlen);\n\n  writeUInt32BE(buf, srclen, p += 4);\n  buf.write(cfg.srcIP, p += 4, srclen, 'ascii');\n\n  writeUInt32BE(buf, cfg.srcPort, p += srclen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_directStreamLocal = function(chan, initWindow,\n                                                          maxPacket, cfg) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var p = 47;\n  var buf = Buffer.allocUnsafe(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathlen + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 30, 1);\n  buf.write('direct-streamlocal@openssh.com', 5, 30, 'ascii');\n\n  writeUInt32BE(buf, chan, 35);\n\n  writeUInt32BE(buf, initWindow, 39);\n\n  writeUInt32BE(buf, maxPacket, 43);\n\n  writeUInt32BE(buf, pathlen, p);\n  buf.write(cfg.socketPath, p += 4, pathlen, 'utf8');\n\n  // reserved fields (string and uint32)\n  buf.fill(0, buf.length - 8);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', direct-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_noMoreSessions = function(wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var buf = Buffer.allocUnsafe(1 + 4 + 28 + 1);\n\n  buf[0] = MESSAGE.GLOBAL_REQUEST;\n\n  writeUInt32BE(buf, 28, 1);\n  buf.write('no-more-sessions@openssh.com', 5, 28, 'ascii');\n\n  buf[33] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing GLOBAL_REQUEST (no-more-sessions@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.session = function(chan, initWindow, maxPacket) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 7 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 7, 1);\n  buf.write('session', 5, 7, 'ascii');\n\n  writeUInt32BE(buf, chan, 12);\n\n  writeUInt32BE(buf, initWindow, 16);\n\n  writeUInt32BE(buf, maxPacket, 20);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', session)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.windowChange = function(chan, rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 13, 5);\n  buf.write('window-change', 9, 13, 'ascii');\n\n  buf[22] = 0;\n\n  writeUInt32BE(buf, cols, 23);\n\n  writeUInt32BE(buf, rows, 27);\n\n  writeUInt32BE(buf, width, 31);\n\n  writeUInt32BE(buf, height, 35);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', window-change)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.pty = function(chan, rows, cols, height,\n                                    width, term, modes, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  if (!term || !term.length)\n    term = 'vt100';\n  if (modes\n      && !Buffer.isBuffer(modes)\n      && !Array.isArray(modes)\n      && typeof modes === 'object')\n    modes = modesToBytes(modes);\n  if (!modes || !modes.length)\n    modes = NO_TERMINAL_MODES_BUFFER;\n\n  var termLen = term.length;\n  var modesLen = modes.length;\n  var p = 21;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4\n                               + 4 + modesLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 7, 5);\n  buf.write('pty-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, termLen, 17);\n  buf.write(term, 21, termLen, 'utf8');\n\n  writeUInt32BE(buf, cols, p += termLen);\n\n  writeUInt32BE(buf, rows, p += 4);\n\n  writeUInt32BE(buf, width, p += 4);\n\n  writeUInt32BE(buf, height, p += 4);\n\n  writeUInt32BE(buf, modesLen, p += 4);\n  p += 4;\n  if (Array.isArray(modes)) {\n    for (var i = 0; i < modesLen; ++i)\n      buf[p++] = modes[i];\n  } else if (Buffer.isBuffer(modes)) {\n    modes.copy(buf, p);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', pty-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.shell = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 5 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 5, 5);\n  buf.write('shell', 9, 5, 'ascii');\n\n  buf[14] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', shell)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exec = function(chan, cmd, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var cmdlen = (Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 4 + 1 + 4 + cmdlen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 4, 5);\n  buf.write('exec', 9, 4, 'ascii');\n\n  buf[13] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, cmdlen, 14);\n  if (Buffer.isBuffer(cmd))\n    cmd.copy(buf, 18);\n  else\n    buf.write(cmd, 18, cmdlen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exec)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.signal = function(chan, signal) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  signal = signal.toUpperCase();\n  if (signal.slice(0, 3) === 'SIG')\n    signal = signal.substring(3);\n\n  if (SIGNALS.indexOf(signal) === -1)\n    throw new Error('Invalid signal: ' + signal);\n\n  var signalLen = signal.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 6 + 1 + 4 + signalLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 6, 5);\n  buf.write('signal', 9, 6, 'ascii');\n\n  buf[15] = 0;\n\n  writeUInt32BE(buf, signalLen, 16);\n  buf.write(signal, 20, signalLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', signal)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.env = function(chan, key, val, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var keyLen = Buffer.byteLength(key);\n  var valLen = (Buffer.isBuffer(val) ? val.length : Buffer.byteLength(val));\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 3, 5);\n  buf.write('env', 9, 3, 'ascii');\n\n  buf[12] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, keyLen, 13);\n  buf.write(key, 17, keyLen, 'ascii');\n\n  writeUInt32BE(buf, valLen, 17 + keyLen);\n  if (Buffer.isBuffer(val))\n    val.copy(buf, 17 + keyLen + 4);\n  else\n    buf.write(val, 17 + keyLen + 4, valLen, 'utf8');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', env)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11Forward = function(chan, cfg, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var protolen = Buffer.byteLength(cfg.protocol);\n  var cookielen = Buffer.byteLength(cfg.cookie);\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 7 + 1 + 1 + 4 + protolen + 4\n                               + cookielen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 7, 5);\n  buf.write('x11-req', 9, 7, 'ascii');\n\n  buf[16] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  buf[17] = (cfg.single ? 1 : 0);\n\n  writeUInt32BE(buf, protolen, 18);\n  var bp = 22;\n  if (Buffer.isBuffer(cfg.protocol))\n    cfg.protocol.copy(buf, bp);\n  else\n    buf.write(cfg.protocol, bp, protolen, 'utf8');\n  bp += protolen;\n\n  writeUInt32BE(buf, cookielen, bp);\n  bp += 4;\n  if (Buffer.isBuffer(cfg.cookie))\n    cfg.cookie.copy(buf, bp);\n  else\n    buf.write(cfg.cookie, bp, cookielen, 'binary');\n  bp += cookielen;\n\n  writeUInt32BE(buf, (cfg.screen || 0), bp);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', x11-req)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.subsystem = function(chan, name, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 9 + 1 + 4 + nameLen);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 9, 5);\n  buf.write('subsystem', 9, 9, 'ascii');\n\n  buf[18] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  writeUInt32BE(buf, nameLen, 19);\n  buf.write(name, 23, nameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', subsystem: '\n             + name\n             + ')');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_agentForward = function(chan, wantReply) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 26 + 1);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 26, 5);\n  buf.write('auth-agent-req@openssh.com', 9, 26, 'ascii');\n\n  buf[35] = (wantReply === undefined || wantReply === true ? 1 : 0);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', auth-agent-req@openssh.com)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authPassword = function(username, password) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var passLen = Buffer.byteLength(password);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 8 // \"password\"\n                               + 1\n                               + 4 + passLen);\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 8, p += 14);\n  buf.write('password', p += 4, 8, 'ascii');\n\n  buf[p += 8] = 0;\n\n  writeUInt32BE(buf, passLen, ++p);\n  buf.write(password, p += 4, passLen, 'utf8');\n\n  this._state.authsQueue.push('password');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (password)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPK = function(username, pubKey, cbSign) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var keyType;\n\n  if (typeof pubKey.getPublicSSH === 'function') {\n    keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n  } else {\n    keyType = pubKey.toString('ascii',\n                              4,\n                              4 + readUInt32BE(pubKey, 0));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(keyType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var p = 0;\n  var buf = Buffer.allocUnsafe((cbSign ? 4 + sesLen : 0)\n                               + 1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 9 // \"publickey\"\n                               + 1\n                               + 4 + algoLen\n                               + 4 + pubKeyLen\n                              );\n\n  if (cbSign) {\n    writeUInt32BE(buf, sesLen, p);\n    outstate.sessionId.copy(buf, p += 4);\n    buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n  } else {\n    buf[p] = MESSAGE.USERAUTH_REQUEST;\n  }\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 9, p += 14);\n  buf.write('publickey', p += 4, 9, 'ascii');\n\n  buf[p += 9] = (cbSign ? 1 : 0);\n\n  writeUInt32BE(buf, algoLen, ++p);\n  buf.write(keyType, p += 4, algoLen, 'ascii');\n\n  writeUInt32BE(buf, pubKeyLen, p += algoLen);\n  pubKey.copy(buf, p += 4);\n\n  if (!cbSign) {\n    this._state.authsQueue.push('publickey');\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey -- check)');\n    return send(this, buf);\n  }\n\n  cbSign(buf, function(signature) {\n    signature = convertSignature(signature, keyType);\n    if (signature === false)\n      throw new Error('Error while converting handshake signature');\n\n    var sigLen = signature.length;\n    var sigbuf = Buffer.allocUnsafe(1\n                                    + 4 + userLen\n                                    + 4 + 14 // \"ssh-connection\"\n                                    + 4 + 9 // \"publickey\"\n                                    + 1\n                                    + 4 + algoLen\n                                    + 4 + pubKeyLen\n                                    + 4 // 4 + algoLen + 4 + sigLen\n                                    + 4 + algoLen\n                                    + 4 + sigLen);\n\n    p = 0;\n\n    sigbuf[p] = MESSAGE.USERAUTH_REQUEST;\n\n    writeUInt32BE(sigbuf, userLen, ++p);\n    sigbuf.write(username, p += 4, userLen, 'utf8');\n\n    writeUInt32BE(sigbuf, 14, p += userLen);\n    sigbuf.write('ssh-connection', p += 4, 14, 'ascii');\n\n    writeUInt32BE(sigbuf, 9, p += 14);\n    sigbuf.write('publickey', p += 4, 9, 'ascii');\n\n    sigbuf[p += 9] = 1;\n\n    writeUInt32BE(sigbuf, algoLen, ++p);\n    sigbuf.write(keyType, p += 4, algoLen, 'ascii');\n\n    writeUInt32BE(sigbuf, pubKeyLen, p += algoLen);\n    pubKey.copy(sigbuf, p += 4);\n    writeUInt32BE(sigbuf, 4 + algoLen + 4 + sigLen, p += pubKeyLen);\n    writeUInt32BE(sigbuf, algoLen, p += 4);\n    sigbuf.write(keyType, p += 4, algoLen, 'ascii');\n    writeUInt32BE(sigbuf, sigLen, p += algoLen);\n    signature.copy(sigbuf, p += 4);\n\n    // Servers shouldn't send packet type 60 in response to signed publickey\n    // attempts, but if they do, interpret as type 60.\n    self._state.authsQueue.push('publickey');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (publickey)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authHostbased = function(username, pubKey, hostname,\n                                              userlocal, cbSign) {\n  // TODO: Make DRY by sharing similar code with authPK()\n\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var self = this;\n  var outstate = this._state.outgoing;\n  var keyType;\n\n  if (typeof pubKey.getPublicSSH === 'function') {\n    keyType = pubKey.type;\n    pubKey = pubKey.getPublicSSH();\n  } else {\n    keyType = pubKey.toString('ascii',\n                              4,\n                              4 + readUInt32BE(pubKey, 0));\n  }\n\n  var userLen = Buffer.byteLength(username);\n  var algoLen = Buffer.byteLength(keyType);\n  var pubKeyLen = pubKey.length;\n  var sesLen = outstate.sessionId.length;\n  var hostnameLen = Buffer.byteLength(hostname);\n  var userlocalLen = Buffer.byteLength(userlocal);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(4 + sesLen\n                               + 1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 9 // \"hostbased\"\n                               + 4 + algoLen\n                               + 4 + pubKeyLen\n                               + 4 + hostnameLen\n                               + 4 + userlocalLen\n                              );\n\n  writeUInt32BE(buf, sesLen, p);\n  outstate.sessionId.copy(buf, p += 4);\n\n  buf[p += sesLen] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 9, p += 14);\n  buf.write('hostbased', p += 4, 9, 'ascii');\n\n  writeUInt32BE(buf, algoLen, p += 9);\n  buf.write(keyType, p += 4, algoLen, 'ascii');\n\n  writeUInt32BE(buf, pubKeyLen, p += algoLen);\n  pubKey.copy(buf, p += 4);\n\n  writeUInt32BE(buf, hostnameLen, p += pubKeyLen);\n  buf.write(hostname, p += 4, hostnameLen, 'ascii');\n\n  writeUInt32BE(buf, userlocalLen, p += hostnameLen);\n  buf.write(userlocal, p += 4, userlocalLen, 'utf8');\n\n  cbSign(buf, function(signature) {\n    signature = convertSignature(signature, keyType);\n    if (signature === false)\n      throw new Error('Error while converting handshake signature');\n\n    var sigLen = signature.length;\n    var sigbuf = Buffer.allocUnsafe((buf.length - sesLen) + sigLen);\n\n    buf.copy(sigbuf, 0, 4 + sesLen);\n    writeUInt32BE(sigbuf, sigLen, sigbuf.length - sigLen - 4);\n    signature.copy(sigbuf, sigbuf.length - sigLen);\n\n    self._state.authsQueue.push('hostbased');\n    self.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (hostbased)');\n    return send(self, sigbuf);\n  });\n  return true;\n};\nSSH2Stream.prototype.authKeyboard = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 20 // \"keyboard-interactive\"\n                               + 4 // no language set\n                               + 4 // no submethods\n                              );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 20, p += 14);\n  buf.write('keyboard-interactive', p += 4, 20, 'ascii');\n\n  writeUInt32BE(buf, 0, p += 20);\n\n  writeUInt32BE(buf, 0, p += 4);\n\n  this._state.authsQueue.push('keyboard-interactive');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (keyboard-interactive)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authNone = function(username) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var userLen = Buffer.byteLength(username);\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + userLen\n                               + 4 + 14 // \"ssh-connection\"\n                               + 4 + 4 // \"none\"\n                              );\n\n  buf[p] = MESSAGE.USERAUTH_REQUEST;\n\n  writeUInt32BE(buf, userLen, ++p);\n  buf.write(username, p += 4, userLen, 'utf8');\n\n  writeUInt32BE(buf, 14, p += userLen);\n  buf.write('ssh-connection', p += 4, 14, 'ascii');\n\n  writeUInt32BE(buf, 4, p += 14);\n  buf.write('none', p += 4, 4, 'ascii');\n\n  this._state.authsQueue.push('none');\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_REQUEST (none)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoRes = function(responses) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  var responsesLen = 0;\n  var p = 0;\n  var resLen;\n  var len;\n  var i;\n\n  if (responses) {\n    for (i = 0, len = responses.length; i < len; ++i)\n      responsesLen += 4 + Buffer.byteLength(responses[i]);\n  }\n  var buf = Buffer.allocUnsafe(1 + 4 + responsesLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_RESPONSE;\n\n  writeUInt32BE(buf, responses ? responses.length : 0, p);\n  if (responses) {\n    p += 4;\n    for (i = 0, len = responses.length; i < len; ++i) {\n      resLen = Buffer.byteLength(responses[i]);\n      writeUInt32BE(buf, resLen, p);\n      p += 4;\n      if (resLen) {\n        buf.write(responses[i], p, resLen, 'utf8');\n        p += resLen;\n      }\n    }\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_RESPONSE');\n  return send(this, buf);\n};\n\n// Server-specific methods\n// Global\nSSH2Stream.prototype.serviceAccept = function(svcName) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var svcNameLen = svcName.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + svcNameLen);\n\n  buf[0] = MESSAGE.SERVICE_ACCEPT;\n\n  writeUInt32BE(buf, svcNameLen, 1);\n  buf.write(svcName, 5, svcNameLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing SERVICE_ACCEPT (' + svcName + ')');\n  send(this, buf);\n\n  if (this.server && this.banner && svcName === 'ssh-userauth') {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var bannerLen = Buffer.byteLength(this.banner);\n    var packetLen = 1 + 4 + bannerLen + 4;\n    var packet = Buffer.allocUnsafe(packetLen);\n    packet[0] = MESSAGE.USERAUTH_BANNER;\n    writeUInt32BE(packet, bannerLen, 1);\n    packet.write(this.banner, 5, bannerLen, 'utf8');\n    packet.fill(0, packetLen - 4); // Empty language tag\n    this.debug('DEBUG: Outgoing: Writing USERAUTH_BANNER');\n    send(this, packet);\n    this.banner = undefined; // Prevent banner from being displayed again\n  }\n};\n// 'ssh-connection' service-specific\nSSH2Stream.prototype.forwardedTcpip = function(chan, initWindow, maxPacket,\n                                               cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var boundAddrLen = Buffer.byteLength(cfg.boundAddr);\n  var remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);\n  var p = 36 + boundAddrLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4\n                               + remoteAddrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 15, 1);\n  buf.write('forwarded-tcpip', 5, 15, 'ascii');\n\n  writeUInt32BE(buf, chan, 20);\n\n  writeUInt32BE(buf, initWindow, 24);\n\n  writeUInt32BE(buf, maxPacket, 28);\n\n  writeUInt32BE(buf, boundAddrLen, 32);\n  buf.write(cfg.boundAddr, 36, boundAddrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.boundPort, p);\n\n  writeUInt32BE(buf, remoteAddrLen, p += 4);\n  buf.write(cfg.remoteAddr, p += 4, remoteAddrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.remotePort, p += remoteAddrLen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-tcpip)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.x11 = function(chan, initWindow, maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var addrLen = Buffer.byteLength(cfg.originAddr);\n  var p = 24 + addrLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 3, 1);\n  buf.write('x11', 5, 3, 'ascii');\n\n  writeUInt32BE(buf, chan, 8);\n\n  writeUInt32BE(buf, initWindow, 12);\n\n  writeUInt32BE(buf, maxPacket, 16);\n\n  writeUInt32BE(buf, addrLen, 20);\n  buf.write(cfg.originAddr, 24, addrLen, 'ascii');\n\n  writeUInt32BE(buf, cfg.originPort, p);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', x11)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_authAgent = function(chan, initWindow, maxPacket) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var buf = Buffer.allocUnsafe(1 + 4 + 22 + 4 + 4 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 22, 1);\n  buf.write('auth-agent@openssh.com', 5, 22, 'ascii');\n\n  writeUInt32BE(buf, chan, 27);\n\n  writeUInt32BE(buf, initWindow, 31);\n\n  writeUInt32BE(buf, maxPacket, 35);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', auth-agent@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.openssh_forwardedStreamLocal = function(chan, initWindow,\n                                                             maxPacket, cfg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var pathlen = Buffer.byteLength(cfg.socketPath);\n  var buf = Buffer.allocUnsafe(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathlen + 4);\n\n  buf[0] = MESSAGE.CHANNEL_OPEN;\n\n  writeUInt32BE(buf, 33, 1);\n  buf.write('forwarded-streamlocal@openssh.com', 5, 33, 'ascii');\n\n  writeUInt32BE(buf, chan, 38);\n\n  writeUInt32BE(buf, initWindow, 42);\n\n  writeUInt32BE(buf, maxPacket, 46);\n\n  writeUInt32BE(buf, pathlen, 50);\n  buf.write(cfg.socketPath, 54, pathlen, 'utf8');\n\n  writeUInt32BE(buf, 0, 54 + pathlen);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_OPEN ('\n             + chan\n             + ', forwarded-streamlocal@openssh.com)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitStatus = function(chan, status) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 11 + 1 + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 11, 5);\n  buf.write('exit-status', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  writeUInt32BE(buf, status, 21);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-status)');\n  return send(this, buf);\n};\nSSH2Stream.prototype.exitSignal = function(chan, name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  // Does not consume window space\n  var nameLen = Buffer.byteLength(name);\n  var msgLen = (msg ? Buffer.byteLength(msg) : 0);\n  var p = 25 + nameLen;\n  var buf = Buffer.allocUnsafe(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen\n                               + 4);\n\n  buf[0] = MESSAGE.CHANNEL_REQUEST;\n\n  writeUInt32BE(buf, chan, 1);\n\n  writeUInt32BE(buf, 11, 5);\n  buf.write('exit-signal', 9, 11, 'ascii');\n\n  buf[20] = 0;\n\n  writeUInt32BE(buf, nameLen, 21);\n  buf.write(name, 25, nameLen, 'utf8');\n\n  buf[p++] = (coreDumped ? 1 : 0);\n\n  writeUInt32BE(buf, msgLen, p);\n  p += 4;\n  if (msgLen) {\n    buf.write(msg, p, msgLen, 'utf8');\n    p += msgLen;\n  }\n\n  writeUInt32BE(buf, 0, p);\n\n  this.debug('DEBUG: Outgoing: Writing CHANNEL_REQUEST ('\n             + chan\n             + ', exit-signal)');\n  return send(this, buf);\n};\n// 'ssh-userauth' service-specific\nSSH2Stream.prototype.authFailure = function(authMethods, isPartial) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var methods;\n\n  if (typeof authMethods === 'boolean') {\n    isPartial = authMethods;\n    authMethods = undefined;\n  }\n\n  if (authMethods) {\n    methods = [];\n    for (var i = 0, len = authMethods.length; i < len; ++i) {\n      if (authMethods[i].toLowerCase() === 'none')\n        continue;\n      methods.push(authMethods[i]);\n    }\n    methods = methods.join(',');\n  } else\n    methods = '';\n\n  var methodsLen = methods.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + methodsLen + 1);\n\n  buf[0] = MESSAGE.USERAUTH_FAILURE;\n\n  writeUInt32BE(buf, methodsLen, 1);\n  buf.write(methods, 5, methodsLen, 'ascii');\n\n  buf[5 + methodsLen] = (isPartial === true ? 1 : 0);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_FAILURE');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authSuccess = function() {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length)\n    throw new Error('No auth in progress');\n\n  var state = this._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  state.authsQueue.shift();\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_SUCCESS');\n  var ret = send(this, USERAUTH_SUCCESS_PACKET);\n\n  if (outstate.compress.type === 'zlib@openssh.com') {\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    outstate.compress.queue = [];\n  }\n  if (instate.decompress.type === 'zlib@openssh.com')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n\n  return ret;\n};\nSSH2Stream.prototype.authPKOK = function(keyAlgo, key) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var authsQueue = this._state.authsQueue;\n  if (!authsQueue.length || authsQueue[0] !== 'publickey')\n    throw new Error('\"publickey\" auth not in progress');\n\n  var keyAlgoLen = keyAlgo.length;\n  var keyLen = key.length;\n  var buf = Buffer.allocUnsafe(1 + 4 + keyAlgoLen + 4 + keyLen);\n\n  buf[0] = MESSAGE.USERAUTH_PK_OK;\n\n  writeUInt32BE(buf, keyAlgoLen, 1);\n  buf.write(keyAlgo, 5, keyAlgoLen, 'ascii');\n\n  writeUInt32BE(buf, keyLen, 5 + keyAlgoLen);\n  key.copy(buf, 5 + keyAlgoLen + 4);\n\n  this._state.authsQueue.shift();\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PK_OK');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authPasswdChg = function(prompt, lang) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptLen = Buffer.byteLength(prompt);\n  var langLen = lang ? lang.length : 0;\n  var p = 0;\n  var buf = Buffer.allocUnsafe(1 + 4 + promptLen + 4 + langLen);\n\n  buf[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;\n\n  writeUInt32BE(buf, promptLen, ++p);\n  buf.write(prompt, p += 4, promptLen, 'utf8');\n\n  writeUInt32BE(buf, langLen, p += promptLen);\n  if (langLen)\n    buf.write(lang, p += 4, langLen, 'ascii');\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_PASSWD_CHANGEREQ');\n  return send(this, buf);\n};\nSSH2Stream.prototype.authInfoReq = function(name, instructions, prompts) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  var promptsLen = 0;\n  var nameLen = name ? Buffer.byteLength(name) : 0;\n  var instrLen = instructions ? Buffer.byteLength(instructions) : 0;\n  var p = 0;\n  var promptLen;\n  var prompt;\n  var len;\n  var i;\n\n  for (i = 0, len = prompts.length; i < len; ++i)\n    promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;\n  var buf = Buffer.allocUnsafe(1 + 4 + nameLen + 4 + instrLen + 4 + 4\n                               + promptsLen);\n\n  buf[p++] = MESSAGE.USERAUTH_INFO_REQUEST;\n\n  writeUInt32BE(buf, nameLen, p);\n  p += 4;\n  if (name) {\n    buf.write(name, p, nameLen, 'utf8');\n    p += nameLen;\n  }\n\n  writeUInt32BE(buf, instrLen, p);\n  p += 4;\n  if (instructions) {\n    buf.write(instructions, p, instrLen, 'utf8');\n    p += instrLen;\n  }\n\n  writeUInt32BE(buf, 0, p);\n  p += 4;\n\n  writeUInt32BE(buf, prompts.length, p);\n  p += 4;\n  for (i = 0, len = prompts.length; i < len; ++i) {\n    prompt = prompts[i];\n    promptLen = Buffer.byteLength(prompt.prompt);\n    writeUInt32BE(buf, promptLen, p);\n    p += 4;\n    if (promptLen) {\n      buf.write(prompt.prompt, p, promptLen, 'utf8');\n      p += promptLen;\n    }\n    buf[p++] = (prompt.echo ? 1 : 0);\n  }\n\n  this.debug('DEBUG: Outgoing: Writing USERAUTH_INFO_REQUEST');\n  return send(this, buf);\n};\n\n// Shared incoming/parser functions\nfunction onDISCONNECT(self, reason, code, desc, lang) { // Client/Server\n  if (code !== DISCONNECT_REASON.BY_APPLICATION) {\n    var err = new Error(desc || reason);\n    err.code = code;\n    self.emit('error', err);\n  }\n  self.reset();\n}\n\nfunction onKEXINIT(self, init, firstFollows) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  if (outstate.status === OUT_READY) {\n    self.debug('DEBUG: Received re-key request');\n    outstate.status = OUT_REKEYING;\n    outstate.kexinit = undefined;\n    KEXINIT(self, check);\n  } else {\n    check();\n  }\n\n  function check() {\n    if (check_KEXINIT(self, init, firstFollows) === true) {\n      if (!self.server) {\n        if (state.kex.type === 'groupex')\n          KEXDH_GEX_REQ(self);\n        else\n          KEXDH_INIT(self);\n      } else {\n        state.incoming.expectedPacket = state.kex.pktInit;\n      }\n    }\n  }\n}\n\nfunction check_KEXINIT(self, init, firstFollows) {\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var serverList;\n  var clientList;\n  var val;\n  var len;\n  var i;\n\n  debug('DEBUG: Comparing KEXINITs ...');\n\n  var algos = self.config.algorithms;\n\n  var kexList = algos.kex;\n  if (self.remoteBugs & BUGS.BAD_DHGEX) {\n    var copied = false;\n    for (var j = kexList.length - 1; j >= 0; --j) {\n      if (kexList[j].indexOf('group-exchange') !== -1) {\n        if (!copied) {\n          kexList = kexList.slice();\n          copied = true;\n        }\n        kexList.splice(j, 1);\n      }\n    }\n  }\n\n  debug('DEBUG: (local) KEX algorithms: ' + kexList);\n  debug('DEBUG: (remote) KEX algorithms: ' + init.algorithms.kex);\n  if (self.server) {\n    serverList = kexList;\n    clientList = init.algorithms.kex;\n  } else {\n    serverList = init.algorithms.kex;\n    clientList = kexList;\n  }\n  // Check for agreeable key exchange algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching key exchange algorithm');\n    var err = new Error('Handshake failed: no matching key exchange algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var kex_algorithm = clientList[i];\n  debug('DEBUG: KEX algorithm: ' + kex_algorithm);\n  if (firstFollows\n      && (!init.algorithms.kex.length\n          || kex_algorithm !== init.algorithms.kex[0])) {\n    // Ignore next incoming packet, it was a wrong first guess at KEX algorithm\n    instate.ignoreNext = true;\n  }\n\n  debug('DEBUG: (local) Host key formats: ' + algos.serverHostKey);\n  debug('DEBUG: (remote) Host key formats: ' + init.algorithms.srvHostKey);\n  if (self.server) {\n    serverList = algos.serverHostKey;\n    clientList = init.algorithms.srvHostKey;\n  } else {\n    serverList = init.algorithms.srvHostKey;\n    clientList = algos.serverHostKey;\n  }\n  // Check for agreeable server host key format\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching host key format');\n    var err = new Error('Handshake failed: no matching host key format');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  state.hostkeyFormat = clientList[i];\n  debug('DEBUG: Host key format: ' + state.hostkeyFormat);\n\n  debug('DEBUG: (local) Client->Server ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Client->Server ciphers: '\n        + init.algorithms.cs.encrypt);\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.cs.encrypt;\n  } else {\n    serverList = init.algorithms.cs.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable client->server cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server cipher');\n    var err = new Error('Handshake failed: no matching client->server cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decrypt.type = clientList[i];\n  else\n    val = outstate.encrypt.type = clientList[i];\n  debug('DEBUG: Client->Server Cipher: ' + val);\n\n  debug('DEBUG: (local) Server->Client ciphers: ' + algos.cipher);\n  debug('DEBUG: (remote) Server->Client ciphers: '\n        + (init.algorithms.sc.encrypt));\n  if (self.server) {\n    serverList = algos.cipher;\n    clientList = init.algorithms.sc.encrypt;\n  } else {\n    serverList = init.algorithms.sc.encrypt;\n    clientList = algos.cipher;\n  }\n  // Check for agreeable server->client cipher\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client cipher');\n    var err = new Error('Handshake failed: no matching server->client cipher');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.encrypt.type = clientList[i];\n  else\n    val = instate.decrypt.type = clientList[i];\n  debug('DEBUG: Server->Client Cipher: ' + val);\n\n  debug('DEBUG: (local) Client->Server HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Client->Server HMAC algorithms: '\n        + init.algorithms.cs.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.cs.mac;\n  } else {\n    serverList = init.algorithms.cs.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable client->server hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server HMAC algorithm');\n    var err = new Error('Handshake failed: no matching client->server HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.hmac.type = clientList[i];\n  else\n    val = outstate.hmac.type = clientList[i];\n  debug('DEBUG: Client->Server HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client HMAC algorithms: ' + algos.hmac);\n  debug('DEBUG: (remote) Server->Client HMAC algorithms: '\n        + init.algorithms.sc.mac);\n  if (self.server) {\n    serverList = algos.hmac;\n    clientList = init.algorithms.sc.mac;\n  } else {\n    serverList = init.algorithms.sc.mac;\n    clientList = algos.hmac;\n  }\n  // Check for agreeable server->client hmac algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client HMAC algorithm');\n    var err = new Error('Handshake failed: no matching server->client HMAC');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.hmac.type = clientList[i];\n  else\n    val = instate.hmac.type = clientList[i];\n  debug('DEBUG: Server->Client HMAC algorithm: ' + val);\n\n  debug('DEBUG: (local) Client->Server compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Client->Server compression algorithms: '\n        + init.algorithms.cs.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.cs.compress;\n  } else {\n    serverList = init.algorithms.cs.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable client->server compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Client->Server compression algorithm');\n    var err = new Error('Handshake failed: no matching client->server '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = instate.decompress.type = clientList[i];\n  else\n    val = outstate.compress.type = clientList[i];\n  debug('DEBUG: Client->Server compression algorithm: ' + val);\n\n  debug('DEBUG: (local) Server->Client compression algorithms: '\n        + algos.compress);\n  debug('DEBUG: (remote) Server->Client compression algorithms: '\n        + init.algorithms.sc.compress);\n  if (self.server) {\n    serverList = algos.compress;\n    clientList = init.algorithms.sc.compress;\n  } else {\n    serverList = init.algorithms.sc.compress;\n    clientList = algos.compress;\n  }\n  // Check for agreeable server->client compression algorithm\n  for (i = 0, len = clientList.length;\n       i < len && serverList.indexOf(clientList[i]) === -1;\n       ++i);\n  if (i === len) {\n    // No suitable match found!\n    debug('DEBUG: No matching Server->Client compression algorithm');\n    var err = new Error('Handshake failed: no matching server->client '\n                        + 'compression algorithm');\n    err.level = 'handshake';\n    self.emit('error', err);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  if (self.server)\n    val = outstate.compress.type = clientList[i];\n  else\n    val = instate.decompress.type = clientList[i];\n  debug('DEBUG: Server->Client compression algorithm: ' + val);\n\n  state.kex = new KeyExchange(kex_algorithm);\n  state.kex.generateKeys();\n  outstate.pubkey = state.kex.getPublicKey();\n\n  return true;\n}\n\nfunction onKEXDH_GEX_GROUP(self, prime, gen) {\n  var state = self._state;\n  var outstate = state.outgoing;\n\n  state.kex.setDHParams(prime, gen);\n  state.kex.generateKeys();\n  outstate.pubkey = state.kex.getPublicKey();\n\n  KEXDH_INIT(self);\n}\n\nfunction onKEXDH_INIT(self, e) { // Server\n  KEXDH_REPLY(self, e);\n}\n\nfunction onKEXDH_REPLY(self, info, verifiedHost) { // Client\n  var state = self._state;\n  var instate = state.incoming;\n  var outstate = state.outgoing;\n  var debug = self.debug;\n  var len;\n  var i;\n\n  if (verifiedHost === undefined) {\n    instate.expectedPacket = 'NEWKEYS';\n    outstate.sentNEWKEYS = false;\n\n    debug('DEBUG: Checking host key format');\n    // Ensure all host key formats agree\n    var hostkey_format = readString(info.hostkey, 0, 'ascii', self);\n    if (hostkey_format === false)\n      return false;\n    if (info.hostkey_format !== state.hostkeyFormat\n        || info.hostkey_format !== hostkey_format) {\n      // Expected and actual server host key format do not match!\n      debug('DEBUG: Host key format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: host key format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n\n    debug('DEBUG: Checking signature format');\n    // Ensure signature formats agree\n    var sig_format = readString(info.sig, 0, 'ascii', self);\n    if (sig_format === false)\n      return false;\n    if (info.sig_format !== sig_format) {\n      debug('DEBUG: Signature format mismatch');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: signature format mismatch');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  // Verify the host fingerprint first if needed\n  if (outstate.status === OUT_INIT) {\n    if (verifiedHost === undefined) {\n      debug('DEBUG: Verifying host fingerprint');\n      var sync = true;\n      var emitted = self.emit('fingerprint', info.hostkey, function(permitted) {\n        // Prevent multiple calls to this callback\n        if (verifiedHost !== undefined)\n          return;\n        verifiedHost = !!permitted;\n        if (!sync) {\n          // Continue execution by re-entry\n          onKEXDH_REPLY(self, info, verifiedHost);\n        }\n      });\n      sync = false;\n      // Support async calling of verification callback\n      if (emitted && verifiedHost === undefined)\n        return;\n    }\n    if (verifiedHost === undefined)\n      debug('DEBUG: Host accepted by default (no verification)');\n    else if (verifiedHost === true)\n      debug('DEBUG: Host accepted (verified)');\n    else {\n      debug('DEBUG: Host denied via fingerprint verification');\n      self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n      self.reset();\n      var err = new Error('Handshake failed: '\n                          + 'host fingerprint verification failed');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    }\n  }\n\n  info.pubkey = state.kex.convertPublicKey(info.pubkey);\n\n  info.secret = state.kex.computeSecret(info.pubkey);\n\n  if (info.secret instanceof Error) {\n    info.secret.message = 'Error while computing DH secret ('\n                          + state.kex.type + '): '\n                          + info.secret.message;\n    info.secret.level = 'handshake';\n    self.emit('error', info.secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hash = crypto.createHash(state.kex.hash);\n\n  var len_ident = Buffer.byteLength(self.config.ident);\n  var len_sident = Buffer.byteLength(instate.identRaw);\n  var len_init = outstate.kexinit.length;\n  var len_sinit = instate.kexinit.length;\n  var len_hostkey = info.hostkey.length;\n  var len_pubkey = outstate.pubkey.length;\n  var len_spubkey = info.pubkey.length;\n  var len_secret = info.secret.length;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var len_gex_prime;\n  var len_gex_gen;\n  var gex_prime;\n  var gex_gen;\n  var dhParams = state.kex.getDHParams();\n  if (dhParams) {\n    gex_prime = dhParams.prime;\n    gex_gen = dhParams.generator;\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = Buffer.allocUnsafe(exchangeBufLen);\n\n  writeUInt32BE(exchangeBuf, len_ident, bp);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  writeUInt32BE(exchangeBuf, len_sident, bp);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  writeUInt32BE(exchangeBuf, len_init, bp);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  outstate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_sinit, bp);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  instate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_hostkey, bp);\n  bp += 4;\n  info.hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (dhParams) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    writeUInt32BE(exchangeBuf, len_gex_prime, bp);\n    bp += 4;\n    gex_prime.copy(exchangeBuf, bp); // p\n    bp += len_gex_prime;\n\n    writeUInt32BE(exchangeBuf, len_gex_gen, bp);\n    bp += 4;\n    gex_gen.copy(exchangeBuf, bp); // g\n    bp += len_gex_gen;\n  }\n\n  writeUInt32BE(exchangeBuf, len_pubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(exchangeBuf, bp); // e\n  bp += len_pubkey;\n\n  writeUInt32BE(exchangeBuf, len_spubkey, bp);\n  bp += 4;\n  info.pubkey.copy(exchangeBuf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(exchangeBuf, len_secret, bp);\n  bp += 4;\n  info.secret.copy(exchangeBuf, bp); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  var rawsig = readString(info.sig, info.sig._pos, self); // s\n  if (rawsig === false\n      || !(rawsig = sigSSHToASN1(rawsig, info.sig_format, self))) {\n    return false;\n  }\n\n  var hostPubKey = parseDERKey(info.hostkey, info.sig_format);\n  if (hostPubKey instanceof Error)\n    return false;\n\n  debug('DEBUG: Verifying signature');\n\n  if (hostPubKey.verify(outstate.exchangeHash, rawsig) !== true) {\n    debug('DEBUG: Signature verification failed');\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    self.reset();\n    var err = new Error('Handshake failed: signature verification failed');\n    err.level = 'handshake';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = info.secret;\n\n  debug('DEBUG: Outgoing: Writing NEWKEYS');\n  if (outstate.status === OUT_REKEYING)\n    send(self, NEWKEYS_PACKET, undefined, true);\n  else\n    send(self, NEWKEYS_PACKET);\n  outstate.sentNEWKEYS = true;\n\n  if (verifiedHost !== undefined && instate.expectedPacket === undefined) {\n    // We received NEWKEYS while we were waiting for the fingerprint\n    // verification callback to be called. In this case we have to re-execute\n    // onNEWKEYS to finish the handshake.\n    onNEWKEYS(self);\n  }\n}\n\nfunction onNEWKEYS(self) { // Client/Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n\n  instate.expectedPacket = undefined;\n\n  if (!outstate.sentNEWKEYS)\n    return;\n\n  var len = outstate.kexsecret.length;\n\n  var outCipherInfo = outstate.encrypt.info = CIPHER_INFO[outstate.encrypt.type];\n  var p = 0;\n\n  var dhHashAlgo = state.kex.hash;\n\n  var secret = Buffer.allocUnsafe(4 + len);\n  var iv;\n  var key;\n\n  // Whenever the client sends a new authentication request, it is enqueued\n  // here.  Once the request is resolved (success, fail, or PK_OK),\n  // dequeue.  Whatever is at the front of the queue determines how we\n  // interpret packet type 60.\n  state.authsQueue = [];\n\n  writeUInt32BE(secret, len, p);\n  p += 4;\n  outstate.kexsecret.copy(secret, p);\n  outstate.kexsecret = undefined;\n  if (!outCipherInfo.stream) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'A' : 'B', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    while (iv.length < outCipherInfo.ivLen) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    if (iv.length > outCipherInfo.ivLen)\n      iv = iv.slice(0, outCipherInfo.ivLen);\n  } else {\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'C' : 'D', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (key.length < outCipherInfo.keyLen) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  if (key.length > outCipherInfo.keyLen)\n    key = key.slice(0, outCipherInfo.keyLen);\n\n  if (outCipherInfo.authLen > 0) {\n    outstate.encrypt.iv = iv;\n    outstate.encrypt.key = key;\n    outstate.encrypt.instance = true;\n  } else {\n    var cipherAlgo = SSH_TO_OPENSSL[outstate.encrypt.type];\n    outstate.encrypt.instance = crypto.createCipheriv(cipherAlgo, key, iv);\n    outstate.encrypt.instance.setAutoPadding(false);\n  }\n\n  // And now for decrypting ...\n\n  var inCipherInfo = instate.decrypt.info = CIPHER_INFO[instate.decrypt.type];\n  if (!inCipherInfo.stream) {\n    iv = crypto.createHash(dhHashAlgo)\n               .update(secret)\n               .update(outstate.exchangeHash)\n               .update(!self.server ? 'B' : 'A', 'ascii')\n               .update(outstate.sessionId)\n               .digest();\n    while (iv.length < inCipherInfo.ivLen) {\n      iv = Buffer.concat([iv,\n                          crypto.createHash(dhHashAlgo)\n                                .update(secret)\n                                .update(outstate.exchangeHash)\n                                .update(iv)\n                                .digest()]);\n    }\n    if (iv.length > inCipherInfo.ivLen)\n      iv = iv.slice(0, inCipherInfo.ivLen);\n  } else {\n    iv = EMPTY_BUFFER; // Streaming ciphers don't use an IV upfront\n  }\n\n  // Create a reusable buffer for decryption purposes\n  instate.decrypt.buf = Buffer.allocUnsafe(inCipherInfo.blockLen);\n\n  key = crypto.createHash(dhHashAlgo)\n              .update(secret)\n              .update(outstate.exchangeHash)\n              .update(!self.server ? 'D' : 'C', 'ascii')\n              .update(outstate.sessionId)\n              .digest();\n  while (key.length < inCipherInfo.keyLen) {\n    key = Buffer.concat([key,\n                         crypto.createHash(dhHashAlgo)\n                               .update(secret)\n                               .update(outstate.exchangeHash)\n                               .update(key)\n                               .digest()]);\n  }\n  if (key.length > inCipherInfo.keyLen)\n    key = key.slice(0, inCipherInfo.keyLen);\n\n  var decipherAlgo = SSH_TO_OPENSSL[instate.decrypt.type];\n  instate.decrypt.instance = crypto.createDecipheriv(decipherAlgo, key, iv);\n  instate.decrypt.instance.setAutoPadding(false);\n  instate.decrypt.iv = iv;\n  instate.decrypt.key = key;\n\n  var emptyBuf;\n  if (outCipherInfo.discardLen > 0) {\n    emptyBuf = Buffer.alloc(outCipherInfo.discardLen);\n    outstate.encrypt.instance.update(emptyBuf);\n  }\n  if (inCipherInfo.discardLen > 0) {\n    if (!emptyBuf || emptyBuf.length !== inCipherInfo.discardLen)\n      emptyBuf = Buffer.alloc(outCipherInfo.discardLen);\n    instate.decrypt.instance.update(emptyBuf);\n  }\n\n  var outHMACInfo = outstate.hmac.info = HMAC_INFO[outstate.hmac.type];\n  var inHMACInfo = instate.hmac.info = HMAC_INFO[instate.hmac.type];\n\n  if (outCipherInfo.authLen === 0) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'E' : 'F', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (key.length < outHMACInfo.len) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    if (key.length > outHMACInfo.len)\n      key = key.slice(0, outHMACInfo.len);\n    outstate.hmac.key = key;\n  } else {\n    outstate.hmac.key = undefined;\n  }\n  if (inCipherInfo.authLen === 0) {\n    key = crypto.createHash(dhHashAlgo)\n                .update(secret)\n                .update(outstate.exchangeHash)\n                .update(!self.server ? 'F' : 'E', 'ascii')\n                .update(outstate.sessionId)\n                .digest();\n    while (key.length < inHMACInfo.len) {\n      key = Buffer.concat([key,\n                           crypto.createHash(dhHashAlgo)\n                                 .update(secret)\n                                 .update(outstate.exchangeHash)\n                                 .update(key)\n                                 .digest()]);\n    }\n    if (key.length > inHMACInfo.len)\n      key = key.slice(0, inHMACInfo.len);\n    instate.hmac.key = key;\n  } else {\n    instate.hmac.key = undefined;\n  }\n\n  // Create a reusable buffer for message verification purposes\n  var inHMACSize = inCipherInfo.authLen || instate.hmac.info.actualLen;\n  if (!instate.hmac.buf\n      || instate.hmac.buf.length !== inHMACSize) {\n    instate.hmac.buf = Buffer.allocUnsafe(inHMACSize);\n  }\n\n  outstate.exchangeHash = undefined;\n\n  if (outstate.compress.type === 'zlib') {\n    outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n    outstate.compress.queue = [];\n  } else if (outstate.compress.type === 'none') {\n    outstate.compress.instance = false;\n    outstate.compress.queue = null;\n  }\n  if (instate.decompress.type === 'zlib')\n    instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n  else if (instate.decompress.type === 'none')\n    instate.decompress.instance = false;\n\n  self.bytesSent = self.bytesReceived = 0;\n\n  if (outstate.status === OUT_REKEYING) {\n    outstate.status = OUT_READY;\n\n    // Empty our outbound buffer of any data we tried to send during the\n    // re-keying process\n    var queue = outstate.rekeyQueue;\n    var qlen = queue.length;\n    var q = 0;\n\n    outstate.rekeyQueue = [];\n\n    for (; q < qlen; ++q) {\n      if (Buffer.isBuffer(queue[q]))\n        send(self, queue[q]);\n      else\n        send(self, queue[q][0], queue[q][1]);\n    }\n\n    // Now empty our inbound buffer of any non-transport layer packets we\n    // received during the re-keying process\n    queue = instate.rekeyQueue;\n    qlen = queue.length;\n    q = 0;\n\n    instate.rekeyQueue = [];\n\n    var curSeqno = instate.seqno;\n    for (; q < qlen; ++q) {\n      instate.seqno = queue[q][0];\n      instate.payload = queue[q][1];\n      if (parsePacket(self) === false)\n        return;\n\n      if (instate.status === IN_INIT) {\n        // We were reset due to some error/disagreement ?\n        return;\n      }\n    }\n    instate.seqno = curSeqno;\n  } else {\n    outstate.status = OUT_READY;\n    if (instate.status === IN_PACKET) {\n      // Explicitly update incoming packet parser status in order to get the\n      // correct decipher, hmac, etc. states.\n\n      // We only get here if the host fingerprint callback was called\n      // asynchronously and the incoming packet parser is still expecting an\n      // unencrypted packet, etc.\n\n      self.debug('DEBUG: Parser: IN_PACKETBEFORE (update) (expecting '\n                 + inCipherInfo.blockLen + ')');\n      // Wait for the right number of bytes so we can determine the incoming\n      // packet length\n      expectData(self,\n                 EXP_TYPE_BYTES,\n                 inCipherInfo.blockLen,\n                 instate.decrypt.buf);\n    }\n    self.emit('ready');\n  }\n}\n\nfunction getPacketType(self, pktType) {\n  var kex = self._state.kex;\n  if (kex) {\n    // Disambiguate\n    switch (pktType) {\n      case 30:\n        return kex.pktInit;\n      case 31:\n        switch (kex.type) {\n          case 'group':\n            return 'KEXDH_REPLY';\n          case 'groupex':\n            return 'KEXDH_GEX_GROUP';\n          default:\n            return 'KEXECDH_REPLY';\n        }\n        break;\n      case 33:\n        if (kex.type === 'groupex')\n          return 'KEXDH_GEX_REPLY';\n    }\n  }\n  return MESSAGE[pktType];\n}\n\nfunction parsePacket(self, callback) {\n  var instate = self._state.incoming;\n  var outstate = self._state.outgoing;\n  var payload = instate.payload;\n  var seqno = instate.seqno;\n  var serviceName;\n  var lang;\n  var message;\n  var info;\n  var chan;\n  var data;\n  var srcIP;\n  var srcPort;\n  var sender;\n  var window;\n  var packetSize;\n  var recipient;\n  var description;\n  var socketPath;\n\n  if (++instate.seqno > MAX_SEQNO)\n    instate.seqno = 0;\n\n  if (instate.ignoreNext) {\n    self.debug('DEBUG: Parser: Packet ignored');\n    instate.ignoreNext = false;\n    return;\n  }\n\n  var type = payload[0];\n  if (type === undefined)\n    return false;\n\n  // If we receive a packet during handshake that is not the expected packet\n  // and it is not one of: DISCONNECT, IGNORE, UNIMPLEMENTED, or DEBUG, then we\n  // close the stream\n  if (outstate.status !== OUT_READY\n      && getPacketType(self, type) !== instate.expectedPacket\n      && type < 1\n      && type > 4) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + getPacketType(self, type));\n    // XXX: Potential issue where the module user decides to initiate a rekey\n    // via KEXINIT() (which sets `expectedPacket`) after receiving a packet\n    // and there is still another packet already waiting to be parsed at the\n    // time the KEXINIT is written. this will cause an unexpected disconnect...\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (type === MESSAGE.CHANNEL_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_DATA\n      uint32    recipient channel\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    // TODO: MAX_CHAN_DATA_LEN here should really be dependent upon the\n    //       channel's packet size. The ssh2 module uses 32KB, so we'll hard\n    //       code this for now ...\n    data = readString(payload, 5, self, callback, 32768);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_DATA:' + chan, data);\n  } else if (type === MESSAGE.CHANNEL_EXTENDED_DATA) {\n    /*\n      byte      SSH_MSG_CHANNEL_EXTENDED_DATA\n      uint32    recipient channel\n      uint32    data_type_code\n      string    data\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var dataType = readInt(payload, 5, self, callback);\n    if (dataType === false)\n      return false;\n    data = readString(payload, 9, self, callback);\n    if (data === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_EXTENDED_DATA ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EXTENDED_DATA:' + chan, dataType, data);\n  } else if (type === MESSAGE.CHANNEL_WINDOW_ADJUST) {\n    /*\n      byte      SSH_MSG_CHANNEL_WINDOW_ADJUST\n      uint32    recipient channel\n      uint32    bytes to add\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    var bytesToAdd = readInt(payload, 5, self, callback);\n    if (bytesToAdd === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: '\n               + 'CHANNEL_WINDOW_ADJUST ('\n               + chan\n               + ', '\n               + bytesToAdd\n               + ')');\n    self.emit('CHANNEL_WINDOW_ADJUST:' + chan, bytesToAdd);\n  } else if (type === MESSAGE.CHANNEL_SUCCESS) {\n    /*\n      byte      SSH_MSG_CHANNEL_SUCCESS\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_SUCCESS ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_SUCCESS:' + chan);\n  } else if (type === MESSAGE.CHANNEL_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_FAILURE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_FAILURE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_FAILURE:' + chan);\n  } else if (type === MESSAGE.CHANNEL_EOF) {\n    /*\n      byte      SSH_MSG_CHANNEL_EOF\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_EOF ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_EOF:' + chan);\n  } else if (type === MESSAGE.CHANNEL_OPEN) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN\n      string    channel type in US-ASCII only\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    var chanType = readString(payload, 1, 'ascii', self, callback);\n    if (chanType === false)\n      return false;\n    sender = readInt(payload, payload._pos, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, payload._pos += 4, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, payload._pos += 4, self, callback);\n    if (packetSize === false)\n      return false;\n    var channel;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_OPEN ('\n               + sender\n               + ', '\n               + chanType\n               + ')');\n\n    if (chanType === 'forwarded-tcpip' // Server->Client\n        || chanType === 'direct-tcpip') { // Client->Server\n      /*\n        string    address that was connected / host to connect\n        uint32    port that was connected / port to connect\n        string    originator IP address\n        uint32    originator port\n      */\n      var destIP = readString(payload,\n                              payload._pos += 4,\n                              'ascii',\n                              self,\n                              callback);\n      if (destIP === false)\n        return false;\n      var destPort = readInt(payload, payload._pos, self, callback);\n      if (destPort === false)\n        return false;\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          destIP: destIP,\n          destPort: destPort,\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else if (// Server->Client\n               chanType === 'forwarded-streamlocal@openssh.com'\n               // Client->Server\n               || chanType === 'direct-streamlocal@openssh.com') {\n      /*\n        string    socket path\n        string    reserved for future use\n      */\n      socketPath = readString(payload,\n                              payload._pos += 4,\n                              'utf8',\n                              self,\n                              callback);\n      if (socketPath === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          socketPath: socketPath,\n        }\n      };\n    } else if (chanType === 'x11') { // Server->Client\n      /*\n        string    originator address (e.g., \"192.168.7.38\")\n        uint32    originator port\n      */\n      srcIP = readString(payload, payload._pos += 4, 'ascii', self, callback);\n      if (srcIP === false)\n        return false;\n      srcPort = readInt(payload, payload._pos, self, callback);\n      if (srcPort === false)\n        return false;\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {\n          srcIP: srcIP,\n          srcPort: srcPort\n        }\n      };\n    } else {\n      // 'session' (Client->Server), 'auth-agent@openssh.com' (Server->Client)\n      channel = {\n        type: chanType,\n        sender: sender,\n        window: window,\n        packetSize: packetSize,\n        data: {}\n      };\n    }\n\n    self.emit('CHANNEL_OPEN', channel);\n  } else if (type === MESSAGE.CHANNEL_OPEN_CONFIRMATION) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_CONFIRMATION\n      uint32    recipient channel\n      uint32    sender channel\n      uint32    initial window size\n      uint32    maximum packet size\n      ....      channel type specific data follows\n    */\n    // \"The 'recipient channel' is the channel number given in the\n    // original open request, and 'sender channel' is the channel number\n    // allocated by the other side.\"\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    sender = readInt(payload, 5, self, callback);\n    if (sender === false)\n      return false;\n    window = readInt(payload, 9, self, callback);\n    if (window === false)\n      return false;\n    packetSize = readInt(payload, 13, self, callback);\n    if (packetSize === false)\n      return false;\n\n    info = {\n      recipient: recipient,\n      sender: sender,\n      window: window,\n      packetSize: packetSize\n    };\n\n    if (payload.length > 17)\n      info.data = payload.slice(17);\n\n    self.emit('CHANNEL_OPEN_CONFIRMATION:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_OPEN_FAILURE) {\n    /*\n      byte      SSH_MSG_CHANNEL_OPEN_FAILURE\n      uint32    recipient channel\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    recipient = readInt(payload, 1, self, callback);\n    if (recipient === false)\n      return false;\n    var reasonCode = readInt(payload, 5, self, callback);\n    if (reasonCode === false)\n      return false;\n    description = readString(payload, 9, 'utf8', self, callback);\n    if (description === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    payload._pos = 9;\n    info = {\n      recipient: recipient,\n      reasonCode: reasonCode,\n      reason: CHANNEL_OPEN_FAILURE[reasonCode],\n      description: description,\n      lang: lang\n    };\n\n    self.emit('CHANNEL_OPEN_FAILURE:' + info.recipient, info);\n  } else if (type === MESSAGE.CHANNEL_CLOSE) {\n    /*\n      byte      SSH_MSG_CHANNEL_CLOSE\n      uint32    recipient channel\n    */\n    chan = readInt(payload, 1, self, callback);\n    if (chan === false)\n      return false;\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_CLOSE ('\n               + chan\n               + ')');\n    self.emit('CHANNEL_CLOSE:' + chan);\n  } else if (type === MESSAGE.IGNORE) {\n    /*\n      byte      SSH_MSG_IGNORE\n      string    data\n    */\n  } else if (type === MESSAGE.DISCONNECT) {\n    /*\n      byte      SSH_MSG_DISCONNECT\n      uint32    reason code\n      string    description in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var reason = readInt(payload, 1, self, callback);\n    if (reason === false)\n      return false;\n    var reasonText = DISCONNECT_REASON[reason];\n    description = readString(payload, 5, 'utf8', self, callback);\n    if (description === false)\n      return false;\n\n    if (payload._pos < payload.length)\n      lang = readString(payload, payload._pos, 'ascii', self, callback);\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: DISCONNECT ('\n               + reasonText\n               + ')');\n\n    self.emit('DISCONNECT', reasonText, reason, description, lang);\n  } else if (type === MESSAGE.DEBUG) {\n    /*\n      byte      SSH_MSG_DEBUG\n      boolean   always_display\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 2, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'ascii', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('DEBUG', message, lang);\n  } else if (type === MESSAGE.NEWKEYS) {\n    /*\n      byte      SSH_MSG_NEW_KEYS\n    */\n    self.emit('NEWKEYS');\n  } else if (type === MESSAGE.SERVICE_REQUEST) {\n    /*\n      byte      SSH_MSG_SERVICE_REQUEST\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_REQUEST', serviceName);\n  } else if (type === MESSAGE.SERVICE_ACCEPT) {\n    /*\n      byte      SSH_MSG_SERVICE_ACCEPT\n      string    service name\n    */\n    serviceName = readString(payload, 1, 'ascii', self, callback);\n    if (serviceName === false)\n      return false;\n\n    self.emit('SERVICE_ACCEPT', serviceName);\n  } else if (type === MESSAGE.USERAUTH_REQUEST) {\n    /*\n      byte      SSH_MSG_USERAUTH_REQUEST\n      string    user name in ISO-10646 UTF-8 encoding [RFC3629]\n      string    service name in US-ASCII\n      string    method name in US-ASCII\n      ....      method specific fields\n    */\n    var username = readString(payload, 1, 'utf8', self, callback);\n    if (username === false)\n      return false;\n    var svcName = readString(payload, payload._pos, 'ascii', self, callback);\n    if (svcName === false)\n      return false;\n    var method = readString(payload, payload._pos, 'ascii', self, callback);\n    if (method === false)\n      return false;\n\n    var methodData;\n    var methodDesc;\n\n    if (method === 'password') {\n      methodData = readString(payload,\n                              payload._pos + 1,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method === 'publickey' || method === 'hostbased') {\n      var pkSigned;\n      var keyAlgo;\n      var key;\n      var signature;\n      var blob;\n      var hostname;\n      var userlocal;\n      if (method === 'publickey') {\n        pkSigned = payload[payload._pos++];\n        if (pkSigned === undefined)\n          return false;\n        pkSigned = (pkSigned !== 0);\n      }\n      keyAlgo = readString(payload, payload._pos, 'ascii', self, callback);\n      if (keyAlgo === false)\n        return false;\n      key = readString(payload, payload._pos, self, callback);\n      if (key === false)\n        return false;\n\n      if (pkSigned || method === 'hostbased') {\n        if (method === 'hostbased') {\n          hostname = readString(payload, payload._pos, 'ascii', self, callback);\n          if (hostname === false)\n            return false;\n          userlocal = readString(payload, payload._pos, 'utf8', self, callback);\n          if (userlocal === false)\n            return false;\n        }\n\n        var blobEnd = payload._pos;\n        signature = readString(payload, blobEnd, self, callback);\n        if (signature === false)\n          return false;\n\n        if (signature.length > (4 + keyAlgo.length + 4)\n            && signature.toString('ascii', 4, 4 + keyAlgo.length) === keyAlgo) {\n          // Skip algoLen + algo + sigLen\n          signature = signature.slice(4 + keyAlgo.length + 4);\n        }\n\n        signature = sigSSHToASN1(signature, keyAlgo, self, callback);\n        if (signature === false)\n          return false;\n\n        blob = Buffer.allocUnsafe(4 + outstate.sessionId.length + blobEnd);\n        writeUInt32BE(blob, outstate.sessionId.length, 0);\n        outstate.sessionId.copy(blob, 4);\n        payload.copy(blob, 4 + outstate.sessionId.length, 0, blobEnd);\n      } else {\n        methodDesc = 'publickey -- check';\n      }\n\n      methodData = {\n        keyAlgo: keyAlgo,\n        key: key,\n        signature: signature,\n        blob: blob,\n        localHostname: hostname,\n        localUsername: userlocal\n      };\n    } else if (method === 'keyboard-interactive') {\n      // Skip language, it's deprecated\n      var skipLen = readInt(payload, payload._pos, self, callback);\n      if (skipLen === false)\n        return false;\n      methodData = readString(payload,\n                              payload._pos + 4 + skipLen,\n                              'utf8',\n                              self,\n                              callback);\n      if (methodData === false)\n        return false;\n    } else if (method !== 'none')\n      methodData = payload.slice(payload._pos);\n\n    if (methodDesc === undefined)\n      methodDesc = method;\n\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: USERAUTH_REQUEST ('\n               + methodDesc\n               + ')');\n\n    self._state.authsQueue.push(method);\n    self.emit('USERAUTH_REQUEST', username, svcName, method, methodData);\n  } else if (type === MESSAGE.USERAUTH_SUCCESS) {\n    /*\n      byte      SSH_MSG_USERAUTH_SUCCESS\n    */\n    if (outstate.compress.type === 'zlib@openssh.com') {\n      outstate.compress.instance = zlib.createDeflate(ZLIB_OPTS);\n      outstate.compress.queue = [];\n    }\n    if (instate.decompress.type === 'zlib@openssh.com')\n      instate.decompress.instance = zlib.createInflate(ZLIB_OPTS);\n\n    self._state.authsQueue.shift();\n\n    self.emit('USERAUTH_SUCCESS');\n  } else if (type === MESSAGE.USERAUTH_FAILURE) {\n    /*\n      byte      SSH_MSG_USERAUTH_FAILURE\n      name-list    authentications that can continue\n      boolean      partial success\n    */\n    var auths = readString(payload, 1, 'ascii', self, callback);\n    if (auths === false)\n      return false;\n    var partSuccess = payload[payload._pos];\n    if (partSuccess === undefined)\n      return false;\n\n    partSuccess = (partSuccess !== 0);\n    auths = auths.split(',');\n\n    self._state.authsQueue.shift();\n    self.emit('USERAUTH_FAILURE', auths, partSuccess);\n  } else if (type === MESSAGE.USERAUTH_BANNER) {\n    /*\n      byte      SSH_MSG_USERAUTH_BANNER\n      string    message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    message = readString(payload, 1, 'utf8', self, callback);\n    if (message === false)\n      return false;\n    lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n\n    self.emit('USERAUTH_BANNER', message, lang);\n  } else if (type === MESSAGE.GLOBAL_REQUEST) {\n    /*\n      byte      SSH_MSG_GLOBAL_REQUEST\n      string    request name in US-ASCII only\n      boolean   want reply\n      ....      request-specific data follows\n    */\n    var request = readString(payload, 1, 'ascii', self, callback);\n    if (request === false) {\n      self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST');\n      return false;\n    }\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: GLOBAL_REQUEST ('\n               + request\n               + ')');\n\n    var wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n\n    var reqData;\n    if (request === 'tcpip-forward' || request === 'cancel-tcpip-forward') {\n      var bindAddr = readString(payload, payload._pos, 'ascii', self, callback);\n      if (bindAddr === false)\n        return false;\n      var bindPort = readInt(payload, payload._pos, self, callback);\n      if (bindPort === false)\n        return false;\n      reqData = {\n        bindAddr: bindAddr,\n        bindPort: bindPort\n      };\n    } else if (request === 'streamlocal-forward@openssh.com'\n               || request === 'cancel-streamlocal-forward@openssh.com') {\n      socketPath = readString(payload, payload._pos, 'utf8', self, callback);\n      if (socketPath === false)\n        return false;\n      reqData = {\n        socketPath: socketPath\n      };\n    } else if (request === 'no-more-sessions@openssh.com') {\n      // No data\n    } else {\n      reqData = payload.slice(payload._pos);\n    }\n\n    self.emit('GLOBAL_REQUEST', request, wantReply, reqData);\n  } else if (type === MESSAGE.REQUEST_SUCCESS) {\n    /*\n      byte      SSH_MSG_REQUEST_SUCCESS\n      ....      response specific data\n    */\n    if (payload.length > 1)\n      self.emit('REQUEST_SUCCESS', payload.slice(1));\n    else\n      self.emit('REQUEST_SUCCESS');\n  } else if (type === MESSAGE.REQUEST_FAILURE) {\n    /*\n      byte      SSH_MSG_REQUEST_FAILURE\n    */\n    self.emit('REQUEST_FAILURE');\n  } else if (type === MESSAGE.UNIMPLEMENTED) {\n    /*\n      byte      SSH_MSG_UNIMPLEMENTED\n      uint32    packet sequence number of rejected message\n    */\n    // TODO\n  } else if (type === MESSAGE.KEXINIT)\n    return parse_KEXINIT(self, callback);\n  else if (type === MESSAGE.CHANNEL_REQUEST)\n    return parse_CHANNEL_REQUEST(self, callback);\n  else if (type >= 30 && type <= 49) // Key exchange method-specific messages\n    return parse_KEX(self, type, callback);\n  else if (type >= 60 && type <= 70) // User auth context-specific messages\n    return parse_USERAUTH(self, type, callback);\n  else {\n    // Unknown packet type\n    var unimpl = Buffer.allocUnsafe(1 + 4);\n    unimpl[0] = MESSAGE.UNIMPLEMENTED;\n    writeUInt32BE(unimpl, seqno, 1);\n    send(self, unimpl);\n  }\n}\n\nfunction parse_KEXINIT(self, callback) {\n  var instate = self._state.incoming;\n  var payload = instate.payload;\n\n  /*\n    byte         SSH_MSG_KEXINIT\n    byte[16]     cookie (random bytes)\n    name-list    kex_algorithms\n    name-list    server_host_key_algorithms\n    name-list    encryption_algorithms_client_to_server\n    name-list    encryption_algorithms_server_to_client\n    name-list    mac_algorithms_client_to_server\n    name-list    mac_algorithms_server_to_client\n    name-list    compression_algorithms_client_to_server\n    name-list    compression_algorithms_server_to_client\n    name-list    languages_client_to_server\n    name-list    languages_server_to_client\n    boolean      first_kex_packet_follows\n    uint32       0 (reserved for future extension)\n  */\n  var init = {\n    algorithms: {\n      kex: undefined,\n      srvHostKey: undefined,\n      cs: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      },\n      sc: {\n        encrypt: undefined,\n        mac: undefined,\n        compress: undefined\n      }\n    },\n    languages: {\n      cs: undefined,\n      sc: undefined\n    }\n  };\n  var val;\n\n  val = readList(payload, 17, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.kex = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.srvHostKey = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.encrypt = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.mac = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.cs.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.algorithms.sc.compress = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.cs = val;\n  val = readList(payload, payload._pos, self, callback);\n  if (val === false)\n    return false;\n  init.languages.sc = val;\n\n  var firstFollows = (payload._pos < payload.length\n                      && payload[payload._pos] === 1);\n\n  instate.kexinit = payload;\n\n  self.emit('KEXINIT', init, firstFollows);\n}\n\nfunction parse_KEX(self, type, callback) {\n  var state = self._state;\n  var instate = state.incoming;\n  var payload = instate.payload;\n\n  if (state.outgoing.status === OUT_READY\n      || getPacketType(self, type) !== instate.expectedPacket) {\n    self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, expected: '\n               + instate.expectedPacket\n               + ' but got: '\n               + getPacketType(self, type));\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Received unexpected packet');\n    err.level = 'protocol';\n    self.emit('error', err);\n    return false;\n  }\n\n  if (state.kex.type === 'groupex') {\n    // Dynamic group exchange-related\n\n    if (self.server) {\n      // TODO: Support group exchange server-side\n      self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n      var err = new Error('DH group exchange not supported by server');\n      err.level = 'handshake';\n      self.emit('error', err);\n      return false;\n    } else {\n      if (type === MESSAGE.KEXDH_GEX_GROUP) {\n        /*\n          byte    SSH_MSG_KEX_DH_GEX_GROUP\n          mpint   p, safe prime\n          mpint   g, generator for subgroup in GF(p)\n        */\n        var prime = readString(payload, 1, self, callback);\n        if (prime === false)\n          return false;\n        var gen = readString(payload, payload._pos, self, callback);\n        if (gen === false)\n          return false;\n        self.emit('KEXDH_GEX_GROUP', prime, gen);\n      } else if (type === MESSAGE.KEXDH_GEX_REPLY)\n        return parse_KEXDH_REPLY(self, callback);\n    }\n  } else {\n    // Static group or ECDH-related\n\n    if (type === MESSAGE.KEXDH_INIT) {\n      /*\n        byte      SSH_MSG_KEXDH_INIT\n        mpint     e\n      */\n      var e = readString(payload, 1, self, callback);\n      if (e === false)\n        return false;\n\n      self.emit('KEXDH_INIT', e);\n    } else if (type === MESSAGE.KEXDH_REPLY)\n      return parse_KEXDH_REPLY(self, callback);\n  }\n}\n\nfunction parse_KEXDH_REPLY(self, callback) {\n  var payload = self._state.incoming.payload;\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n                / SSH_MSG_KEX_DH_GEX_REPLY\n                / SSH_MSG_KEX_ECDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n  var hostkey = readString(payload, 1, self, callback);\n  if (hostkey === false)\n    return false;\n  var pubkey = readString(payload, payload._pos, self, callback);\n  if (pubkey === false)\n    return false;\n  var sig = readString(payload, payload._pos, self, callback);\n  if (sig === false)\n    return false;\n  var info = {\n    hostkey: hostkey,\n    hostkey_format: undefined,\n    pubkey: pubkey,\n    sig: sig,\n    sig_format: undefined\n  };\n  var hostkey_format = readString(hostkey, 0, 'ascii', self, callback);\n  if (hostkey_format === false)\n    return false;\n  info.hostkey_format = hostkey_format;\n  var sig_format = readString(sig, 0, 'ascii', self, callback);\n  if (sig_format === false)\n    return false;\n  info.sig_format = sig_format;\n  self.emit('KEXDH_REPLY', info);\n}\n\nfunction parse_USERAUTH(self, type, callback) {\n  var state = self._state;\n  var authMethod = state.authsQueue[0];\n  var payload = state.incoming.payload;\n  var message;\n  var lang;\n  var text;\n\n  if (authMethod === 'password') {\n    if (type === MESSAGE.USERAUTH_PASSWD_CHANGEREQ) {\n      /*\n        byte      SSH_MSG_USERAUTH_PASSWD_CHANGEREQ\n        string    prompt in ISO-10646 UTF-8 encoding\n        string    language tag\n      */\n      message = readString(payload, 1, 'utf8', self, callback);\n      if (message === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      self.emit('USERAUTH_PASSWD_CHANGEREQ', message, lang);\n    }\n  } else if (authMethod === 'keyboard-interactive') {\n    if (type === MESSAGE.USERAUTH_INFO_REQUEST) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_REQUEST\n        string    name (ISO-10646 UTF-8)\n        string    instruction (ISO-10646 UTF-8)\n        string    language tag -- MAY be empty\n        int       num-prompts\n        string    prompt[1] (ISO-10646 UTF-8)\n        boolean   echo[1]\n        ...\n        string    prompt[num-prompts] (ISO-10646 UTF-8)\n        boolean   echo[num-prompts]\n      */\n      var name;\n      var instr;\n      var nprompts;\n\n      name = readString(payload, 1, 'utf8', self, callback);\n      if (name === false)\n        return false;\n      instr = readString(payload, payload._pos, 'utf8', self, callback);\n      if (instr === false)\n        return false;\n      lang = readString(payload, payload._pos, 'utf8', self, callback);\n      if (lang === false)\n        return false;\n      nprompts = readInt(payload, payload._pos, self, callback);\n      if (nprompts === false)\n        return false;\n\n      payload._pos += 4;\n\n      var prompts = [];\n      for (var prompt = 0; prompt < nprompts; ++prompt) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        var echo = payload[payload._pos++];\n        if (echo === undefined)\n          return false;\n        echo = (echo !== 0);\n        prompts.push({\n          prompt: text,\n          echo: echo\n        });\n      }\n      self.emit('USERAUTH_INFO_REQUEST', name, instr, lang, prompts);\n    } else if (type === MESSAGE.USERAUTH_INFO_RESPONSE) {\n      /*\n        byte      SSH_MSG_USERAUTH_INFO_RESPONSE\n        int       num-responses\n        string    response[1] (ISO-10646 UTF-8)\n        ...\n        string    response[num-responses] (ISO-10646 UTF-8)\n      */\n      var nresponses = readInt(payload, 1, self, callback);\n      if (nresponses === false)\n        return false;\n\n      payload._pos = 5;\n\n      var responses = [];\n      for (var response = 0; response < nresponses; ++response) {\n        text = readString(payload, payload._pos, 'utf8', self, callback);\n        if (text === false)\n          return false;\n        responses.push(text);\n      }\n      self.emit('USERAUTH_INFO_RESPONSE', responses);\n    }\n  } else if (authMethod === 'publickey') {\n    if (type === MESSAGE.USERAUTH_PK_OK) {\n      /*\n        byte      SSH_MSG_USERAUTH_PK_OK\n        string    public key algorithm name from the request\n        string    public key blob from the request\n      */\n      var authsQueue = self._state.authsQueue;\n      if (!authsQueue.length || authsQueue[0] !== 'publickey')\n        return;\n      authsQueue.shift();\n      self.emit('USERAUTH_PK_OK');\n      // XXX: Parse public key info? client currently can ignore it because\n      // there is only one outstanding auth request at any given time, so it\n      // knows which key was OK'd\n    }\n  } else if (authMethod !== undefined) {\n    // Invalid packet for this auth type\n    self.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    var err = new Error('Invalid authentication method: ' + authMethod);\n    err.level = 'protocol';\n    self.emit('error', err);\n  }\n}\n\nfunction parse_CHANNEL_REQUEST(self, callback) {\n  var payload = self._state.incoming.payload;\n  var info;\n  var cols;\n  var rows;\n  var width;\n  var height;\n  var wantReply;\n  var signal;\n\n  var recipient = readInt(payload, 1, self, callback);\n  if (recipient === false)\n    return false;\n  var request = readString(payload, 5, 'ascii', self, callback);\n  if (request === false)\n    return false;\n\n  if (request === 'exit-status') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-status\"\n      boolean   FALSE\n      uint32    exit_status\n    */\n    var code = readInt(payload, ++payload._pos, self, callback);\n    if (code === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      code: code\n    };\n  } else if (request === 'exit-signal') { // Server->Client\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exit-signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n      boolean   core dumped\n      string    error message in ISO-10646 UTF-8 encoding\n      string    language tag\n    */\n    var coredump;\n    if (!(self.remoteBugs & BUGS.OLD_EXIT)) {\n      signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n      if (signal === false)\n        return false;\n      coredump = payload[payload._pos++];\n      if (coredump === undefined)\n        return false;\n      coredump = (coredump !== 0);\n    } else {\n      /*\n        Instead of `signal name` and `core dumped`, we have just:\n\n        uint32  signal number\n      */\n      signal = readInt(payload, ++payload._pos, self, callback);\n      if (signal === false)\n        return false;\n      switch (signal) {\n        case 1:\n          signal = 'HUP';\n          break;\n        case 2:\n          signal = 'INT';\n          break;\n        case 3:\n          signal = 'QUIT';\n          break;\n        case 6:\n          signal = 'ABRT';\n          break;\n        case 9:\n          signal = 'KILL';\n          break;\n        case 14:\n          signal = 'ALRM';\n          break;\n        case 15:\n          signal = 'TERM';\n          break;\n        default:\n          // Unknown or OS-specific\n          signal = 'UNKNOWN (' + signal + ')';\n      }\n      coredump = false;\n    }\n    var description = readString(payload, payload._pos, 'utf8', self,\n                                 callback);\n    if (description === false)\n      return false;\n    var lang = readString(payload, payload._pos, 'utf8', self, callback);\n    if (lang === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: signal,\n      coredump: coredump,\n      description: description,\n      lang: lang\n    };\n  } else if (request === 'pty-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"pty-req\"\n      boolean   want_reply\n      string    TERM environment variable value (e.g., vt100)\n      uint32    terminal width, characters (e.g., 80)\n      uint32    terminal height, rows (e.g., 24)\n      uint32    terminal width, pixels (e.g., 640)\n      uint32    terminal height, pixels (e.g., 480)\n      string    encoded terminal modes\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var term = readString(payload, payload._pos, 'ascii', self, callback);\n    if (term === false)\n      return false;\n    cols = readInt(payload, payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    var modes = readString(payload, payload._pos += 4, self, callback);\n    if (modes === false)\n      return false;\n    modes = bytesToModes(modes);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      term: term,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height,\n      modes: modes\n    };\n  } else if (request === 'window-change') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"window-change\"\n      boolean   FALSE\n      uint32    terminal width, columns\n      uint32    terminal height, rows\n      uint32    terminal width, pixels\n      uint32    terminal height, pixels\n    */\n    cols = readInt(payload, ++payload._pos, self, callback);\n    if (cols === false)\n      return false;\n    rows = readInt(payload, payload._pos += 4, self, callback);\n    if (rows === false)\n      return false;\n    width = readInt(payload, payload._pos += 4, self, callback);\n    if (width === false)\n      return false;\n    height = readInt(payload, payload._pos += 4, self, callback);\n    if (height === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      cols: cols,\n      rows: rows,\n      width: width,\n      height: height\n    };\n  } else if (request === 'x11-req') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"x11-req\"\n      boolean   want reply\n      boolean   single connection\n      string    x11 authentication protocol\n      string    x11 authentication cookie\n      uint32    x11 screen number\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var single = payload[payload._pos++];\n    if (single === undefined)\n      return false;\n    single = (single !== 0);\n    var protocol = readString(payload, payload._pos, 'ascii', self, callback);\n    if (protocol === false)\n      return false;\n    var cookie = readString(payload, payload._pos, 'binary', self, callback);\n    if (cookie === false)\n      return false;\n    var screen = readInt(payload, payload._pos, self, callback);\n    if (screen === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      single: single,\n      protocol: protocol,\n      cookie: cookie,\n      screen: screen\n    };\n  } else if (request === 'env') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"env\"\n      boolean   want reply\n      string    variable name\n      string    variable value\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var key = readString(payload, payload._pos, 'utf8', self, callback);\n    if (key === false)\n      return false;\n    var val = readString(payload, payload._pos, 'utf8', self, callback);\n    if (val === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      key: key,\n      val: val\n    };\n  } else if (request === 'shell') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"shell\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else if (request === 'exec') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"exec\"\n      boolean   want reply\n      string    command\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var command = readString(payload, payload._pos, 'utf8', self, callback);\n    if (command === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      command: command\n    };\n  } else if (request === 'subsystem') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"subsystem\"\n      boolean   want reply\n      string    subsystem name\n    */\n    wantReply = payload[payload._pos++];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    var subsystem = readString(payload, payload._pos, 'utf8', self, callback);\n    if (subsystem === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply,\n      subsystem: subsystem\n    };\n  } else if (request === 'signal') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"signal\"\n      boolean   FALSE\n      string    signal name (without the \"SIG\" prefix)\n    */\n    signal = readString(payload, ++payload._pos, 'ascii', self, callback);\n    if (signal === false)\n      return false;\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      signal: 'SIG' + signal\n    };\n  } else if (request === 'xon-xoff') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"xon-xoff\"\n      boolean   FALSE\n      boolean   client can do\n    */\n    var clientControl = payload[++payload._pos];\n    if (clientControl === undefined)\n      return false;\n    clientControl = (clientControl !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: false,\n      clientControl: clientControl\n    };\n  } else if (request === 'auth-agent-req@openssh.com') { // Client->Server\n    /*\n      byte      SSH_MSG_CHANNEL_REQUEST\n      uint32    recipient channel\n      string    \"auth-agent-req@openssh.com\"\n      boolean   want reply\n    */\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  } else {\n    // Unknown request type\n    wantReply = payload[payload._pos];\n    if (wantReply === undefined)\n      return false;\n    wantReply = (wantReply !== 0);\n    info = {\n      recipient: recipient,\n      request: request,\n      wantReply: wantReply\n    };\n  }\n  self.debug('DEBUG: Parser: IN_PACKETDATAAFTER, packet: CHANNEL_REQUEST ('\n             + recipient\n             + ', '\n             + request\n             + ')');\n  self.emit('CHANNEL_REQUEST:' + recipient, info);\n}\n\nfunction hmacVerify(self, data) {\n  var instate = self._state.incoming;\n  var hmac = instate.hmac;\n\n  self.debug('DEBUG: Parser: Verifying MAC');\n\n  if (instate.decrypt.info.authLen > 0) {\n    var decrypt = instate.decrypt;\n    var instance = decrypt.instance;\n\n    instance.setAuthTag(data);\n\n    var payload = instance.update(instate.packet);\n    instate.payload = payload.slice(1, instate.packet.length - payload[0]);\n    iv_inc(decrypt.iv);\n\n    decrypt.instance = crypto.createDecipheriv(\n                         SSH_TO_OPENSSL[decrypt.type],\n                         decrypt.key,\n                         decrypt.iv\n                       );\n    decrypt.instance.setAutoPadding(false);\n    return true;\n  } else {\n    var calcHmac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n\n    writeUInt32BE(HMAC_COMPUTE, instate.seqno, 0);\n    writeUInt32BE(HMAC_COMPUTE, instate.pktLen, 4);\n    HMAC_COMPUTE[8] = instate.padLen;\n\n    calcHmac.update(HMAC_COMPUTE);\n    calcHmac.update(instate.packet);\n\n    var mac = calcHmac.digest();\n    if (mac.length > instate.hmac.info.actualLen)\n      mac = mac.slice(0, instate.hmac.info.actualLen);\n    return timingSafeEqual(mac, data);\n  }\n}\n\nfunction decryptData(self, data) {\n  var instance = self._state.incoming.decrypt.instance;\n  self.debug('DEBUG: Parser: Decrypting');\n  return instance.update(data);\n}\n\nfunction expectData(self, type, amount, buffer) {\n  var expect = self._state.incoming.expect;\n  expect.amount = amount;\n  expect.type = type;\n  expect.ptr = 0;\n  if (buffer)\n    expect.buf = buffer;\n  else if (amount)\n    expect.buf = Buffer.allocUnsafe(amount);\n}\n\nfunction readList(buffer, start, stream, callback) {\n  var list = readString(buffer, start, 'ascii', stream, callback);\n  return (list !== false ? (list.length ? list.split(',') : []) : false);\n}\n\nfunction bytesToModes(buffer) {\n  var modes = {};\n\n  for (var i = 0, len = buffer.length, opcode; i < len; i += 5) {\n    opcode = buffer[i];\n    if (opcode === TERMINAL_MODE.TTY_OP_END\n        || TERMINAL_MODE[opcode] === undefined\n        || i + 5 > len)\n      break;\n    modes[TERMINAL_MODE[opcode]] = readUInt32BE(buffer, i + 1);\n  }\n\n  return modes;\n}\n\nfunction modesToBytes(modes) {\n  var RE_IS_NUM = /^\\d+$/;\n  var keys = Object.keys(modes);\n  var b = 0;\n  var bytes = [];\n\n  for (var i = 0, len = keys.length, key, opcode, val; i < len; ++i) {\n    key = keys[i];\n    opcode = TERMINAL_MODE[key];\n    if (opcode\n        && !RE_IS_NUM.test(key)\n        && typeof modes[key] === 'number'\n        && key !== 'TTY_OP_END') {\n      val = modes[key];\n      bytes[b++] = opcode;\n      bytes[b++] = (val >>> 24) & 0xFF;\n      bytes[b++] = (val >>> 16) & 0xFF;\n      bytes[b++] = (val >>> 8) & 0xFF;\n      bytes[b++] = val & 0xFF;\n    }\n  }\n\n  bytes[b] = TERMINAL_MODE.TTY_OP_END;\n\n  return bytes;\n}\n\n// Shared outgoing functions\nfunction KEXINIT(self, cb) { // Client/Server\n  randBytes(16, function(myCookie) {\n    /*\n      byte         SSH_MSG_KEXINIT\n      byte[16]     cookie (random bytes)\n      name-list    kex_algorithms\n      name-list    server_host_key_algorithms\n      name-list    encryption_algorithms_client_to_server\n      name-list    encryption_algorithms_server_to_client\n      name-list    mac_algorithms_client_to_server\n      name-list    mac_algorithms_server_to_client\n      name-list    compression_algorithms_client_to_server\n      name-list    compression_algorithms_server_to_client\n      name-list    languages_client_to_server\n      name-list    languages_server_to_client\n      boolean      first_kex_packet_follows\n      uint32       0 (reserved for future extension)\n    */\n    var algos = self.config.algorithms;\n\n    var kexBuf = algos.kexBuf;\n    if (self.remoteBugs & BUGS.BAD_DHGEX) {\n      var copied = false;\n      var kexList = algos.kex;\n      for (var j = kexList.length - 1; j >= 0; --j) {\n        if (kexList[j].indexOf('group-exchange') !== -1) {\n          if (!copied) {\n            kexList = kexList.slice();\n            copied = true;\n          }\n          kexList.splice(j, 1);\n        }\n      }\n      if (copied)\n        kexBuf = Buffer.from(kexList.join(','));\n    }\n\n    var hostKeyBuf = algos.serverHostKeyBuf;\n\n    var kexInitSize = 1 + 16\n                      + 4 + kexBuf.length\n                      + 4 + hostKeyBuf.length\n                      + (2 * (4 + algos.cipherBuf.length))\n                      + (2 * (4 + algos.hmacBuf.length))\n                      + (2 * (4 + algos.compressBuf.length))\n                      + (2 * (4 /* languages skipped */))\n                      + 1 + 4;\n    var buf = Buffer.allocUnsafe(kexInitSize);\n    var p = 17;\n\n    buf[0] = MESSAGE.KEXINIT;\n\n    if (myCookie !== false)\n      myCookie.copy(buf, 1);\n\n    writeUInt32BE(buf, kexBuf.length, p);\n    p += 4;\n    kexBuf.copy(buf, p);\n    p += kexBuf.length;\n\n    writeUInt32BE(buf, hostKeyBuf.length, p);\n    p += 4;\n    hostKeyBuf.copy(buf, p);\n    p += hostKeyBuf.length;\n\n    writeUInt32BE(buf, algos.cipherBuf.length, p);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    writeUInt32BE(buf, algos.cipherBuf.length, p);\n    p += 4;\n    algos.cipherBuf.copy(buf, p);\n    p += algos.cipherBuf.length;\n\n    writeUInt32BE(buf, algos.hmacBuf.length, p);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    writeUInt32BE(buf, algos.hmacBuf.length, p);\n    p += 4;\n    algos.hmacBuf.copy(buf, p);\n    p += algos.hmacBuf.length;\n\n    writeUInt32BE(buf, algos.compressBuf.length, p);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    writeUInt32BE(buf, algos.compressBuf.length, p);\n    p += 4;\n    algos.compressBuf.copy(buf, p);\n    p += algos.compressBuf.length;\n\n    // Skip language lists, first_kex_packet_follows, and reserved bytes\n    buf.fill(0, buf.length - 13);\n\n    self.debug('DEBUG: Outgoing: Writing KEXINIT');\n\n    self._state.incoming.expectedPacket = 'KEXINIT';\n\n    var outstate = self._state.outgoing;\n\n    outstate.kexinit = buf;\n\n    if (outstate.status === OUT_READY) {\n      // We are the one starting the rekeying process ...\n      outstate.status = OUT_REKEYING;\n    }\n\n    send(self, buf, cb, true);\n  });\n  return true;\n}\n\nfunction KEXDH_INIT(self) { // Client\n  var state = self._state;\n  var outstate = state.outgoing;\n  var buf = Buffer.allocUnsafe(1 + 4 + outstate.pubkey.length);\n\n  state.incoming.expectedPacket = state.kex.pktReply;\n  if (state.kex.type === 'groupex') {\n    buf[0] = MESSAGE.KEXDH_GEX_INIT;\n    self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_INIT');\n  } else {\n    buf[0] = MESSAGE.KEXDH_INIT;\n    if (state.kex.type === 'group')\n      self.debug('DEBUG: Outgoing: Writing KEXDH_INIT');\n    else\n      self.debug('DEBUG: Outgoing: Writing KEXECDH_INIT');\n  }\n\n  writeUInt32BE(buf, outstate.pubkey.length, 1);\n  outstate.pubkey.copy(buf, 5);\n\n  return send(self, buf, undefined, true);\n}\n\nfunction KEXDH_REPLY(self, e) { // Server\n  var state = self._state;\n  var outstate = state.outgoing;\n  var instate = state.incoming;\n  var curHostKey = self.config.hostKeys[state.hostkeyFormat];\n  if (Array.isArray(curHostKey))\n    curHostKey = curHostKey[0];\n  var hostkey = curHostKey.getPublicSSH();\n  var hostkeyAlgo = curHostKey.type;\n\n  // e === client DH public key\n\n  e = state.kex.convertPublicKey(e);\n\n  var secret = state.kex.computeSecret(e);\n\n  if (secret instanceof Error) {\n    secret.message = 'Error while computing DH secret ('\n                     + state.kex.type + '): '\n                     + secret.message;\n    secret.level = 'handshake';\n    self.emit('error', secret);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  var hash = crypto.createHash(state.kex.hash);\n\n  var len_ident = Buffer.byteLength(instate.identRaw);\n  var len_sident = Buffer.byteLength(self.config.ident);\n  var len_init = instate.kexinit.length;\n  var len_sinit = outstate.kexinit.length;\n  var len_hostkey = hostkey.length;\n  var len_pubkey = e.length;\n  var len_spubkey = outstate.pubkey.length;\n  var len_secret = secret.length;\n\n  var exchangeBufLen = len_ident\n                       + len_sident\n                       + len_init\n                       + len_sinit\n                       + len_hostkey\n                       + len_pubkey\n                       + len_spubkey\n                       + len_secret\n                       + (4 * 8); // Length fields for above values\n\n  // Group exchange-related\n  var len_gex_prime;\n  var len_gex_gen;\n  var gex_prime;\n  var gex_gen;\n  var dhParams = state.kex.getDHParams();\n  if (dhParams) {\n    gex_prime = dhParams.prime;\n    gex_gen = dhParams.generator;\n    len_gex_prime = gex_prime.length;\n    len_gex_gen = gex_gen.length;\n    exchangeBufLen += (4 * 3); // min, n, max values\n    exchangeBufLen += (4 * 2); // prime, generator length fields\n    exchangeBufLen += len_gex_prime;\n    exchangeBufLen += len_gex_gen;\n  }\n\n  var bp = 0;\n  var exchangeBuf = Buffer.allocUnsafe(exchangeBufLen);\n\n  writeUInt32BE(exchangeBuf, len_ident, bp);\n  bp += 4;\n  exchangeBuf.write(instate.identRaw, bp, 'utf8'); // V_C\n  bp += len_ident;\n\n  writeUInt32BE(exchangeBuf, len_sident, bp);\n  bp += 4;\n  exchangeBuf.write(self.config.ident, bp, 'utf8'); // V_S\n  bp += len_sident;\n\n  writeUInt32BE(exchangeBuf, len_init, bp);\n  bp += 4;\n  instate.kexinit.copy(exchangeBuf, bp); // I_C\n  bp += len_init;\n  instate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_sinit, bp);\n  bp += 4;\n  outstate.kexinit.copy(exchangeBuf, bp); // I_S\n  bp += len_sinit;\n  outstate.kexinit = undefined;\n\n  writeUInt32BE(exchangeBuf, len_hostkey, bp);\n  bp += 4;\n  hostkey.copy(exchangeBuf, bp); // K_S\n  bp += len_hostkey;\n\n  if (dhParams) {\n    KEXDH_GEX_REQ_PACKET.slice(1).copy(exchangeBuf, bp); // min, n, max\n    bp += (4 * 3); // Skip over bytes just copied\n\n    writeUInt32BE(exchangeBuf, len_gex_prime, bp);\n    bp += 4;\n    gex_prime.copy(exchangeBuf, bp); // p\n    bp += len_gex_prime;\n\n    writeUInt32BE(exchangeBuf, len_gex_gen, bp);\n    bp += 4;\n    gex_gen.copy(exchangeBuf, bp); // g\n    bp += len_gex_gen;\n  }\n\n  writeUInt32BE(exchangeBuf, len_pubkey, bp);\n  bp += 4;\n  e.copy(exchangeBuf, bp); // e\n  bp += len_pubkey;\n\n  writeUInt32BE(exchangeBuf, len_spubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(exchangeBuf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(exchangeBuf, len_secret, bp);\n  bp += 4;\n  secret.copy(exchangeBuf, bp); // K\n\n  outstate.exchangeHash = hash.update(exchangeBuf).digest(); // H\n\n  if (outstate.sessionId === undefined)\n    outstate.sessionId = outstate.exchangeHash;\n  outstate.kexsecret = secret;\n\n  var signature = curHostKey.sign(outstate.exchangeHash);\n  if (signature instanceof Error) {\n    signature.message = 'Error while signing data with host key ('\n                        + hostkeyAlgo + '): '\n                        + signature.message;\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  signature = convertSignature(signature, hostkeyAlgo);\n  if (signature === false) {\n    signature.message = 'Error while converting handshake signature';\n    signature.level = 'handshake';\n    self.emit('error', signature);\n    self.disconnect(DISCONNECT_REASON.KEY_EXCHANGE_FAILED);\n    return false;\n  }\n\n  /*\n    byte      SSH_MSG_KEXDH_REPLY\n    string    server public host key and certificates (K_S)\n    mpint     f\n    string    signature of H\n  */\n\n  var siglen = 4 + hostkeyAlgo.length + 4 + signature.length;\n  var buf = Buffer.allocUnsafe(1\n                               + 4 + len_hostkey\n                               + 4 + len_spubkey\n                               + 4 + siglen);\n\n  bp = 0;\n  buf[bp] = MESSAGE[state.kex.pktReply];\n  ++bp;\n\n  writeUInt32BE(buf, len_hostkey, bp);\n  bp += 4;\n  hostkey.copy(buf, bp); // K_S\n  bp += len_hostkey;\n\n  writeUInt32BE(buf, len_spubkey, bp);\n  bp += 4;\n  outstate.pubkey.copy(buf, bp); // f\n  bp += len_spubkey;\n\n  writeUInt32BE(buf, siglen, bp);\n  bp += 4;\n  writeUInt32BE(buf, hostkeyAlgo.length, bp);\n  bp += 4;\n  buf.write(hostkeyAlgo, bp, hostkeyAlgo.length, 'ascii');\n  bp += hostkeyAlgo.length;\n  writeUInt32BE(buf, signature.length, bp);\n  bp += 4;\n  signature.copy(buf, bp);\n\n  state.incoming.expectedPacket = 'NEWKEYS';\n\n  self.debug('DEBUG: Outgoing: Writing ' + state.kex.pktReply);\n  send(self, buf, undefined, true);\n\n  outstate.sentNEWKEYS = true;\n  self.debug('DEBUG: Outgoing: Writing NEWKEYS');\n  return send(self, NEWKEYS_PACKET, undefined, true);\n}\n\nfunction KEXDH_GEX_REQ(self) { // Client\n  self._state.incoming.expectedPacket = 'KEXDH_GEX_GROUP';\n\n  self.debug('DEBUG: Outgoing: Writing KEXDH_GEX_REQUEST');\n  return send(self, KEXDH_GEX_REQ_PACKET, undefined, true);\n}\n\nfunction compressPayload(self, payload, cb) {\n  var compress = self._state.outgoing.compress.instance;\n  compress.write(payload);\n  compress.flush(Z_PARTIAL_FLUSH, compressFlushCb.bind(self, cb));\n}\n\nfunction compressFlushCb(cb) {\n  if (this._readableState.ended || this._writableState.ended)\n    return;\n  send_(this, this._state.outgoing.compress.instance.read(), cb);\n\n  var queue = this._state.outgoing.compress.queue;\n  queue.shift();\n  if (queue.length > 0)\n    compressPayload(this, queue[0][0], queue[0][1]);\n}\n\nfunction send(self, payload, cb, bypass) {\n  var state = self._state;\n\n  if (!state)\n    return false;\n\n  var outstate = state.outgoing;\n  if (outstate.status === OUT_REKEYING && !bypass) {\n    if (typeof cb === 'function')\n      outstate.rekeyQueue.push([payload, cb]);\n    else\n      outstate.rekeyQueue.push(payload);\n    return false;\n  } else if (self._readableState.ended || self._writableState.ended) {\n    return false;\n  }\n\n  if (outstate.compress.instance) {\n    // This queue nonsense only exists because of a change made in node v10.12.0\n    // that changed flushing behavior, which now coalesces multiple writes to a\n    // single flush, which does not work for us.\n    var queue = outstate.compress.queue;\n    queue.push([payload, cb]);\n    if (queue.length === 1)\n      compressPayload(self, queue[0][0], queue[0][1]);\n    return true;\n  } else {\n    return send_(self, payload, cb);\n  }\n}\n\nfunction send_(self, payload, cb) {\n  // TODO: Implement length checks\n\n  var state = self._state;\n  var outstate = state.outgoing;\n  var encrypt = outstate.encrypt;\n  var hmac = outstate.hmac;\n  var pktLen;\n  var padLen;\n  var buf;\n  var mac;\n  var ret;\n\n  pktLen = payload.length + 9;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.info.authLen > 0) {\n      var ptlen = 1 + payload.length + 4/* Must have at least 4 bytes padding*/;\n      while ((ptlen % encrypt.info.blockLen) !== 0)\n        ++ptlen;\n      padLen = ptlen - 1 - payload.length;\n      pktLen = 4 + ptlen;\n    } else {\n      var blockLen = encrypt.info.blockLen;\n      pktLen += ((blockLen - 1) * pktLen) % blockLen;\n      padLen = pktLen - payload.length - 5;\n    }\n  } else {\n    pktLen += (7 * pktLen) % 8;\n    padLen = pktLen - payload.length - 5;\n  }\n\n  buf = Buffer.allocUnsafe(pktLen);\n\n  writeUInt32BE(buf, pktLen - 4, 0);\n  buf[4] = padLen;\n  payload.copy(buf, 5);\n\n  copyRandPadBytes(buf, 5 + payload.length, padLen);\n\n  if (hmac.type !== false && hmac.key) {\n    mac = crypto.createHmac(SSH_TO_OPENSSL[hmac.type], hmac.key);\n    writeUInt32BE(outstate.bufSeqno, outstate.seqno, 0);\n    mac.update(outstate.bufSeqno);\n    mac.update(buf);\n    mac = mac.digest();\n    if (mac.length > hmac.info.actualLen)\n      mac = mac.slice(0, hmac.info.actualLen);\n  }\n\n  var nb = 0;\n  var encData;\n\n  if (encrypt.instance !== false) {\n    if (encrypt.info.authLen > 0) {\n      var encrypter = crypto.createCipheriv(SSH_TO_OPENSSL[encrypt.type],\n                                            encrypt.key,\n                                            encrypt.iv);\n      encrypter.setAutoPadding(false);\n\n      var lenbuf = buf.slice(0, 4);\n\n      encrypter.setAAD(lenbuf);\n      self.push(lenbuf);\n      nb += lenbuf;\n\n      encData = encrypter.update(buf.slice(4));\n      self.push(encData);\n      nb += encData.length;\n\n      var final = encrypter.final();\n      if (final.length) {\n        self.push(final);\n        nb += final.length;\n      }\n\n      var authTag = encrypter.getAuthTag();\n      ret = self.push(authTag);\n      nb += authTag.length;\n\n      iv_inc(encrypt.iv);\n    } else {\n      encData = encrypt.instance.update(buf);\n      self.push(encData);\n      nb += encData.length;\n\n      ret = self.push(mac);\n      nb += mac.length;\n    }\n  } else {\n    ret = self.push(buf);\n    nb = buf.length;\n  }\n\n  self.bytesSent += nb;\n\n  if (++outstate.seqno > MAX_SEQNO)\n    outstate.seqno = 0;\n\n  cb && cb();\n\n  return ret;\n}\n\nvar copyRandPadBytes = (function() {\n  if (typeof crypto.randomFillSync === 'function') {\n    return crypto.randomFillSync;\n  } else {\n    return function copyRandPadBytes(buf, offset, count) {\n      var padBytes = crypto.randomBytes(count);\n      padBytes.copy(buf, offset);\n    };\n  }\n})();\n\nfunction randBytes(n, cb) {\n  crypto.randomBytes(n, function retry(err, buf) {\n    if (err)\n      return crypto.randomBytes(n, retry);\n    cb && cb(buf);\n  });\n}\n\nfunction convertSignature(signature, keyType) {\n  switch (keyType) {\n    case 'ssh-dss':\n      return DSASigBERToBare(signature);\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      return ECDSASigASN1ToSSH(signature);\n  }\n\n  return signature;\n}\n\nvar timingSafeEqual = (function() {\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return function timingSafeEquals(a, b) {\n      if (a.length !== b.length) {\n        crypto.timingSafeEqual(a, a);\n        return false;\n      } else {\n        return crypto.timingSafeEqual(a, b);\n      }\n    };\n  } else {\n    return function timingSafeEquals(a, b) {\n      var val;\n      if (a.length === b.length) {\n        val = 0;\n      } else {\n        val = 1;\n        b = a;\n      }\n\n      for (var i = 0, len = a.length; i < len; ++i)\n        val |= (a[i] ^ b[i]);\n\n      return (val === 0);\n    }\n  }\n})();\n\nfunction KeyExchange(algo, options) {\n  switch (algo) {\n    case 'curve25519-sha256':\n    case 'curve25519-sha256@libssh.org':\n      if (!CURVE25519_SUPPORTED)\n        break;\n      this.type = '25519';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp256':\n      this.type = 'ecdh';\n      this.name = 'prime256v1';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp384':\n      this.type = 'ecdh';\n      this.name = 'secp384r1';\n      this.hash = 'sha384';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'ecdh-sha2-nistp521':\n      this.type = 'ecdh';\n      this.name = 'secp521r1';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXECDH_INIT';\n      this.pktReply = 'KEXECDH_REPLY';\n      return;\n    case 'diffie-hellman-group1-sha1':\n      this.type = 'group';\n      this.name = 'modp2';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group14-sha1':\n      this.type = 'group';\n      this.name = 'modp14';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group14-sha256':\n      this.type = 'group';\n      this.name = 'modp14';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group16-sha512':\n      this.type = 'group';\n      this.name = 'modp16';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group18-sha512':\n      this.type = 'group';\n      this.name = 'modp18';\n      this.hash = 'sha512';\n      this.pktInit = 'KEXDH_INIT';\n      this.pktReply = 'KEXDH_REPLY';\n      return;\n    case 'diffie-hellman-group-exchange-sha1':\n      this.type = 'groupex';\n      this.hash = 'sha1';\n      this.pktInit = 'KEXDH_GEX_REQ';\n      this.pktReply = 'KEXDH_GEX_REPLY';\n      this._prime = null;\n      this._generator = null;\n      return;\n    case 'diffie-hellman-group-exchange-sha256':\n      this.type = 'groupex';\n      this.hash = 'sha256';\n      this.pktInit = 'KEXDH_GEX_REQ';\n      this.pktReply = 'KEXDH_GEX_REPLY';\n      this._prime = null;\n      this._generator = null;\n      return;\n  }\n  throw new Error('Unsupported key exchange algorithm: ' + algo);\n}\nKeyExchange.prototype.setDHParams = function(prime, generator) {\n  if (this.type === 'groupex') {\n    if (!Buffer.isBuffer(prime))\n      throw new Error('Invalid prime value');\n    if (!Buffer.isBuffer(generator))\n      throw new Error('Invalid generator value');\n    this._prime = prime;\n    this._generator = generator;\n  }\n};\nKeyExchange.prototype.getDHParams = function() {\n  if (this.type === 'groupex' && this._kex) {\n    return {\n      prime: convertToMpint(this._kex.getPrime()),\n      generator: convertToMpint(this._kex.getGenerator()),\n    };\n  }\n};\nKeyExchange.prototype.generateKeys = function() {\n  switch (this.type) {\n    case '25519':\n      if (!this._keys)\n        this._keys = crypto.generateKeyPairSync('x25519');\n      break;\n    case 'ecdh':\n      if (!this._kex) {\n        this._kex = crypto.createECDH(this.name);\n        this._public = this._kex.generateKeys();\n      }\n      break;\n    case 'group':\n    case 'groupex':\n      if (!this._kex) {\n        if (this.name)\n          this._kex = crypto.createDiffieHellmanGroup(this.name);\n        else if (this._prime && this._generator)\n          this._kex = crypto.createDiffieHellman(this._prime, this._generator);\n        if (this._kex)\n          this._public = this._kex.generateKeys();\n      }\n      break;\n  }\n};\nKeyExchange.prototype.getPublicKey = function() {\n  this.generateKeys();\n\n  var key;\n  switch (this.type) {\n    case '25519':\n      key = this._keys.publicKey.export({ type: 'spki', format: 'der' });\n      return key.slice(-32); // HACK: avoids parsing DER/BER header\n    case 'ecdh':\n    case 'group':\n    case 'groupex':\n      key = this._public;\n      break;\n  }\n  if (key)\n    return this.convertPublicKey(key);\n};\nKeyExchange.prototype.convertPublicKey = function(key) {\n  var newKey;\n  var idx = 0;\n  var len = key.length;\n  while (key[idx] === 0x00) {\n    ++idx;\n    --len;\n  }\n  switch (this.type) {\n    case '25519':\n      if (key.length === 32)\n        return key;\n      break;\n    default:\n      if (key[idx] & 0x80) {\n        newKey = Buffer.allocUnsafe(1 + len);\n        newKey[0] = 0;\n        key.copy(newKey, 1, idx);\n        return newKey;\n      }\n  }\n  if (len !== key.length) {\n    newKey = Buffer.allocUnsafe(len);\n    key.copy(newKey, 0, idx);\n    key = newKey;\n  }\n  return key;\n};\nKeyExchange.prototype.computeSecret = function(otherPublicKey) {\n  this.generateKeys();\n\n  switch (this.type) {\n    case '25519':\n      try {\n        var asnWriter = new Ber.Writer();\n        asnWriter.startSequence();\n          // algorithm\n          asnWriter.startSequence();\n            asnWriter.writeOID('1.3.101.110'); // id-X25519\n          asnWriter.endSequence();\n\n          // PublicKey\n          asnWriter.startSequence(Ber.BitString);\n            asnWriter.writeByte(0x00);\n            // XXX: hack to write a raw buffer without a tag -- yuck\n            asnWriter._ensure(otherPublicKey.length);\n            otherPublicKey.copy(asnWriter._buf,\n                                asnWriter._offset,\n                                0,\n                                otherPublicKey.length);\n            asnWriter._offset += otherPublicKey.length;\n          asnWriter.endSequence();\n        asnWriter.endSequence();\n\n        return convertToMpint(crypto.diffieHellman({\n          privateKey: this._keys.privateKey,\n          publicKey: crypto.createPublicKey({\n            key: asnWriter.buffer,\n            type: 'spki',\n            format: 'der',\n          }),\n        }));\n      } catch (ex) {\n        return ex;\n      }\n      break;\n    case 'ecdh':\n    case 'group':\n    case 'groupex':\n      try {\n        return convertToMpint(this._kex.computeSecret(otherPublicKey));\n      } catch (ex) {\n        return ex;\n      }\n  }\n};\n\nfunction convertToMpint(buf) {\n  var idx = 0;\n  var length = buf.length;\n  while (buf[idx] === 0x00) {\n    ++idx;\n    --length;\n  }\n  var newBuf;\n  if (buf[idx] & 0x80) {\n    newBuf = Buffer.allocUnsafe(1 + length);\n    newBuf[0] = 0;\n    buf.copy(newBuf, 1, idx);\n    buf = newBuf;\n  } else if (length !== buf.length) {\n    newBuf = Buffer.allocUnsafe(length);\n    buf.copy(newBuf, 0, idx);\n    buf = newBuf;\n  }\n  return buf;\n}\n\nmodule.exports = SSH2Stream;\nmodule.exports._send = send;\n","var Ber = require('asn1').Ber;\n\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\n// XXX the value of 2400 from dropbear is only for certain strings, not all\n// strings. for example the list strings used during handshakes\nvar MAX_STRING_LEN = Infinity;//2400; // taken from dropbear\n\nmodule.exports = {\n  iv_inc: iv_inc,\n  readInt: readInt,\n  readString: readString,\n  parseKey: require('./keyParser').parseKey,\n  sigSSHToASN1: sigSSHToASN1,\n  DSASigBERToBare: DSASigBERToBare,\n  ECDSASigASN1ToSSH: ECDSASigASN1ToSSH\n};\n\nfunction iv_inc(iv) {\n  var n = 12;\n  var c = 0;\n  do {\n    --n;\n    c = iv[n];\n    if (c === 255)\n      iv[n] = 0;\n    else {\n      iv[n] = ++c;\n      return;\n    }\n  } while (n > 4);\n}\n\nfunction readInt(buffer, start, stream, cb) {\n  var bufferLen = buffer.length;\n  if (start < 0 || start >= bufferLen || (bufferLen - start) < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  return readUInt32BE(buffer, start);\n}\n\nfunction DSASigBERToBare(signature) {\n  if (signature.length <= 40)\n    return signature;\n  // This is a quick and dirty way to get from BER encoded r and s that\n  // OpenSSL gives us, to just the bare values back to back (40 bytes\n  // total) like OpenSSH (and possibly others) are expecting\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  var rOffset = 0;\n  var sOffset = 0;\n  if (r.length < 20) {\n    var rNew = Buffer.allocUnsafe(20);\n    r.copy(rNew, 1);\n    r = rNew;\n    r[0] = 0;\n  }\n  if (s.length < 20) {\n    var sNew = Buffer.allocUnsafe(20);\n    s.copy(sNew, 1);\n    s = sNew;\n    s[0] = 0;\n  }\n  if (r.length > 20 && r[0] === 0x00)\n    rOffset = 1;\n  if (s.length > 20 && s[0] === 0x00)\n    sOffset = 1;\n  var newSig = Buffer.allocUnsafe((r.length - rOffset) + (s.length - sOffset));\n  r.copy(newSig, 0, rOffset);\n  s.copy(newSig, r.length - rOffset, sOffset);\n  return newSig;\n}\n\nfunction ECDSASigASN1ToSSH(signature) {\n  if (signature[0] === 0x00)\n    return signature;\n  // Convert SSH signature parameters to ASN.1 BER values for OpenSSL\n  var asnReader = new Ber.Reader(signature);\n  asnReader.readSequence();\n  var r = asnReader.readString(Ber.Integer, true);\n  var s = asnReader.readString(Ber.Integer, true);\n  if (r === null || s === null)\n    return false;\n  var newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);\n  writeUInt32BE(newSig, r.length, 0);\n  r.copy(newSig, 4);\n  writeUInt32BE(newSig, s.length, 4 + r.length);\n  s.copy(newSig, 4 + 4 + r.length);\n  return newSig;\n}\n\nfunction sigSSHToASN1(sig, type, self, callback) {\n  var asnWriter;\n  switch (type) {\n    case 'ssh-dss':\n      if (sig.length > 40)\n        return sig;\n      // Change bare signature r and s values to ASN.1 BER values for OpenSSL\n      asnWriter = new Ber.Writer();\n      asnWriter.startSequence();\n      var r = sig.slice(0, 20);\n      var s = sig.slice(20);\n      if (r[0] & 0x80) {\n        var rNew = Buffer.allocUnsafe(21);\n        rNew[0] = 0x00;\n        r.copy(rNew, 1);\n        r = rNew;\n      } else if (r[0] === 0x00 && !(r[1] & 0x80)) {\n        r = r.slice(1);\n      }\n      if (s[0] & 0x80) {\n        var sNew = Buffer.allocUnsafe(21);\n        sNew[0] = 0x00;\n        s.copy(sNew, 1);\n        s = sNew;\n      } else if (s[0] === 0x00 && !(s[1] & 0x80)) {\n        s = s.slice(1);\n      }\n      asnWriter.writeBuffer(r, Ber.Integer);\n      asnWriter.writeBuffer(s, Ber.Integer);\n      asnWriter.endSequence();\n      return asnWriter.buffer;\n    case 'ecdsa-sha2-nistp256':\n    case 'ecdsa-sha2-nistp384':\n    case 'ecdsa-sha2-nistp521':\n      var r = readString(sig, 0, self, callback);\n      if (r === false)\n        return false;\n      var s = readString(sig, sig._pos, self, callback);\n      if (s === false)\n        return false;\n\n      asnWriter = new Ber.Writer();\n      asnWriter.startSequence();\n      asnWriter.writeBuffer(r, Ber.Integer);\n      asnWriter.writeBuffer(s, Ber.Integer);\n      asnWriter.endSequence();\n      return asnWriter.buffer;\n    default:\n      return sig;\n  }\n}\n\nfunction readString(buffer, start, encoding, stream, cb, maxLen) {\n  if (encoding && !Buffer.isBuffer(encoding) && typeof encoding !== 'string') {\n    if (typeof cb === 'number')\n      maxLen = cb;\n    cb = stream;\n    stream = encoding;\n    encoding = undefined;\n  }\n\n  start || (start = 0);\n  var bufferLen = buffer.length;\n  var left = (bufferLen - start);\n  var len;\n  var end;\n  if (start < 0 || start >= bufferLen || left < 4) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  len = readUInt32BE(buffer, start);\n  if (len > (maxLen || MAX_STRING_LEN) || left < (4 + len)) {\n    stream && stream._cleanup(cb);\n    return false;\n  }\n\n  start += 4;\n  end = start + len;\n  buffer._pos = end;\n\n  if (encoding) {\n    if (Buffer.isBuffer(encoding)) {\n      buffer.copy(encoding, 0, start, end);\n      return encoding;\n    } else {\n      return buffer.toString(encoding, start, end);\n    }\n  } else {\n    return buffer.slice(start, end);\n  }\n}\n\n","var inherits = require('util').inherits;\nvar DuplexStream = require('stream').Duplex;\nvar ReadableStream = require('stream').Readable;\nvar WritableStream = require('stream').Writable;\n\nvar STDERR = require('ssh2-streams').constants.CHANNEL_EXTENDED_DATATYPE.STDERR;\n\nvar PACKET_SIZE = 32 * 1024;\nvar MAX_WINDOW = 2 * 1024 * 1024;\nvar WINDOW_THRESHOLD = MAX_WINDOW / 2;\nvar CUSTOM_EVENTS = [\n  'CHANNEL_EOF',\n  'CHANNEL_CLOSE',\n  'CHANNEL_DATA',\n  'CHANNEL_EXTENDED_DATA',\n  'CHANNEL_WINDOW_ADJUST',\n  'CHANNEL_SUCCESS',\n  'CHANNEL_FAILURE',\n  'CHANNEL_REQUEST'\n];\nvar CUSTOM_EVENTS_LEN = CUSTOM_EVENTS.length;\n\nfunction Channel(info, client, opts) {\n  var streamOpts = {\n    highWaterMark: MAX_WINDOW,\n    allowHalfOpen: (!opts || (opts && opts.allowHalfOpen !== false))\n  };\n\n  this.allowHalfOpen = streamOpts.allowHalfOpen;\n\n  DuplexStream.call(this, streamOpts);\n\n  var self = this;\n  var server = opts && opts.server;\n\n  this.server = server;\n  this.type = info.type;\n  this.subtype = undefined;\n  /*\n    incoming and outgoing contain these properties:\n    {\n      id: undefined,\n      window: undefined,\n      packetSize: undefined,\n      state: 'closed'\n    }\n  */\n  var incoming = this.incoming = info.incoming;\n  var incomingId = incoming.id;\n  var outgoing = this.outgoing = info.outgoing;\n  var callbacks = this._callbacks = [];\n  var exitCode;\n  var exitSignal;\n  var exitDump;\n  var exitDesc;\n  var exitLang;\n\n  this._client = client;\n  this._hasX11 = false;\n\n  var channels = client._channels;\n  var sshstream = client._sshstream;\n\n  function ondrain() {\n    if (self._waitClientDrain) {\n      self._waitClientDrain = false;\n      if (!self._waitWindow) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }\n  client._sock.on('drain', ondrain);\n\n  sshstream.once('CHANNEL_EOF:' + incomingId, function() {\n    if (incoming.state !== 'open')\n      return;\n    incoming.state = 'eof';\n\n    if (self.readable)\n      self.push(null);\n    if (!server && self.stderr.readable)\n      self.stderr.push(null);\n  }).once('CHANNEL_CLOSE:' + incomingId, function() {\n    if (incoming.state === 'closed')\n      return;\n    incoming.state = 'closed';\n\n    if (self.readable)\n      self.push(null);\n    if (server && self.stderr.writable)\n      self.stderr.end();\n    else if (!server && self.stderr.readable)\n      self.stderr.push(null);\n\n    if (outgoing.state === 'open' || outgoing.state === 'eof')\n      self.close();\n    if (outgoing.state === 'closing')\n      outgoing.state = 'closed';\n\n    delete channels[incomingId];\n\n    var state = self._writableState;\n    client._sock.removeListener('drain', ondrain);\n    if (!state.ending && !state.finished)\n      self.end();\n\n    // Take care of any outstanding channel requests\n    self._callbacks = [];\n    for (var i = 0; i < callbacks.length; ++i)\n      callbacks[i](true);\n    callbacks = self._callbacks;\n\n    if (!server) {\n      // align more with node child processes, where the close event gets the\n      // same arguments as the exit event\n      if (!self.readable) {\n        if (exitCode === null) {\n          self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                    exitLang);\n        } else\n          self.emit('close', exitCode);\n      } else {\n        self.once('end', function() {\n          if (exitCode === null) {\n            self.emit('close', exitCode, exitSignal, exitDump, exitDesc,\n                      exitLang);\n          } else\n            self.emit('close', exitCode);\n        });\n      }\n\n      if (!self.stderr.readable)\n        self.stderr.emit('close');\n      else {\n        self.stderr.once('end', function() {\n          self.stderr.emit('close');\n        });\n      }\n    } else { // Server mode\n      if (!self.readable)\n        self.emit('close');\n      else {\n        self.once('end', function() {\n          self.emit('close');\n        });\n      }\n    }\n\n    for (var i = 0; i < CUSTOM_EVENTS_LEN; ++i)\n      sshstream.removeAllListeners(CUSTOM_EVENTS[i] + ':' + incomingId);\n  }).on('CHANNEL_DATA:' + incomingId, function(data) {\n    // the remote party should not be sending us data if there is no window\n    // space available ...\n    // TODO: raise error on data with not enough window\n    if (incoming.window === 0)\n      return;\n\n    incoming.window -= data.length;\n\n    if (!self.push(data)) {\n      self._waitChanDrain = true;\n      return;\n    }\n\n    if (incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(self);\n  }).on('CHANNEL_WINDOW_ADJUST:' + incomingId, function(amt) {\n    // the server is allowing us to send `amt` more bytes of data\n    outgoing.window += amt;\n\n    if (self._waitWindow) {\n      self._waitWindow = false;\n      if (!self._waitClientDrain) {\n        if (self._chunk)\n          self._write(self._chunk, null, self._chunkcb);\n        else if (self._chunkcb)\n          self._chunkcb();\n        else if (self._chunkErr)\n          self.stderr._write(self._chunkErr, null, self._chunkcbErr);\n        else if (self._chunkcbErr)\n          self._chunkcbErr();\n      }\n    }\n  }).on('CHANNEL_SUCCESS:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(false);\n  }).on('CHANNEL_FAILURE:' + incomingId, function() {\n    if (server) {\n      sshstream._kalast = Date.now();\n      sshstream._kacnt = 0;\n    } else\n      client._resetKA();\n    if (callbacks.length)\n      callbacks.shift()(true);\n  }).on('CHANNEL_REQUEST:' + incomingId, function(info) {\n    if (!server) {\n      if (info.request === 'exit-status') {\n        self.emit('exit', exitCode = info.code);\n        return;\n      } else if (info.request === 'exit-signal') {\n        self.emit('exit',\n                  exitCode = null,\n                  exitSignal = 'SIG' + info.signal,\n                  exitDump = info.coredump,\n                  exitDesc = info.description,\n                  exitLang = info.lang);\n        return;\n      }\n    }\n\n    // keepalive request? OpenSSH will send one as a channel request if there\n    // is a channel open\n\n    if (info.wantReply)\n      sshstream.channelFailure(outgoing.id);\n  });\n\n  this.stdin = this.stdout = this;\n\n  if (server)\n    this.stderr = new ServerStderr(this);\n  else {\n    this.stderr = new ReadableStream(streamOpts);\n    this.stderr._read = function(n) {\n      if (self._waitChanDrain) {\n        self._waitChanDrain = false;\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    };\n\n    sshstream.on('CHANNEL_EXTENDED_DATA:' + incomingId,\n      function(type, data) {\n        // the remote party should not be sending us data if there is no window\n        // space available ...\n        // TODO: raise error on data with not enough window\n        if (incoming.window === 0)\n          return;\n\n        incoming.window -= data.length;\n\n        if (!self.stderr.push(data)) {\n          self._waitChanDrain = true;\n          return;\n        }\n\n        if (incoming.window <= WINDOW_THRESHOLD)\n          windowAdjust(self);\n      }\n    );\n  }\n\n  // outgoing data\n  this._waitClientDrain = false; // Client stream-level backpressure\n  this._waitWindow = false; // SSH-level backpressure\n\n  // incoming data\n  this._waitChanDrain = false; // Channel Readable side backpressure\n\n  this._chunk = undefined;\n  this._chunkcb = undefined;\n  this._chunkErr = undefined;\n  this._chunkcbErr = undefined;\n\n  function onFinish() {\n    self.eof();\n    if (server || (!server && !self.allowHalfOpen))\n      self.close();\n    self.writable = false;\n  }\n  this.on('finish', onFinish)\n      .on('prefinish', onFinish); // for node v0.11+\n  function onEnd() {\n    self.readable = false;\n  }\n  this.on('end', onEnd)\n      .on('close', onEnd);\n}\ninherits(Channel, DuplexStream);\n\nChannel.prototype.eof = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open') {\n    outgoing.state = 'eof';\n    ret = this._client._sshstream.channelEOF(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype.close = function() {\n  var ret = true;\n  var outgoing = this.outgoing;\n\n  if (outgoing.state === 'open' || outgoing.state === 'eof') {\n    outgoing.state = 'closing';\n    ret = this._client._sshstream.channelClose(outgoing.id);\n  }\n\n  return ret;\n};\n\nChannel.prototype._read = function(n) {\n  if (this._waitChanDrain) {\n    this._waitChanDrain = false;\n    if (this.incoming.window <= WINDOW_THRESHOLD)\n      windowAdjust(this);\n  }\n};\n\nChannel.prototype._write = function(data, encoding, cb) {\n  var sshstream = this._client._sshstream;\n  var outgoing = this.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelData(id, data.slice(p, p + sliceLen));\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      this._waitClientDrain = true;\n      this._chunk = undefined;\n      this._chunkcb = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      this._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = Buffer.allocUnsafe(len - p);\n      data.copy(buf, 0, p);\n      this._chunk = buf;\n    } else\n      this._chunk = data;\n    this._chunkcb = cb;\n    return;\n  }\n\n  if (!this._waitClientDrain)\n    cb();\n};\n\nChannel.prototype.destroy = function() {\n  this.end();\n};\n\n// session type-specific methods\nChannel.prototype.setWindow = function(rows, cols, height, width) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && (this.subtype === 'shell' || this.subtype === 'exec')\n      && this.writable\n      && this.outgoing.state === 'open') {\n    return this._client._sshstream.windowChange(this.outgoing.id,\n                                                rows,\n                                                cols,\n                                                height,\n                                                width);\n  }\n\n  return true;\n};\nChannel.prototype.signal = function(signalName) {\n  if (this.server)\n    throw new Error('Client-only method called in server mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open')\n    return this._client._sshstream.signal(this.outgoing.id, signalName);\n\n  return true;\n};\nChannel.prototype.exit = function(name, coreDumped, msg) {\n  if (!this.server)\n    throw new Error('Server-only method called in client mode');\n\n  if (this.type === 'session'\n      && this.writable\n      && this.outgoing.state === 'open') {\n    if (typeof name === 'number')\n      return this._client._sshstream.exitStatus(this.outgoing.id, name);\n    else {\n      return this._client._sshstream.exitSignal(this.outgoing.id,\n                                                name,\n                                                coreDumped,\n                                                msg);\n    }\n  }\n\n  return true;\n};\n\nChannel.MAX_WINDOW = MAX_WINDOW;\nChannel.PACKET_SIZE = PACKET_SIZE;\n\nfunction windowAdjust(self) {\n  if (self.outgoing.state === 'closed')\n    return true;\n  var amt = MAX_WINDOW - self.incoming.window;\n  if (amt <= 0)\n    return true;\n  self.incoming.window += amt;\n  return self._client._sshstream.channelWindowAdjust(self.outgoing.id, amt);\n}\n\nfunction ServerStderr(channel) {\n  WritableStream.call(this, { highWaterMark: MAX_WINDOW });\n  this._channel = channel;\n}\ninherits(ServerStderr, WritableStream);\n\nServerStderr.prototype._write = function(data, encoding, cb) {\n  var channel = this._channel;\n  var sshstream = channel._client._sshstream;\n  var outgoing = channel.outgoing;\n  var packetSize = outgoing.packetSize;\n  var id = outgoing.id;\n  var window = outgoing.window;\n  var len = data.length;\n  var p = 0;\n  var ret;\n  var buf;\n  var sliceLen;\n\n  if (channel.outgoing.state !== 'open')\n    return;\n\n  while (len - p > 0 && window > 0) {\n    sliceLen = len - p;\n    if (sliceLen > window)\n      sliceLen = window;\n    if (sliceLen > packetSize)\n      sliceLen = packetSize;\n\n    ret = sshstream.channelExtData(id, data.slice(p, p + sliceLen), STDERR);\n\n    p += sliceLen;\n    window -= sliceLen;\n\n    if (!ret) {\n      channel._waitClientDrain = true;\n      channel._chunkErr = undefined;\n      channel._chunkcbErr = cb;\n      break;\n    }\n  }\n\n  outgoing.window = window;\n\n  if (len - p > 0) {\n    if (window === 0)\n      channel._waitWindow = true;\n    if (p > 0) {\n      // partial\n      buf = Buffer.allocUnsafe(len - p);\n      data.copy(buf, 0, p);\n      channel._chunkErr = buf;\n    } else\n      channel._chunkErr = data;\n    channel._chunkcbErr = cb;\n    return;\n  }\n\n  if (!channel._waitClientDrain)\n    cb();\n};\n\nmodule.exports = Channel;\n","// This wrapper class is used to retain backwards compatibility with\n// pre-v0.4 ssh2. If it weren't for `read()` and `write()` being used by the\n// streams2/3 API, we could just pass the SFTPStream directly to the end user...\n\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\nfunction SFTPWrapper(stream) {\n  var self = this;\n\n  EventEmitter.call(this);\n\n  this._stream = stream;\n\n  stream.on('error', function(err) {\n    self.emit('error', err);\n  }).on('end', function() {\n    self.emit('end');\n  }).on('close', function() {\n    self.emit('close');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n}\ninherits(SFTPWrapper, EventEmitter);\n\n// stream-related methods to pass on\nSFTPWrapper.prototype.end = function() {\n  return this._stream.end();\n};\n// SFTPStream client methods\nSFTPWrapper.prototype.createReadStream = function(path, options) {\n  return this._stream.createReadStream(path, options);\n};\nSFTPWrapper.prototype.createWriteStream = function(path, options) {\n  return this._stream.createWriteStream(path, options);\n};\nSFTPWrapper.prototype.open = function(path, flags, attrs, cb) {\n  return this._stream.open(path, flags, attrs, cb);\n};\nSFTPWrapper.prototype.close = function(handle, cb) {\n  return this._stream.close(handle, cb);\n};\nSFTPWrapper.prototype.read = function(handle, buf, off, len, position, cb) {\n  return this._stream.readData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.write = function(handle, buf, off, len, position, cb) {\n  return this._stream.writeData(handle, buf, off, len, position, cb);\n};\nSFTPWrapper.prototype.fastGet = function(remotePath, localPath, opts, cb) {\n  return this._stream.fastGet(remotePath, localPath, opts, cb);\n};\nSFTPWrapper.prototype.fastPut = function(localPath, remotePath, opts, cb) {\n  return this._stream.fastPut(localPath, remotePath, opts, cb);\n};\nSFTPWrapper.prototype.readFile = function(path, options, callback_) {\n  return this._stream.readFile(path, options, callback_);\n};\nSFTPWrapper.prototype.writeFile = function(path, data, options, callback_) {\n  return this._stream.writeFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.appendFile = function(path, data, options, callback_) {\n  return this._stream.appendFile(path, data, options, callback_);\n};\nSFTPWrapper.prototype.exists = function(path, cb) {\n  return this._stream.exists(path, cb);\n};\nSFTPWrapper.prototype.unlink = function(filename, cb) {\n  return this._stream.unlink(filename, cb);\n};\nSFTPWrapper.prototype.rename = function(oldPath, newPath, cb) {\n  return this._stream.rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.mkdir = function(path, attrs, cb) {\n  return this._stream.mkdir(path, attrs, cb);\n};\nSFTPWrapper.prototype.rmdir = function(path, cb) {\n  return this._stream.rmdir(path, cb);\n};\nSFTPWrapper.prototype.readdir = function(where, opts, cb) {\n  return this._stream.readdir(where, opts, cb);\n};\nSFTPWrapper.prototype.fstat = function(handle, cb) {\n  return this._stream.fstat(handle, cb);\n};\nSFTPWrapper.prototype.stat = function(path, cb) {\n  return this._stream.stat(path, cb);\n};\nSFTPWrapper.prototype.lstat = function(path, cb) {\n  return this._stream.lstat(path, cb);\n};\nSFTPWrapper.prototype.opendir = function(path, cb) {\n  return this._stream.opendir(path, cb);\n};\nSFTPWrapper.prototype.setstat = function(path, attrs, cb) {\n  return this._stream.setstat(path, attrs, cb);\n};\nSFTPWrapper.prototype.fsetstat = function(handle, attrs, cb) {\n  return this._stream.fsetstat(handle, attrs, cb);\n};\nSFTPWrapper.prototype.futimes = function(handle, atime, mtime, cb) {\n  return this._stream.futimes(handle, atime, mtime, cb);\n};\nSFTPWrapper.prototype.utimes = function(path, atime, mtime, cb) {\n  return this._stream.utimes(path, atime, mtime, cb);\n};\nSFTPWrapper.prototype.fchown = function(handle, uid, gid, cb) {\n  return this._stream.fchown(handle, uid, gid, cb);\n};\nSFTPWrapper.prototype.chown = function(path, uid, gid, cb) {\n  return this._stream.chown(path, uid, gid, cb);\n};\nSFTPWrapper.prototype.fchmod = function(handle, mode, cb) {\n  return this._stream.fchmod(handle, mode, cb);\n};\nSFTPWrapper.prototype.chmod = function(path, mode, cb) {\n  return this._stream.chmod(path, mode, cb);\n};\nSFTPWrapper.prototype.readlink = function(path, cb) {\n  return this._stream.readlink(path, cb);\n};\nSFTPWrapper.prototype.symlink = function(targetPath, linkPath, cb) {\n  return this._stream.symlink(targetPath, linkPath, cb);\n};\nSFTPWrapper.prototype.realpath = function(path, cb) {\n  return this._stream.realpath(path, cb);\n};\n// extended requests\nSFTPWrapper.prototype.ext_openssh_rename = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_rename(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_statvfs = function(path, cb) {\n  return this._stream.ext_openssh_statvfs(path, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fstatvfs = function(handle, cb) {\n  return this._stream.ext_openssh_fstatvfs(handle, cb);\n};\nSFTPWrapper.prototype.ext_openssh_hardlink = function(oldPath, newPath, cb) {\n  return this._stream.ext_openssh_hardlink(oldPath, newPath, cb);\n};\nSFTPWrapper.prototype.ext_openssh_fsync = function(handle, cb) {\n  return this._stream.ext_openssh_fsync(handle, cb);\n};\n\nmodule.exports = SFTPWrapper;\n","var Socket = require('net').Socket;\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar path = require('path');\nvar fs = require('fs');\nvar cp = require('child_process');\n\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\nvar writeUInt32LE = require('./buffer-helpers').writeUInt32LE;\n\nvar REQUEST_IDENTITIES = 11;\nvar IDENTITIES_ANSWER = 12;\nvar SIGN_REQUEST = 13;\nvar SIGN_RESPONSE = 14;\nvar FAILURE = 5;\n\nvar RE_CYGWIN_SOCK = /^\\!<socket >(\\d+) s ([A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8}\\-[A-Z0-9]{8})/;\n\n// Format of `//./pipe/ANYTHING`, with forward slashes and backward slashes being interchangeable\nvar WINDOWS_PIPE_REGEX = /^[/\\\\][/\\\\]\\.[/\\\\]pipe[/\\\\].+/;\n\nmodule.exports = function(sockPath, key, keyType, data, cb) {\n  var sock;\n  var error;\n  var sig;\n  var datalen;\n  var keylen = 0;\n  var isSigning = Buffer.isBuffer(key);\n  var type;\n  var count = 0;\n  var siglen = 0;\n  var nkeys = 0;\n  var keys;\n  var comlen = 0;\n  var comment = false;\n  var accept;\n  var reject;\n\n  if (typeof key === 'function' && typeof keyType === 'function') {\n    // agent forwarding\n    accept = key;\n    reject = keyType;\n  } else if (isSigning) {\n    keylen = key.length;\n    datalen = data.length;\n  } else {\n    cb = key;\n    key = undefined;\n  }\n\n  function onconnect() {\n    var buf;\n    if (isSigning) {\n      /*\n        byte        SSH2_AGENTC_SIGN_REQUEST\n        string      key_blob\n        string      data\n        uint32      flags\n      */\n      var p = 9;\n      buf = Buffer.allocUnsafe(4 + 1 + 4 + keylen + 4 + datalen + 4);\n      writeUInt32BE(buf, buf.length - 4, 0);\n      buf[4] = SIGN_REQUEST;\n      writeUInt32BE(buf, keylen, 5);\n      key.copy(buf, p);\n      writeUInt32BE(buf, datalen, p += keylen);\n      data.copy(buf, p += 4);\n      writeUInt32BE(buf, 0, p += datalen);\n      sock.write(buf);\n    } else {\n      /*\n        byte        SSH2_AGENTC_REQUEST_IDENTITIES\n      */\n      sock.write(Buffer.from([0, 0, 0, 1, REQUEST_IDENTITIES]));\n    }\n  }\n  function ondata(chunk) {\n    for (var i = 0, len = chunk.length; i < len; ++i) {\n      if (type === undefined) {\n        // skip over packet length\n        if (++count === 5) {\n          type = chunk[i];\n          count = 0;\n        }\n      } else if (type === SIGN_RESPONSE) {\n        /*\n          byte        SSH2_AGENT_SIGN_RESPONSE\n          string      signature_blob\n        */\n        if (!sig) {\n          siglen <<= 8;\n          siglen += chunk[i];\n          if (++count === 4) {\n            sig = Buffer.allocUnsafe(siglen);\n            count = 0;\n          }\n        } else {\n          sig[count] = chunk[i];\n          if (++count === siglen) {\n            sock.removeAllListeners('data');\n            return sock.destroy();\n          }\n        }\n      } else if (type === IDENTITIES_ANSWER) {\n        /*\n          byte        SSH2_AGENT_IDENTITIES_ANSWER\n          uint32      num_keys\n\n        Followed by zero or more consecutive keys, encoded as:\n\n          string      public key blob\n          string      public key comment\n        */\n        if (keys === undefined) {\n          nkeys <<= 8;\n          nkeys += chunk[i];\n          if (++count === 4) {\n            keys = new Array(nkeys);\n            count = 0;\n            if (nkeys === 0) {\n              sock.removeAllListeners('data');\n              return sock.destroy();\n            }\n          }\n        } else {\n          if (!key) {\n            keylen <<= 8;\n            keylen += chunk[i];\n            if (++count === 4) {\n              key = Buffer.allocUnsafe(keylen);\n              count = 0;\n            }\n          } else if (comment === false) {\n            key[count] = chunk[i];\n            if (++count === keylen) {\n              keys[nkeys - 1] = key;\n              keylen = 0;\n              count = 0;\n              comment = true;\n              if (--nkeys === 0) {\n                key = undefined;\n                sock.removeAllListeners('data');\n                return sock.destroy();\n              }\n            }\n          } else if (comment === true) {\n            comlen <<= 8;\n            comlen += chunk[i];\n            if (++count === 4) {\n              count = 0;\n              if (comlen > 0)\n                comment = comlen;\n              else {\n                key = undefined;\n                comment = false;\n              }\n              comlen = 0;\n            }\n          } else {\n            // skip comments\n            if (++count === comment) {\n              comment = false;\n              count = 0;\n              key = undefined;\n            }\n          }\n        }\n      } else if (type === FAILURE) {\n        if (isSigning)\n          error = new Error('Agent unable to sign data');\n        else\n          error = new Error('Unable to retrieve list of keys from agent');\n        sock.removeAllListeners('data');\n        return sock.destroy();\n      }\n    }\n  }\n  function onerror(err) {\n    error = err;\n  }\n  function onclose() {\n    if (error)\n      cb(error);\n    else if ((isSigning && !sig) || (!isSigning && !keys))\n      cb(new Error('Unexpected disconnection from agent'));\n    else if (isSigning && sig)\n      cb(undefined, sig);\n    else if (!isSigning && keys)\n      cb(undefined, keys);\n  }\n\n  if (process.platform === 'win32' && !WINDOWS_PIPE_REGEX.test(sockPath)) {\n    if (sockPath === 'pageant') {\n      // Pageant (PuTTY authentication agent)\n      sock = new PageantSock();\n    } else {\n      // cygwin ssh-agent instance\n      var triedCygpath = false;\n      fs.readFile(sockPath, function readCygsocket(err, data) {\n        if (err) {\n          if (triedCygpath)\n            return cb(new Error('Invalid cygwin unix socket path'));\n          // try using `cygpath` to convert a possible *nix-style path to the\n          // real Windows path before giving up ...\n          cp.exec('cygpath -w \"' + sockPath + '\"',\n                  function(err, stdout, stderr) {\n            if (err || stdout.length === 0)\n              return cb(new Error('Invalid cygwin unix socket path'));\n            triedCygpath = true;\n            sockPath = stdout.toString().replace(/[\\r\\n]/g, '');\n            fs.readFile(sockPath, readCygsocket);\n          });\n          return;\n        }\n\n        var m;\n        if (m = RE_CYGWIN_SOCK.exec(data.toString('ascii'))) {\n          var port;\n          var secret;\n          var secretbuf;\n          var state;\n          var bc = 0;\n          var isRetrying = false;\n          var inbuf = [];\n          var credsbuf = Buffer.allocUnsafe(12);\n          var i;\n          var j;\n\n          // use 0 for pid, uid, and gid to ensure we get an error and also\n          // a valid uid and gid from cygwin so that we don't have to figure it\n          // out ourselves\n          credsbuf.fill(0);\n\n          // parse cygwin unix socket file contents\n          port = parseInt(m[1], 10);\n          secret = m[2].replace(/\\-/g, '');\n          secretbuf = Buffer.allocUnsafe(16);\n          for (i = 0, j = 0; j < 32; ++i,j+=2)\n            secretbuf[i] = parseInt(secret.substring(j, j + 2), 16);\n\n          // convert to host order (always LE for Windows)\n          for (i = 0; i < 16; i += 4)\n            writeUInt32LE(secretbuf, readUInt32BE(secretbuf, i), i);\n\n          function _onconnect() {\n            bc = 0;\n            state = 'secret';\n            sock.write(secretbuf);\n          }\n          function _ondata(data) {\n            bc += data.length;\n            if (state === 'secret') {\n              // the secret we sent is echoed back to us by cygwin, not sure of\n              // the reason for that, but we ignore it nonetheless ...\n              if (bc === 16) {\n                bc = 0;\n                state = 'creds';\n                sock.write(credsbuf);\n              }\n            } else if (state === 'creds') {\n              // if this is the first attempt, make sure to gather the valid\n              // uid and gid for our next attempt\n              if (!isRetrying)\n                inbuf.push(data);\n\n              if (bc === 12) {\n                sock.removeListener('connect', _onconnect);\n                sock.removeListener('data', _ondata);\n                sock.removeListener('close', _onclose);\n                if (isRetrying) {\n                  addSockListeners();\n                  sock.emit('connect');\n                } else {\n                  isRetrying = true;\n                  credsbuf = Buffer.concat(inbuf);\n                  writeUInt32LE(credsbuf, process.pid, 0);\n                  sock.destroy();\n                  tryConnect();\n                }\n              }\n            }\n          }\n          function _onclose() {\n            cb(new Error('Problem negotiating cygwin unix socket security'));\n          }\n          function tryConnect() {\n            sock = new Socket();\n            sock.once('connect', _onconnect);\n            sock.on('data', _ondata);\n            sock.once('close', _onclose);\n            sock.connect(port);\n          }\n          tryConnect();\n        } else\n          cb(new Error('Malformed cygwin unix socket file'));\n      });\n      return;\n    }\n  } else\n    sock = new Socket();\n\n  function addSockListeners() {\n    if (!accept && !reject) {\n      sock.once('connect', onconnect);\n      sock.on('data', ondata);\n      sock.once('error', onerror);\n      sock.once('close', onclose);\n    } else {\n      var chan;\n      sock.once('connect', function() {\n        chan = accept();\n        var isDone = false;\n        function onDone() {\n          if (isDone)\n            return;\n          sock.destroy();\n          isDone = true;\n        }\n        chan.once('end', onDone)\n            .once('close', onDone)\n            .on('data', function(data) {\n          sock.write(data);\n        });\n        sock.on('data', function(data) {\n          chan.write(data);\n        });\n      });\n      sock.once('close', function() {\n        if (!chan)\n          reject();\n      });\n    }\n  }\n  addSockListeners();\n  sock.connect(sockPath);\n};\n\n\n// win32 only ------------------------------------------------------------------\nif (process.platform === 'win32') {\n  var RET_ERR_BADARGS = 10;\n  var RET_ERR_UNAVAILABLE = 11;\n  var RET_ERR_NOMAP = 12;\n  var RET_ERR_BINSTDIN = 13;\n  var RET_ERR_BINSTDOUT = 14;\n  var RET_ERR_BADLEN = 15;\n\n  var ERROR = {};\n  var EXEPATH = path.resolve(__dirname, '..', 'util/pagent.exe');\n  ERROR[RET_ERR_BADARGS] = new Error('Invalid pagent.exe arguments');\n  ERROR[RET_ERR_UNAVAILABLE] = new Error('Pageant is not running');\n  ERROR[RET_ERR_NOMAP] = new Error('pagent.exe could not create an mmap');\n  ERROR[RET_ERR_BINSTDIN] = new Error('pagent.exe could not set mode for stdin');\n  ERROR[RET_ERR_BINSTDOUT] = new Error('pagent.exe could not set mode for stdout');\n  ERROR[RET_ERR_BADLEN] = new Error('pagent.exe did not get expected input payload');\n\n  function PageantSock() {\n    this.proc = undefined;\n    this.buffer = null;\n  }\n  inherits(PageantSock, EventEmitter);\n\n  PageantSock.prototype.write = function(buf) {\n    if (this.buffer === null)\n      this.buffer = buf;\n    else {\n      this.buffer = Buffer.concat([this.buffer, buf],\n                                  this.buffer.length + buf.length);\n    }\n    // Wait for at least all length bytes\n    if (this.buffer.length < 4)\n      return;\n\n    var len = readUInt32BE(this.buffer, 0);\n    // Make sure we have a full message before querying pageant\n    if ((this.buffer.length - 4) < len)\n      return;\n\n    buf = this.buffer.slice(0, 4 + len);\n    if (this.buffer.length > (4 + len))\n      this.buffer = this.buffer.slice(4 + len);\n    else\n      this.buffer = null;\n\n    var self = this;\n    var proc;\n    var hadError = false;\n    proc = this.proc = cp.spawn(EXEPATH, [ buf.length ]);\n    proc.stdout.on('data', function(data) {\n      self.emit('data', data);\n    });\n    proc.once('error', function(err) {\n      if (!hadError) {\n        hadError = true;\n        self.emit('error', err);\n      }\n    });\n    proc.once('close', function(code) {\n      self.proc = undefined;\n      if (ERROR[code] && !hadError) {\n        hadError = true;\n        self.emit('error', ERROR[code]);\n      }\n      self.emit('close', hadError);\n    });\n    proc.stdin.end(buf);\n  };\n  PageantSock.prototype.end = PageantSock.prototype.destroy = function() {\n    this.buffer = null;\n    if (this.proc) {\n      this.proc.kill();\n      this.proc = undefined;\n    }\n  };\n  PageantSock.prototype.connect = function() {\n    this.emit('connect');\n  };\n}\n","module.exports = {\n  readUInt32BE: function readUInt32BE(buf, offset) {\n    return buf[offset++] * 16777216\n           + buf[offset++] * 65536\n           + buf[offset++] * 256\n           + buf[offset];\n  },\n  writeUInt32BE: function writeUInt32BE(buf, value, offset) {\n    buf[offset++] = (value >>> 24);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = value;\n    return offset;\n  },\n  writeUInt32LE: function writeUInt32LE(buf, value, offset) {\n    buf[offset++] = value;\n    buf[offset++] = (value >>> 8);\n    buf[offset++] = (value >>> 16);\n    buf[offset++] = (value >>> 24);\n    return offset;\n  }\n};\n","var crypto = require('crypto');\nvar Socket = require('net').Socket;\nvar dnsLookup = require('dns').lookup;\nvar EventEmitter = require('events').EventEmitter;\nvar inherits = require('util').inherits;\nvar HASHES = crypto.getHashes();\n\nvar ssh2_streams = require('ssh2-streams');\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar BUGS = consts.BUGS;\nvar ALGORITHMS = consts.ALGORITHMS;\nvar EDDSA_SUPPORTED = consts.EDDSA_SUPPORTED;\nvar parseKey = ssh2_streams.utils.parseKey;\n\nvar HTTPAgents = require('./http-agents');\nvar Channel = require('./Channel');\nvar agentQuery = require('./agent');\nvar SFTPWrapper = require('./SFTPWrapper');\nvar readUInt32BE = require('./buffer-helpers').readUInt32BE;\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\\d)|(?:\\d{2,})/;\nvar DEBUG_NOOP = function(msg) {};\n\nfunction Client() {\n  if (!(this instanceof Client))\n    return new Client();\n\n  EventEmitter.call(this);\n\n  this.config = {\n    host: undefined,\n    port: undefined,\n    localAddress: undefined,\n    localPort: undefined,\n    forceIPv4: undefined,\n    forceIPv6: undefined,\n    keepaliveCountMax: undefined,\n    keepaliveInterval: undefined,\n    readyTimeout: undefined,\n\n    username: undefined,\n    password: undefined,\n    privateKey: undefined,\n    tryKeyboard: undefined,\n    agent: undefined,\n    allowAgentFwd: undefined,\n    authHandler: undefined,\n\n    hostHashAlgo: undefined,\n    hostHashCb: undefined,\n    strictVendor: undefined,\n    debug: undefined\n  };\n\n  this._readyTimeout = undefined;\n  this._channels = undefined;\n  this._callbacks = undefined;\n  this._forwarding = undefined;\n  this._forwardingUnix = undefined;\n  this._acceptX11 = undefined;\n  this._agentFwdEnabled = undefined;\n  this._curChan = undefined;\n  this._remoteVer = undefined;\n\n  this._sshstream = undefined;\n  this._sock = undefined;\n  this._resetKA = undefined;\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.connect = function(cfg) {\n  var self = this;\n\n  if (this._sock && this._sock.writable) {\n    this.once('close', function() {\n      self.connect(cfg);\n    });\n    this.end();\n    return;\n  }\n\n  this.config.host = cfg.hostname || cfg.host || 'localhost';\n  this.config.port = cfg.port || 22;\n  this.config.localAddress = (typeof cfg.localAddress === 'string'\n                              ? cfg.localAddress\n                              : undefined);\n  this.config.localPort = (typeof cfg.localPort === 'string'\n                           || typeof cfg.localPort === 'number'\n                           ? cfg.localPort\n                           : undefined);\n  this.config.forceIPv4 = cfg.forceIPv4 || false;\n  this.config.forceIPv6 = cfg.forceIPv6 || false;\n  this.config.keepaliveCountMax = (typeof cfg.keepaliveCountMax === 'number'\n                                   && cfg.keepaliveCountMax >= 0\n                                   ? cfg.keepaliveCountMax\n                                   : 3);\n  this.config.keepaliveInterval = (typeof cfg.keepaliveInterval === 'number'\n                                   && cfg.keepaliveInterval > 0\n                                   ? cfg.keepaliveInterval\n                                   : 0);\n  this.config.readyTimeout = (typeof cfg.readyTimeout === 'number'\n                              && cfg.readyTimeout >= 0\n                              ? cfg.readyTimeout\n                              : 20000);\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  var i;\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n      }\n      algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n  if (algorithms.compress === undefined) {\n    if (cfg.compress) {\n      algorithms.compress = ['zlib@openssh.com', 'zlib'];\n      if (cfg.compress !== 'force')\n        algorithms.compress.push('none');\n    } else if (cfg.compress === false)\n      algorithms.compress = ['none'];\n  }\n\n  if (typeof cfg.username === 'string')\n    this.config.username = cfg.username;\n  else if (typeof cfg.user === 'string')\n    this.config.username = cfg.user;\n  else\n    throw new Error('Invalid username');\n\n  this.config.password = (typeof cfg.password === 'string'\n                          ? cfg.password\n                          : undefined);\n  this.config.privateKey = (typeof cfg.privateKey === 'string'\n                            || Buffer.isBuffer(cfg.privateKey)\n                            ? cfg.privateKey\n                            : undefined);\n  this.config.localHostname = (typeof cfg.localHostname === 'string'\n                               && cfg.localHostname.length\n                               ? cfg.localHostname\n                               : undefined);\n  this.config.localUsername = (typeof cfg.localUsername === 'string'\n                               && cfg.localUsername.length\n                               ? cfg.localUsername\n                               : undefined);\n  this.config.tryKeyboard = (cfg.tryKeyboard === true);\n  this.config.agent = (typeof cfg.agent === 'string' && cfg.agent.length\n                       ? cfg.agent\n                       : undefined);\n  this.config.allowAgentFwd = (cfg.agentForward === true\n                               && this.config.agent !== undefined);\n  var authHandler = this.config.authHandler = (\n    typeof cfg.authHandler === 'function' ? cfg.authHandler : undefined\n  );\n\n  this.config.strictVendor = (typeof cfg.strictVendor === 'boolean'\n                              ? cfg.strictVendor\n                              : true);\n\n  var debug = this.config.debug = (typeof cfg.debug === 'function'\n                                   ? cfg.debug\n                                   : DEBUG_NOOP);\n\n  if (cfg.agentForward === true && !this.config.allowAgentFwd)\n    throw new Error('You must set a valid agent path to allow agent forwarding');\n\n  var callbacks = this._callbacks = [];\n  this._channels = {};\n  this._forwarding = {};\n  this._forwardingUnix = {};\n  this._acceptX11 = 0;\n  this._agentFwdEnabled = false;\n  this._curChan = -1;\n  this._remoteVer = undefined;\n  var privateKey;\n\n  if (this.config.privateKey) {\n    privateKey = parseKey(this.config.privateKey, cfg.passphrase);\n    if (privateKey instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privateKey.message);\n    if (Array.isArray(privateKey))\n      privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now\n    if (privateKey.getPrivatePEM() === null)\n      throw new Error('privateKey value does not contain a (valid) private key');\n  }\n\n  var stream = this._sshstream = new SSH2Stream({\n    algorithms: algorithms,\n    debug: (debug === DEBUG_NOOP ? undefined : debug)\n  });\n  var sock = this._sock = (cfg.sock || new Socket());\n\n  // drain stderr if we are connection hopping using an exec stream\n  if (this._sock.stderr && typeof this._sock.stderr.resume === 'function')\n    this._sock.stderr.resume();\n\n  // keepalive-related\n  var kainterval = this.config.keepaliveInterval;\n  var kacountmax = this.config.keepaliveCountMax;\n  var kacount = 0;\n  var katimer;\n  function sendKA() {\n    if (++kacount > kacountmax) {\n      clearInterval(katimer);\n      if (sock.readable) {\n        var err = new Error('Keepalive timeout');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }\n      return;\n    }\n    if (sock.writable) {\n      // append dummy callback to keep correct callback order\n      callbacks.push(resetKA);\n      stream.ping();\n    } else\n      clearInterval(katimer);\n  }\n  function resetKA() {\n    if (kainterval > 0) {\n      kacount = 0;\n      clearInterval(katimer);\n      if (sock.writable)\n        katimer = setInterval(sendKA, kainterval);\n    }\n  }\n  this._resetKA = resetKA;\n\n  stream.on('USERAUTH_BANNER', function(msg) {\n    self.emit('banner', msg);\n  });\n\n  sock.on('connect', function() {\n    debug('DEBUG: Client: Connected');\n    self.emit('connect');\n    if (!cfg.sock)\n      stream.pipe(sock).pipe(stream);\n  }).on('timeout', function() {\n    self.emit('timeout');\n  }).on('error', function(err) {\n    clearTimeout(self._readyTimeout);\n    err.level = 'client-socket';\n    self.emit('error', err);\n  }).on('end', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('end');\n  }).on('close', function() {\n    stream.unpipe(sock);\n    clearTimeout(self._readyTimeout);\n    clearInterval(katimer);\n    self.emit('close');\n\n    // notify outstanding channel requests of disconnection ...\n    var callbacks_ = callbacks;\n    var err = new Error('No response from server');\n    callbacks = self._callbacks = [];\n    for (i = 0; i < callbacks_.length; ++i)\n      callbacks_[i](err);\n\n    // simulate error for any channels waiting to be opened. this is safe\n    // against successfully opened channels because the success and failure\n    // event handlers are automatically removed when a success/failure response\n    // is received\n    var channels = self._channels;\n    var chanNos = Object.keys(channels);\n    self._channels = {};\n    for (i = 0; i < chanNos.length; ++i) {\n      var ev1 = stream.emit('CHANNEL_OPEN_FAILURE:' + chanNos[i], err);\n      // emitting CHANNEL_CLOSE should be safe too and should help for any\n      // special channels which might otherwise keep the process alive, such\n      // as agent forwarding channels which have open unix sockets ...\n      var ev2 = stream.emit('CHANNEL_CLOSE:' + chanNos[i]);\n      var earlyCb;\n      if (!ev1 && !ev2 && (earlyCb = channels[chanNos[i]])\n          && typeof earlyCb === 'function') {\n        earlyCb(err);\n      }\n    }\n  });\n  stream.on('drain', function() {\n    self.emit('drain');\n  }).once('header', function(header) {\n    self._remoteVer = header.versions.software;\n    if (header.greeting)\n      self.emit('greeting', header.greeting);\n  }).on('continue', function() {\n    self.emit('continue');\n  }).on('error', function(err) {\n    if (err.level === undefined)\n      err.level = 'protocol';\n    else if (err.level === 'handshake')\n      clearTimeout(self._readyTimeout);\n    self.emit('error', err);\n  }).on('end', function() {\n    sock.resume();\n  });\n\n  if (typeof cfg.hostVerifier === 'function') {\n    if (HASHES.indexOf(cfg.hostHash) === -1)\n      throw new Error('Invalid host hash algorithm: ' + cfg.hostHash);\n    var hashCb = cfg.hostVerifier;\n    var hasher = crypto.createHash(cfg.hostHash);\n    stream.once('fingerprint', function(key, verify) {\n      hasher.update(key);\n      var ret = hashCb(hasher.digest('hex'), verify);\n      if (ret !== undefined)\n        verify(ret);\n    });\n  }\n\n  // begin authentication handling =============================================\n  var curAuth;\n  var curPartial = null;\n  var curAuthsLeft = null;\n  var agentKeys;\n  var agentKeyPos = 0;\n  var authsAllowed = ['none'];\n  if (this.config.password !== undefined)\n    authsAllowed.push('password');\n  if (privateKey !== undefined)\n    authsAllowed.push('publickey');\n  if (this.config.agent !== undefined)\n    authsAllowed.push('agent');\n  if (this.config.tryKeyboard)\n    authsAllowed.push('keyboard-interactive');\n  if (privateKey !== undefined\n      && this.config.localHostname !== undefined\n      && this.config.localUsername !== undefined) {\n    authsAllowed.push('hostbased');\n  }\n\n  if (authHandler === undefined) {\n    var authPos = 0;\n    authHandler = function authHandler(authsLeft, partial, cb) {\n      if (authPos === authsAllowed.length)\n        return false;\n      return authsAllowed[authPos++];\n    };\n  }\n\n  var hasSentAuth = false;\n  function doNextAuth(authName) {\n    hasSentAuth = true;\n    if (authName === false) {\n      stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n      stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      var err = new Error('All configured authentication methods failed');\n      err.level = 'client-authentication';\n      self.emit('error', err);\n      if (stream.writable)\n        self.end();\n      return;\n    }\n    if (authsAllowed.indexOf(authName) === -1)\n      throw new Error('Authentication method not allowed: ' + authName);\n    curAuth = authName;\n    switch (curAuth) {\n      case 'password':\n        stream.authPassword(self.config.username, self.config.password);\n      break;\n      case 'publickey':\n        stream.authPK(self.config.username, privateKey);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      break;\n      case 'hostbased':\n        function hostbasedCb(buf, cb) {\n          var signature = privateKey.sign(buf);\n          if (signature instanceof Error) {\n            signature.message = 'Error while signing data with privateKey: '\n                                + signature.message;\n            signature.level = 'client-authentication';\n            self.emit('error', signature);\n            return tryNextAuth();\n          }\n\n          cb(signature);\n        }\n        stream.authHostbased(self.config.username,\n                             privateKey,\n                             self.config.localHostname,\n                             self.config.localUsername,\n                             hostbasedCb);\n      break;\n      case 'agent':\n        agentQuery(self.config.agent, function(err, keys) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n            agentKeys = undefined;\n            return tryNextAuth();\n          } else if (keys.length === 0) {\n            debug('DEBUG: Agent: No keys stored in agent');\n            agentKeys = undefined;\n            return tryNextAuth();\n          }\n\n          agentKeys = keys;\n          agentKeyPos = 0;\n\n          stream.authPK(self.config.username, keys[0]);\n          stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n        });\n      break;\n      case 'keyboard-interactive':\n        stream.authKeyboard(self.config.username);\n        stream.on('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n      break;\n      case 'none':\n        stream.authNone(self.config.username);\n      break;\n    }\n  }\n  function tryNextAuth() {\n    hasSentAuth = false;\n    var auth = authHandler(curAuthsLeft, curPartial, doNextAuth);\n    if (hasSentAuth || auth === undefined)\n      return;\n    doNextAuth(auth);\n  }\n  function tryNextAgentKey() {\n    if (curAuth === 'agent') {\n      if (agentKeyPos >= agentKeys.length)\n        return;\n      if (++agentKeyPos >= agentKeys.length) {\n        debug('DEBUG: Agent: No more keys left to try');\n        debug('DEBUG: Client: agent auth failed');\n        agentKeys = undefined;\n        tryNextAuth();\n      } else {\n        debug('DEBUG: Agent: Trying key #' + (agentKeyPos + 1));\n        stream.authPK(self.config.username, agentKeys[agentKeyPos]);\n        stream.once('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n      }\n    }\n  }\n  function onUSERAUTH_INFO_REQUEST(name, instructions, lang, prompts) {\n    var nprompts = (Array.isArray(prompts) ? prompts.length : 0);\n    if (nprompts === 0) {\n      debug('DEBUG: Client: Sending automatic USERAUTH_INFO_RESPONSE');\n      return stream.authInfoRes();\n    }\n    // we sent a keyboard-interactive user authentication request and now the\n    // server is sending us the prompts we need to present to the user\n    self.emit('keyboard-interactive',\n              name,\n              instructions,\n              lang,\n              prompts,\n              function(answers) {\n                stream.authInfoRes(answers);\n              }\n    );\n  }\n  function onUSERAUTH_PK_OK() {\n    if (curAuth === 'agent') {\n      var agentKey = agentKeys[agentKeyPos];\n      var keyLen = readUInt32BE(agentKey, 0);\n      var pubKeyFullType = agentKey.toString('ascii', 4, 4 + keyLen);\n      var pubKeyType = pubKeyFullType.slice(4);\n      // Check that we support the key type first\n      // TODO: move key type checking logic to ssh2-streams\n      switch (pubKeyFullType) {\n        case 'ssh-rsa':\n        case 'ssh-dss':\n        case 'ecdsa-sha2-nistp256':\n        case 'ecdsa-sha2-nistp384':\n        case 'ecdsa-sha2-nistp521':\n          break;\n        default:\n          if (EDDSA_SUPPORTED && pubKeyFullType === 'ssh-ed25519')\n            break;\n          debug('DEBUG: Agent: Skipping unsupported key type: '\n                + pubKeyFullType);\n          return tryNextAgentKey();\n      }\n      stream.authPK(self.config.username, \n                    agentKey,\n                    function(buf, cb) {\n        agentQuery(self.config.agent,\n                   agentKey,\n                   pubKeyType,\n                   buf,\n                   function(err, signed) {\n          if (err) {\n            err.level = 'agent';\n            self.emit('error', err);\n          } else {\n            var sigFullTypeLen = readUInt32BE(signed, 0);\n            if (4 + sigFullTypeLen + 4 < signed.length) {\n              var sigFullType = signed.toString('ascii', 4, 4 + sigFullTypeLen);\n              if (sigFullType !== pubKeyFullType) {\n                err = new Error('Agent key/signature type mismatch');\n                err.level = 'agent';\n                self.emit('error', err);\n              } else {\n                // skip algoLen + algo + sigLen\n                return cb(signed.slice(4 + sigFullTypeLen + 4));\n              }\n            }\n          }\n\n          tryNextAgentKey();\n        });\n      });\n    } else if (curAuth === 'publickey') {\n      stream.authPK(self.config.username, privateKey, function(buf, cb) {\n        var signature = privateKey.sign(buf);\n        if (signature instanceof Error) {\n          signature.message = 'Error while signing data with privateKey: '\n                              + signature.message;\n          signature.level = 'client-authentication';\n          self.emit('error', signature);\n          return tryNextAuth();\n        }\n        cb(signature);\n      });\n    }\n  }\n  function onUSERAUTH_FAILURE(authsLeft, partial) {\n    stream.removeListener('USERAUTH_PK_OK', onUSERAUTH_PK_OK);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n    if (curAuth === 'agent') {\n      debug('DEBUG: Client: Agent key #' + (agentKeyPos + 1) + ' failed');\n      return tryNextAgentKey();\n    } else {\n      debug('DEBUG: Client: ' + curAuth + ' auth failed');\n    }\n\n    curPartial = partial;\n    curAuthsLeft = authsLeft;\n    tryNextAuth();\n  }\n  stream.once('USERAUTH_SUCCESS', function() {\n    stream.removeListener('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n    stream.removeListener('USERAUTH_INFO_REQUEST', onUSERAUTH_INFO_REQUEST);\n\n    // start keepalive mechanism\n    resetKA();\n\n    clearTimeout(self._readyTimeout);\n\n    self.emit('ready');\n  }).on('USERAUTH_FAILURE', onUSERAUTH_FAILURE);\n  // end authentication handling ===============================================\n\n  // handle initial handshake completion\n  stream.once('ready', function() {\n    stream.service('ssh-userauth');\n    stream.once('SERVICE_ACCEPT', function(svcName) {\n      if (svcName === 'ssh-userauth')\n        tryNextAuth();\n    });\n  });\n\n  // handle incoming requests from server, typically a forwarded TCP or X11\n  // connection\n  stream.on('CHANNEL_OPEN', function(info) {\n    onCHANNEL_OPEN(self, info);\n  });\n\n  // handle responses for tcpip-forward and other global requests\n  stream.on('REQUEST_SUCCESS', function(data) {\n    if (callbacks.length)\n      callbacks.shift()(false, data);\n  }).on('REQUEST_FAILURE', function() {\n    if (callbacks.length)\n      callbacks.shift()(true);\n  });\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    // auto-reject all global requests, this can be especially useful if the\n    // server is sending us dummy keepalive global requests\n    if (wantReply)\n      stream.requestFailure();\n  });\n\n  if (!cfg.sock) {\n    var host = this.config.host;\n    var forceIPv4 = this.config.forceIPv4;\n    var forceIPv6 = this.config.forceIPv6;\n\n    debug('DEBUG: Client: Trying '\n          + host\n          + ' on port '\n          + this.config.port\n          + ' ...');\n\n    function doConnect() {\n      startTimeout();\n      self._sock.connect({\n        host: host,\n        port: self.config.port,\n        localAddress: self.config.localAddress,\n        localPort: self.config.localPort\n      });\n      self._sock.setNoDelay(true);\n      self._sock.setMaxListeners(0);\n      self._sock.setTimeout(typeof cfg.timeout === 'number' ? cfg.timeout : 0);\n    }\n\n    if ((!forceIPv4 && !forceIPv6) || (forceIPv4 && forceIPv6))\n      doConnect();\n    else {\n      dnsLookup(host, (forceIPv4 ? 4 : 6), function(err, address, family) {\n        if (err) {\n          var error = new Error('Error while looking up '\n                                + (forceIPv4 ? 'IPv4' : 'IPv6')\n                                + ' address for host '\n                                + host\n                                + ': ' + err);\n          clearTimeout(self._readyTimeout);\n          error.level = 'client-dns';\n          self.emit('error', error);\n          self.emit('close');\n          return;\n        }\n        host = address;\n        doConnect();\n      });\n    }\n  } else {\n    startTimeout();\n    stream.pipe(sock).pipe(stream);\n  }\n\n  function startTimeout() {\n    if (self.config.readyTimeout > 0) {\n      self._readyTimeout = setTimeout(function() {\n        var err = new Error('Timed out while waiting for handshake');\n        err.level = 'client-timeout';\n        self.emit('error', err);\n        sock.destroy();\n      }, self.config.readyTimeout);\n    }\n  }\n};\n\nClient.prototype.end = function() {\n  if (this._sock\n      && this._sock.writable\n      && this._sshstream\n      && this._sshstream.writable)\n    return this._sshstream.disconnect();\n  return false;\n};\n\nClient.prototype.destroy = function() {\n  this._sock && this._sock.destroy();\n};\n\nClient.prototype.exec = function(cmd, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var extraOpts = { allowHalfOpen: (opts.allowHalfOpen !== false) };\n\n  return openChannel(this, 'session', extraOpts, function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() {\n        reqAgentFwd(chan, reqCb);\n      });\n    }\n\n    if (typeof opts === 'object' && opts !== null) {\n      if (typeof opts.env === 'object' && opts.env !== null)\n        reqEnv(chan, opts.env);\n      if ((typeof opts.pty === 'object' && opts.pty !== null)\n          || opts.pty === true) {\n        todo.push(function() { reqPty(chan, opts.pty, reqCb); });\n      }\n      if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n          || opts.x11 === 'number'\n          || opts.x11 === true) {\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n      }\n    }\n\n    todo.push(function() { reqExec(chan, cmd, opts, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.shell = function(wndopts, opts, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // start an interactive terminal/shell session\n  var self = this;\n\n  if (typeof wndopts === 'function') {\n    cb = wndopts;\n    wndopts = opts = undefined;\n  } else if (typeof opts === 'function') {\n    cb = opts;\n    opts = undefined;\n  }\n  if (wndopts && (wndopts.x11 !== undefined || wndopts.env !== undefined)) {\n    opts = wndopts;\n    wndopts = undefined;\n  }\n\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    var todo = [];\n\n    function reqCb(err) {\n      if (err) {\n        chan.close();\n        return cb(err);\n      }\n      if (todo.length)\n        todo.shift()();\n    }\n\n    if (self.config.allowAgentFwd === true\n        || (opts\n            && opts.agentForward === true\n            && self.config.agent !== undefined)) {\n      todo.push(function() { reqAgentFwd(chan, reqCb); });\n    }\n\n    if (wndopts !== false)\n      todo.push(function() { reqPty(chan, wndopts, reqCb); });\n\n    if (typeof opts === 'object' && opts !== null) {\n      if (typeof opts.env === 'object' && opts.env !== null)\n        reqEnv(chan, opts.env);\n      if ((typeof opts.x11 === 'object' && opts.x11 !== null)\n          || opts.x11 === 'number'\n          || opts.x11 === true) {\n        todo.push(function() { reqX11(chan, opts.x11, reqCb); });\n      }\n    }\n\n    todo.push(function() { reqShell(chan, cb); });\n    todo.shift()();\n  });\n};\n\nClient.prototype.subsys = function(name, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n\treturn openChannel(this, 'session', function(err, chan) {\n\t\tif (err)\n\t\t\treturn cb(err);\n\n\t\treqSubsystem(chan, name, function(err, stream) {\n\t\t\tif (err)\n\t\t\t\treturn cb(err);\n\n\t\t\tcb(undefined, stream);\n\t\t});\n\t});\n};\n\nClient.prototype.sftp = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var self = this;\n\n  // start an SFTP session\n  return openChannel(this, 'session', function(err, chan) {\n    if (err)\n      return cb(err);\n\n    reqSubsystem(chan, 'sftp', function(err, stream) {\n      if (err)\n        return cb(err);\n\n      var serverIdentRaw = self._sshstream._state.incoming.identRaw;\n      var cfg = { debug: self.config.debug };\n      var sftp = new SFTPStream(cfg, serverIdentRaw);\n\n      function onError(err) {\n        sftp.removeListener('ready', onReady);\n        stream.removeListener('exit', onExit);\n        cb(err);\n      }\n\n      function onReady() {\n        sftp.removeListener('error', onError);\n        stream.removeListener('exit', onExit);\n        cb(undefined, new SFTPWrapper(sftp));\n      }\n\n      function onExit(code, signal) {\n        sftp.removeListener('ready', onReady);\n        sftp.removeListener('error', onError);\n        var msg;\n        if (typeof code === 'number') {\n          msg = 'Received exit code '\n                + code\n                + ' while establishing SFTP session';\n        } else {\n          msg = 'Received signal '\n                + signal\n                + ' while establishing SFTP session';\n        }\n        var err = new Error(msg);\n        err.code = code;\n        err.signal = signal;\n        cb(err);\n      }\n\n      sftp.once('error', onError)\n          .once('ready', onReady)\n          .once('close', function() {\n            stream.end();\n          });\n\n      // OpenSSH server sends an exit-status if there was a problem spinning up\n      // an sftp server child process, so we listen for that here in order to\n      // properly raise an error.\n      stream.once('exit', onExit);\n\n      sftp.pipe(stream).pipe(sftp);\n    });\n  });\n};\n\nClient.prototype.forwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request for the server to start forwarding TCP connections to us\n  // on a particular address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err, data) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to bind to ' + bindAddr + ':' + bindPort));\n      }\n\n      var realPort = bindPort;\n      if (bindPort === 0 && data && data.length >= 4) {\n        realPort = readUInt32BE(data, 0);\n        if (!(self._sshstream.remoteBugs & BUGS.DYN_RPORT_BUG))\n          bindPort = realPort;\n      }\n\n      self._forwarding[bindAddr + ':' + bindPort] = realPort;\n\n      cb(undefined, realPort);\n    });\n  }\n\n  return this._sshstream.tcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.unforwardIn = function(bindAddr, bindPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to stop forwarding us new connections for a particular\n  // address and port\n\n  var self = this;\n  var wantReply = (typeof cb === 'function');\n\n  if (wantReply) {\n    this._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to unbind from '\n                              + bindAddr + ':' + bindPort));\n      }\n\n      delete self._forwarding[bindAddr + ':' + bindPort];\n\n      cb();\n    });\n  }\n\n  return this._sshstream.cancelTcpipForward(bindAddr, bindPort, wantReply);\n};\n\nClient.prototype.forwardOut = function(srcIP, srcPort, dstIP, dstPort, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  // send a request to forward a TCP connection to the server\n\n  var cfg = {\n    srcIP: srcIP,\n    srcPort: srcPort,\n    dstIP: dstIP,\n    dstPort: dstPort\n  };\n\n  return openChannel(this, 'direct-tcpip', cfg, cb);\n};\n\nClient.prototype.openssh_noMoreSessions = function(cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to disable future sessions'));\n        }\n\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_noMoreSessions(wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to bind to ' + socketPath));\n        }\n        self._forwardingUnix[socketPath] = true;\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_streamLocalForward(socketPath, wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_unforwardInStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  var wantReply = (typeof cb === 'function');\n  var self = this;\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    if (wantReply) {\n      this._callbacks.push(function(had_err) {\n        if (had_err) {\n          return cb(had_err !== true\n                    ? had_err\n                    : new Error('Unable to unbind on ' + socketPath));\n        }\n        delete self._forwardingUnix[socketPath];\n        cb();\n      });\n    }\n\n    return this._sshstream.openssh_cancelStreamLocalForward(socketPath,\n                                                            wantReply);\n  } else if (wantReply) {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  if (!this._sock\n      || !this._sock.writable\n      || !this._sshstream\n      || !this._sshstream.writable)\n    throw new Error('Not connected');\n\n  if (!this.config.strictVendor\n      || (this.config.strictVendor && RE_OPENSSH.test(this._remoteVer))) {\n    var cfg = { socketPath: socketPath };\n    return openChannel(this, 'direct-streamlocal@openssh.com', cfg, cb);\n  } else {\n    process.nextTick(function() {\n      cb(new Error('strictVendor enabled and server is not OpenSSH or compatible version'));\n    });\n  }\n\n  return true;\n};\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the server to open a channel for some purpose\n  // (e.g. session (sftp, exec, shell), or forwarding a TCP connection\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = cb;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, onSuccess)\n           .once('CHANNEL_OPEN_FAILURE:' + localChan, onFailure)\n           .once('CHANNEL_CLOSE:' + localChan, onFailure);\n\n  if (type === 'session')\n    ret = sshstream.session(localChan, initWindow, maxPacket);\n  else if (type === 'direct-tcpip')\n    ret = sshstream.directTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'direct-streamlocal@openssh.com') {\n    ret = sshstream.openssh_directStreamLocal(localChan,\n                                              initWindow,\n                                              maxPacket,\n                                              opts);\n  }\n\n  return ret;\n\n  function onSuccess(info) {\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self));\n  }\n\n  function onFailure(info) {\n    sshstream.removeListener('CHANNEL_OPEN_CONFIRMATION:' + localChan,\n                             onSuccess);\n    sshstream.removeListener('CHANNEL_OPEN_FAILURE:' + localChan, onFailure);\n    sshstream.removeListener('CHANNEL_CLOSE:' + localChan, onFailure);\n\n    delete self._channels[localChan];\n\n    var err;\n    if (info instanceof Error)\n      err = info;\n    else if (typeof info === 'object' && info !== null) {\n      err = new Error('(SSH) Channel open failure: ' + info.description);\n      err.reason = info.reason;\n      err.lang = info.lang;\n    } else {\n      err = new Error('(SSH) Channel open failure: '\n                      + 'server closed channel unexpectedly');\n      err.reason = err.lang = '';\n    }\n    cb(err);\n  }\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // optimized path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\nfunction reqX11(chan, screen, cb) {\n  // asks server to start sending us X11 connections\n  var cfg = {\n    single: false,\n    protocol: 'MIT-MAGIC-COOKIE-1',\n    cookie: undefined,\n    screen: 0\n  };\n\n  if (typeof screen === 'function') {\n    cb = screen;\n  } else if (typeof screen === 'object' && screen !== null) {\n    if (typeof screen.single === 'boolean')\n      cfg.single = screen.single;\n    if (typeof screen.screen === 'number')\n      cfg.screen = screen.screen;\n    if (typeof screen.protocol === 'string')\n      cfg.protocol = screen.protocol;\n    if (typeof screen.cookie === 'string')\n      cfg.cookie = screen.cookie;\n    else if (Buffer.isBuffer(screen.cookie))\n      cfg.cookie = screen.cookie.toString('hex');\n  }\n  if (cfg.cookie === undefined)\n    cfg.cookie = randomCookie();\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request X11'));\n      }\n\n      chan._hasX11 = true;\n      ++chan._client._acceptX11;\n      chan.once('close', function() {\n        if (chan._client._acceptX11)\n          --chan._client._acceptX11;\n      });\n\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.x11Forward(chan.outgoing.id, cfg, wantReply);\n}\n\nfunction reqPty(chan, opts, cb) {\n  var rows = 24;\n  var cols = 80;\n  var width = 640;\n  var height = 480;\n  var term = 'vt100';\n  var modes = null;\n\n  if (typeof opts === 'function')\n    cb = opts;\n  else if (typeof opts === 'object' && opts !== null) {\n    if (typeof opts.rows === 'number')\n      rows = opts.rows;\n    if (typeof opts.cols === 'number')\n      cols = opts.cols;\n    if (typeof opts.width === 'number')\n      width = opts.width;\n    if (typeof opts.height === 'number')\n      height = opts.height;\n    if (typeof opts.term === 'string')\n      term = opts.term;\n    if (typeof opts.modes === 'object')\n      modes = opts.modes;\n  }\n\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  }\n\n  if (wantReply) {\n    chan._callbacks.push(function(had_err) {\n      if (had_err) {\n        return cb(had_err !== true\n                  ? had_err\n                  : new Error('Unable to request a pseudo-terminal'));\n      }\n      cb();\n    });\n  }\n\n  return chan._client._sshstream.pty(chan.outgoing.id,\n                                     rows,\n                                     cols,\n                                     height,\n                                     width,\n                                     term,\n                                     modes,\n                                     wantReply);\n}\n\nfunction reqAgentFwd(chan, cb) {\n  var wantReply = (typeof cb === 'function');\n\n  if (chan.outgoing.state !== 'open') {\n    wantReply && cb(new Error('Channel is not open'));\n    return true;\n  } else if (chan._client._agentFwdEnabled) {\n    wantReply && cb(false);\n    return true;\n  }\n\n  chan._client._agentFwdEnabled = true;\n\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      chan._client._agentFwdEnabled = false;\n      wantReply && cb(had_err !== true\n                      ? had_err\n                      : new Error('Unable to request agent forwarding'));\n      return;\n    }\n\n    wantReply && cb();\n  });\n\n  return chan._client._sshstream.openssh_agentForward(chan.outgoing.id, true);\n}\n\nfunction reqShell(chan, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to open shell'));\n    }\n    chan.subtype = 'shell';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.shell(chan.outgoing.id, true);\n}\n\nfunction reqExec(chan, cmd, opts, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to exec'));\n    }\n    chan.subtype = 'exec';\n    chan.allowHalfOpen = (opts.allowHalfOpen !== false);\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.exec(chan.outgoing.id, cmd, true);\n}\n\nfunction reqEnv(chan, env) {\n  if (chan.outgoing.state !== 'open')\n    return true;\n  var ret = true;\n  var keys = Object.keys(env || {});\n  var key;\n  var val;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    val = env[key];\n    ret = chan._client._sshstream.env(chan.outgoing.id, key, val, false);\n  }\n\n  return ret;\n}\n\nfunction reqSubsystem(chan, name, cb) {\n  if (chan.outgoing.state !== 'open') {\n    cb(new Error('Channel is not open'));\n    return true;\n  }\n  chan._callbacks.push(function(had_err) {\n    if (had_err) {\n      return cb(had_err !== true\n                ? had_err\n                : new Error('Unable to start subsystem: ' + name));\n    }\n    chan.subtype = 'subsystem';\n    cb(undefined, chan);\n  });\n\n  return chan._client._sshstream.subsystem(chan.outgoing.id, name, true);\n}\n\nfunction onCHANNEL_OPEN(self, info) {\n  // the server is trying to open a channel with us, this is usually when\n  // we asked the server to forward us connections on some port and now they\n  // are asking us to accept/deny an incoming connection on their side\n\n  var localChan = false;\n  var reason;\n\n  function accept() {\n    var chaninfo = {\n      type: info.type,\n      incoming: {\n        id: localChan,\n        window: Channel.MAX_WINDOW,\n        packetSize: Channel.PACKET_SIZE,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    var stream = new Channel(chaninfo, self);\n\n    self._sshstream.channelOpenConfirm(info.sender,\n                                       localChan,\n                                       Channel.MAX_WINDOW,\n                                       Channel.PACKET_SIZE);\n    return stream;\n  }\n  function reject() {\n    if (reason === undefined) {\n      if (localChan === false)\n        reason = consts.CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;\n      else\n        reason = consts.CHANNEL_OPEN_FAILURE.CONNECT_FAILED;\n    }\n\n    self._sshstream.channelOpenFail(info.sender, reason, '', '');\n  }\n\n  if (info.type === 'forwarded-tcpip'\n      || info.type === 'x11'\n      || info.type === 'auth-agent@openssh.com'\n      || info.type === 'forwarded-streamlocal@openssh.com') {\n\n    // check for conditions for automatic rejection\n    var rejectConn = (\n     (info.type === 'forwarded-tcpip'\n      && self._forwarding[info.data.destIP\n                         + ':'\n                         + info.data.destPort] === undefined)\n     || (info.type === 'forwarded-streamlocal@openssh.com'\n         && self._forwardingUnix[info.data.socketPath] === undefined)\n     || (info.type === 'x11' && self._acceptX11 === 0)\n     || (info.type === 'auth-agent@openssh.com'\n         && !self._agentFwdEnabled)\n    );\n\n    if (!rejectConn) {\n      localChan = nextChannel(self);\n\n      if (localChan === false) {\n        self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: no channels available');\n        rejectConn = true;\n      } else\n        self._channels[localChan] = true;\n    } else {\n      reason = consts.CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unexpected channel open for: '\n                        + info.type);\n    }\n\n    // TODO: automatic rejection after some timeout?\n\n    if (rejectConn)\n      reject();\n\n    if (localChan !== false) {\n      if (info.type === 'forwarded-tcpip') {\n        if (info.data.destPort === 0) {\n          info.data.destPort = self._forwarding[info.data.destIP\n                                                + ':'\n                                                + info.data.destPort];\n        }\n        self.emit('tcp connection', info.data, accept, reject);\n      } else if (info.type === 'x11') {\n        self.emit('x11', info.data, accept, reject);\n      } else if (info.type === 'forwarded-streamlocal@openssh.com') {\n        self.emit('unix connection', info.data, accept, reject);\n      } else {\n        agentQuery(self.config.agent, accept, reject);\n      }\n    }\n  } else {\n    // automatically reject any unsupported channel open requests\n    self.config.debug('DEBUG: Client: Automatic rejection of incoming channel open: unsupported type: '\n                      + info.type);\n    reason = consts.CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;\n    reject();\n  }\n}\n\nvar randomCookie = (function() {\n  if (typeof crypto.randomFillSync === 'function') {\n    var buffer = Buffer.alloc(16);\n    return function randomCookie() {\n      crypto.randomFillSync(buffer, 0, 16);\n      return buffer.toString('hex');\n    };\n  } else {\n    return function randomCookie() {\n      return crypto.randomBytes(16).toString('hex');\n    };\n  }\n})();\n\nClient.Client = Client;\nClient.Server = require('./server');\n// pass some useful utilities on to end user (e.g. parseKey())\nClient.utils = ssh2_streams.utils;\n// expose useful SFTPStream constants for sftp server usage\nClient.SFTP_STATUS_CODE = SFTPStream.STATUS_CODE;\nClient.SFTP_OPEN_MODE = SFTPStream.OPEN_MODE;\n// expose http(s).Agent implementations to allow easy tunneling of HTTP(S)\n// requests\nClient.HTTPAgent = HTTPAgents.SSHTTPAgent;\nClient.HTTPSAgent = HTTPAgents.SSHTTPSAgent;\n\nmodule.exports = Client; // backwards compatibility\n","var HttpAgent = require('http').Agent;\nvar HttpsAgent = require('https').Agent;\nvar inherits = require('util').inherits;\n\nvar Client;\n\n[HttpAgent, HttpsAgent].forEach((ctor) => {\n  function SSHAgent(connectCfg, agentOptions) {\n    if (!(this instanceof SSHAgent))\n      return new SSHAgent(connectCfg, agentOptions);\n\n    ctor.call(this, agentOptions);\n\n    this._connectCfg = connectCfg;\n    this._defaultSrcIP = (agentOptions && agentOptions.srcIP) || 'localhost';\n  }\n  inherits(SSHAgent, ctor);\n\n  SSHAgent.prototype.createConnection = createConnection;\n\n  exports[ctor === HttpAgent ? 'SSHTTPAgent' : 'SSHTTPSAgent'] = SSHAgent;\n});\n\nfunction createConnection(options, cb) {\n  var srcIP = (options && options.localAddress) || this._defaultSrcIP;\n  var srcPort = (options && options.localPort) || 0;\n  var dstIP = options.host;\n  var dstPort = options.port;\n\n  if (Client === undefined)\n    Client = require('./client').Client;\n\n  var client = new Client();\n  var triedForward = false;\n  client.on('ready', () => {\n    client.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {\n      triedForward = true;\n      if (err) {\n        client.end();\n        return cb(err);\n      }\n      stream.once('close', () => {\n        client.end();\n      });\n      cb(null, decorateStream(stream));\n    });\n  }).on('error', cb).on('close', () => {\n    if (!triedForward)\n      cb(new Error('Unexpected connection loss'));\n  }).connect(this._connectCfg);\n}\n\nfunction noop() {}\n\nfunction decorateStream(stream) {\n  stream.setKeepAlive = noop;\n  stream.setNoDelay = noop;\n  stream.setTimeout = noop;\n  stream.ref = noop;\n  stream.unref = noop;\n  stream.destroySoon = stream.destroy;\n  return stream;\n}\n","function spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction Manager(interval, streamInterval, kaCountMax) {\n  var streams = this._streams = [];\n  this._timer = undefined;\n  this._timerInterval = interval;\n  this._timerfn = function() {\n    var now = Date.now();\n    for (var i = 0, len = streams.length, s, last; i < len; ++i) {\n      s = streams[i];\n      last = s._kalast;\n      if (last && (now - last) >= streamInterval) {\n        if (++s._kacnt > kaCountMax) {\n          var err = new Error('Keepalive timeout');\n          err.level = 'client-timeout';\n          s.emit('error', err);\n          s.disconnect();\n          spliceOne(streams, i);\n          --i;\n          len = streams.length;\n        } else {\n          s._kalast = now;\n          // XXX: if the server ever starts sending real global requests to the\n          //      client, we will need to add a dummy callback here to keep the\n          //      correct reply order\n          s.ping();\n        }\n      }\n    }\n  };\n}\n\nManager.prototype.start = function() {\n  if (this._timer)\n    this.stop();\n  this._timer = setInterval(this._timerfn, this._timerInterval);\n};\n\nManager.prototype.stop = function() {\n  if (this._timer) {\n    clearInterval(this._timer);\n    this._timer = undefined;\n  }\n};\n\nManager.prototype.add = function(stream) {\n  var streams = this._streams,\n      self = this;\n\n  stream.once('end', function() {\n    self.remove(stream);\n  }).on('packet', resetKA);\n\n  streams[streams.length] = stream;\n\n  resetKA();\n\n  if (!this._timer)\n    this.start();\n\n  function resetKA() {\n    stream._kalast = Date.now();\n    stream._kacnt = 0;\n  }\n};\n\nManager.prototype.remove = function(stream) {\n  var streams = this._streams,\n      index = streams.indexOf(stream);\n  if (index > -1)\n    spliceOne(streams, index);\n  if (!streams.length)\n    this.stop();\n};\n\nmodule.exports = Manager;\n","var net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar listenerCount = EventEmitter.listenerCount;\nvar inherits = require('util').inherits;\n\nvar ssh2_streams = require('ssh2-streams');\nvar parseKey = ssh2_streams.utils.parseKey;\nvar SSH2Stream = ssh2_streams.SSH2Stream;\nvar SFTPStream = ssh2_streams.SFTPStream;\nvar consts = ssh2_streams.constants;\nvar DISCONNECT_REASON = consts.DISCONNECT_REASON;\nvar CHANNEL_OPEN_FAILURE = consts.CHANNEL_OPEN_FAILURE;\nvar ALGORITHMS = consts.ALGORITHMS;\n\nvar Channel = require('./Channel');\nvar KeepaliveManager = require('./keepalivemgr');\nvar writeUInt32BE = require('./buffer-helpers').writeUInt32BE;\n\nvar MAX_CHANNEL = Math.pow(2, 32) - 1;\nvar MAX_PENDING_AUTHS = 10;\n\nvar kaMgr;\n\nfunction Server(cfg, listener) {\n  if (!(this instanceof Server))\n    return new Server(cfg, listener);\n\n  var hostKeys = {\n    'ssh-rsa': null,\n    'ssh-dss': null,\n    'ssh-ed25519': null,\n    'ecdsa-sha2-nistp256': null,\n    'ecdsa-sha2-nistp384': null,\n    'ecdsa-sha2-nistp521': null\n  };\n\n  var hostKeys_ = cfg.hostKeys;\n  if (!Array.isArray(hostKeys_))\n    throw new Error('hostKeys must be an array');\n\n  var i;\n  for (i = 0; i < hostKeys_.length; ++i) {\n    var privateKey;\n    if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === 'string')\n      privateKey = parseKey(hostKeys_[i]);\n    else\n      privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);\n    if (privateKey instanceof Error)\n      throw new Error('Cannot parse privateKey: ' + privateKey.message);\n    if (Array.isArray(privateKey))\n      privateKey = privateKey[0]; // OpenSSH's newer format only stores 1 key for now\n    if (privateKey.getPrivatePEM() === null)\n      throw new Error('privateKey value contains an invalid private key');\n    if (hostKeys[privateKey.type])\n      continue;\n    hostKeys[privateKey.type] = privateKey;\n  }\n\n  var algorithms = {\n    kex: undefined,\n    kexBuf: undefined,\n    cipher: undefined,\n    cipherBuf: undefined,\n    serverHostKey: undefined,\n    serverHostKeyBuf: undefined,\n    hmac: undefined,\n    hmacBuf: undefined,\n    compress: undefined,\n    compressBuf: undefined\n  };\n  if (typeof cfg.algorithms === 'object' && cfg.algorithms !== null) {\n    var algosSupported;\n    var algoList;\n\n    algoList = cfg.algorithms.kex;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_KEX;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported key exchange algorithm: ' + algoList[i]);\n      }\n      algorithms.kex = algoList;\n    }\n\n    algoList = cfg.algorithms.cipher;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_CIPHER;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported cipher algorithm: ' + algoList[i]);\n      }\n      algorithms.cipher = algoList;\n    }\n\n    algoList = cfg.algorithms.serverHostKey;\n    var copied = false;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_SERVER_HOST_KEY;\n      for (i = algoList.length - 1; i >= 0; --i) {\n        if (algosSupported.indexOf(algoList[i]) === -1) {\n          throw new Error('Unsupported server host key algorithm: '\n                           + algoList[i]);\n        }\n        if (!hostKeys[algoList[i]]) {\n          // Silently discard for now\n          if (!copied) {\n            algoList = algoList.slice();\n            copied = true;\n          }\n          algoList.splice(i, 1);\n        }\n      }\n      if (algoList.length > 0)\n        algorithms.serverHostKey = algoList;\n    }\n\n    algoList = cfg.algorithms.hmac;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_HMAC;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported HMAC algorithm: ' + algoList[i]);\n      }\n      algorithms.hmac = algoList;\n    }\n\n    algoList = cfg.algorithms.compress;\n    if (Array.isArray(algoList) && algoList.length > 0) {\n      algosSupported = ALGORITHMS.SUPPORTED_COMPRESS;\n      for (i = 0; i < algoList.length; ++i) {\n        if (algosSupported.indexOf(algoList[i]) === -1)\n          throw new Error('Unsupported compression algorithm: ' + algoList[i]);\n      }\n      algorithms.compress = algoList;\n    }\n  }\n\n  // Make sure we at least have some kind of valid list of support key\n  // formats\n  if (algorithms.serverHostKey === undefined) {\n    var hostKeyAlgos = Object.keys(hostKeys);\n    for (i = hostKeyAlgos.length - 1; i >= 0; --i) {\n      if (!hostKeys[hostKeyAlgos[i]])\n        hostKeyAlgos.splice(i, 1);\n    }\n    algorithms.serverHostKey = hostKeyAlgos;\n  }\n\n  if (!kaMgr\n      && Server.KEEPALIVE_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_INTERVAL > 0\n      && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0) {\n    kaMgr = new KeepaliveManager(Server.KEEPALIVE_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_INTERVAL,\n                                 Server.KEEPALIVE_CLIENT_COUNT_MAX);\n  }\n\n  var self = this;\n\n  EventEmitter.call(this);\n\n  if (typeof listener === 'function')\n    self.on('connection', listener);\n\n  var streamcfg = {\n    algorithms: algorithms,\n    hostKeys: hostKeys,\n    server: true\n  };\n  var keys;\n  var len;\n  for (i = 0, keys = Object.keys(cfg), len = keys.length; i < len; ++i) {\n    var key = keys[i];\n    if (key === 'privateKey'\n        || key === 'publicKey'\n        || key === 'passphrase'\n        || key === 'algorithms'\n        || key === 'hostKeys'\n        || key === 'server') {\n      continue;\n    }\n    streamcfg[key] = cfg[key];\n  }\n\n  if (typeof streamcfg.debug === 'function') {\n    var oldDebug = streamcfg.debug;\n    var cfgKeys = Object.keys(streamcfg);\n  }\n\n  this._srv = new net.Server(function(socket) {\n    if (self._connections >= self.maxConnections) {\n      socket.destroy();\n      return;\n    }\n    ++self._connections;\n    socket.once('close', function(had_err) {\n      --self._connections;\n\n      // since joyent/node#993bb93e0a, we have to \"read past EOF\" in order to\n      // get an `end` event on streams. thankfully adding this does not\n      // negatively affect node versions pre-joyent/node#993bb93e0a.\n      sshstream.read();\n    }).on('error', function(err) {\n      sshstream.reset();\n      sshstream.emit('error', err);\n    });\n\n    var conncfg = streamcfg;\n\n    // prepend debug output with a unique identifier in case there are multiple\n    // clients connected at the same time\n    if (oldDebug) {\n      conncfg = {};\n      for (var i = 0, key; i < cfgKeys.length; ++i) {\n        key = cfgKeys[i];\n        conncfg[key] = streamcfg[key];\n      }\n      var debugPrefix = '[' + process.hrtime().join('.') + '] ';\n      conncfg.debug = function(msg) {\n        oldDebug(debugPrefix + msg);\n      };\n    }\n\n    var sshstream = new SSH2Stream(conncfg);\n    var client = new Client(sshstream, socket);\n\n    socket.pipe(sshstream).pipe(socket);\n\n    // silence pre-header errors\n    function onClientPreHeaderError(err) {}\n    client.on('error', onClientPreHeaderError);\n\n    sshstream.once('header', function(header) {\n      if (sshstream._readableState.ended) {\n        // already disconnected internally in SSH2Stream due to incompatible\n        // protocol version\n        return;\n      } else if (!listenerCount(self, 'connection')) {\n        // auto reject\n        return sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n      }\n\n      client.removeListener('error', onClientPreHeaderError);\n\n      self.emit('connection',\n                client,\n                { ip: socket.remoteAddress,\n                  family: socket.remoteFamily,\n                  port: socket.remotePort,\n                  header: header });\n    });\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('listening', function() {\n    self.emit('listening');\n  }).on('close', function() {\n    self.emit('close');\n  });\n  this._connections = 0;\n  this.maxConnections = Infinity;\n}\ninherits(Server, EventEmitter);\n\nServer.prototype.listen = function() {\n  this._srv.listen.apply(this._srv, arguments);\n  return this;\n};\n\nServer.prototype.address = function() {\n  return this._srv.address();\n};\n\nServer.prototype.getConnections = function(cb) {\n  this._srv.getConnections(cb);\n};\n\nServer.prototype.close = function(cb) {\n  this._srv.close(cb);\n  return this;\n};\n\nServer.prototype.ref = function() {\n  this._srv.ref();\n};\n\nServer.prototype.unref = function() {\n  this._srv.unref();\n};\n\n\nfunction Client(stream, socket) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this._sshstream = stream;\n  var channels = this._channels = {};\n  this._curChan = -1;\n  this._sock = socket;\n  this.noMoreSessions = false;\n  this.authenticated = false;\n\n  stream.on('end', function() {\n    socket.resume();\n    self.emit('end');\n  }).on('close', function(hasErr) {\n    self.emit('close', hasErr);\n  }).on('error', function(err) {\n    self.emit('error', err);\n  }).on('drain', function() {\n    self.emit('drain');\n  }).on('continue', function() {\n    self.emit('continue');\n  });\n\n  var exchanges = 0;\n  var acceptedAuthSvc = false;\n  var pendingAuths = [];\n  var authCtx;\n\n  // begin service/auth-related ================================================\n  stream.on('SERVICE_REQUEST', function(service) {\n    if (exchanges === 0\n        || acceptedAuthSvc\n        || self.authenticated\n        || service !== 'ssh-userauth')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    acceptedAuthSvc = true;\n    stream.serviceAccept(service);\n  }).on('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n  function onUSERAUTH_REQUEST(username, service, method, methodData) {\n    if (exchanges === 0\n        || (authCtx\n            && (authCtx.username !== username || authCtx.service !== service))\n          // TODO: support hostbased auth\n        || (method !== 'password'\n            && method !== 'publickey'\n            && method !== 'hostbased'\n            && method !== 'keyboard-interactive'\n            && method !== 'none')\n        || pendingAuths.length === MAX_PENDING_AUTHS)\n      return stream.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);\n    else if (service !== 'ssh-connection')\n      return stream.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);\n\n    // XXX: this really shouldn't be reaching into private state ...\n    stream._state.authMethod = method;\n\n    var ctx;\n    if (method === 'keyboard-interactive') {\n      ctx = new KeyboardAuthContext(stream, username, service, method,\n                                    methodData, onAuthDecide);\n    } else if (method === 'publickey') {\n      ctx = new PKAuthContext(stream, username, service, method, methodData,\n                              onAuthDecide);\n    } else if (method === 'hostbased') {\n      ctx = new HostbasedAuthContext(stream, username, service, method,\n                                     methodData, onAuthDecide);\n    } else if (method === 'password') {\n      ctx = new PwdAuthContext(stream, username, service, method, methodData,\n                               onAuthDecide);\n    } else if (method === 'none')\n      ctx = new AuthContext(stream, username, service, method, onAuthDecide);\n\n    if (authCtx) {\n      if (!authCtx._initialResponse)\n        return pendingAuths.push(ctx);\n      else if (authCtx._multistep && !this._finalResponse) {\n        // RFC 4252 says to silently abort the current auth request if a new\n        // auth request comes in before the final response from an auth method\n        // that requires additional request/response exchanges -- this means\n        // keyboard-interactive for now ...\n        authCtx._cleanup && authCtx._cleanup();\n        authCtx.emit('abort');\n      }\n    }\n\n    authCtx = ctx;\n\n    if (listenerCount(self, 'authentication'))\n      self.emit('authentication', authCtx);\n    else\n      authCtx.reject();\n  }\n  function onAuthDecide(ctx, allowed, methodsLeft, isPartial) {\n    if (authCtx === ctx && !self.authenticated) {\n      if (allowed) {\n        stream.removeListener('USERAUTH_REQUEST', onUSERAUTH_REQUEST);\n        authCtx = undefined;\n        self.authenticated = true;\n        stream.authSuccess();\n        pendingAuths = [];\n        self.emit('ready');\n      } else {\n        stream.authFailure(methodsLeft, isPartial);\n        if (pendingAuths.length) {\n          authCtx = pendingAuths.pop();\n          if (listenerCount(self, 'authentication'))\n            self.emit('authentication', authCtx);\n          else\n            authCtx.reject();\n        }\n      }\n    }\n  }\n  // end service/auth-related ==================================================\n\n  var unsentGlobalRequestsReplies = [];\n\n  function sendReplies() {\n    var reply;\n    while (unsentGlobalRequestsReplies.length > 0\n           && unsentGlobalRequestsReplies[0].type) {\n      reply = unsentGlobalRequestsReplies.shift();\n      if (reply.type === 'SUCCESS')\n        stream.requestSuccess(reply.buf);\n      if (reply.type === 'FAILURE')\n        stream.requestFailure();\n    }\n  }\n\n  stream.on('GLOBAL_REQUEST', function(name, wantReply, data) {\n    var reply = {\n      type: null,\n      buf: null\n    };\n\n    function setReply(type, buf) {\n      reply.type = type;\n      reply.buf = buf;\n      sendReplies();\n    }\n\n    if (wantReply)\n      unsentGlobalRequestsReplies.push(reply);\n\n    if ((name === 'tcpip-forward'\n         || name === 'cancel-tcpip-forward'\n         || name === 'no-more-sessions@openssh.com'\n         || name === 'streamlocal-forward@openssh.com'\n         || name === 'cancel-streamlocal-forward@openssh.com')\n        && listenerCount(self, 'request')\n        && self.authenticated) {\n      var accept;\n      var reject;\n\n      if (wantReply) {\n        var replied = false;\n        accept = function(chosenPort) {\n          if (replied)\n            return;\n          replied = true;\n          var bufPort;\n          if (name === 'tcpip-forward'\n              && data.bindPort === 0\n              && typeof chosenPort === 'number') {\n            bufPort = Buffer.allocUnsafe(4);\n            writeUInt32BE(bufPort, chosenPort, 0);\n          }\n          setReply('SUCCESS', bufPort);\n        };\n        reject = function() {\n          if (replied)\n            return;\n          replied = true;\n          setReply('FAILURE');\n        };\n      }\n\n      if (name === 'no-more-sessions@openssh.com') {\n        self.noMoreSessions = true;\n        accept && accept();\n        return;\n      }\n\n      self.emit('request', accept, reject, name, data);\n    } else if (wantReply)\n      setReply('FAILURE');\n  });\n\n  stream.on('CHANNEL_OPEN', function(info) {\n    // do early reject in some cases to prevent wasteful channel allocation\n    if ((info.type === 'session' && self.noMoreSessions)\n        || !self.authenticated) {\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    }\n\n    var localChan = nextChannel(self);\n    var accept;\n    var reject;\n    var replied = false;\n    if (localChan === false) {\n      // auto-reject due to no channels available\n      return stream.channelOpenFail(info.sender,\n                                    CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE);\n    }\n\n    // be optimistic, reserve channel to prevent another request from trying to\n    // take the same channel\n    channels[localChan] = true;\n\n    reject = function() {\n      if (replied)\n        return;\n\n      replied = true;\n\n      delete channels[localChan];\n\n      var reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;\n      return stream.channelOpenFail(info.sender, reasonCode);\n    };\n\n    switch (info.type) {\n      case 'session':\n        if (listenerCount(self, 'session')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            return new Session(self, info, localChan);\n          };\n\n          self.emit('session', accept, reject);\n        } else\n          reject();\n      break;\n      case 'direct-tcpip':\n        if (listenerCount(self, 'tcpip')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('tcpip', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      case 'direct-streamlocal@openssh.com':\n        if (listenerCount(self, 'openssh.streamlocal')) {\n          accept = function() {\n            if (replied)\n              return;\n\n            replied = true;\n\n            stream.channelOpenConfirm(info.sender,\n                                      localChan,\n                                      Channel.MAX_WINDOW,\n                                      Channel.PACKET_SIZE);\n\n            var chaninfo = {\n              type: undefined,\n              incoming: {\n                id: localChan,\n                window: Channel.MAX_WINDOW,\n                packetSize: Channel.PACKET_SIZE,\n                state: 'open'\n              },\n              outgoing: {\n                id: info.sender,\n                window: info.window,\n                packetSize: info.packetSize,\n                state: 'open'\n              }\n            };\n\n            return new Channel(chaninfo, self);\n          };\n\n          self.emit('openssh.streamlocal', accept, reject, info.data);\n        } else\n          reject();\n      break;\n      default:\n        // auto-reject unsupported channel types\n        reject();\n    }\n  });\n\n  stream.on('NEWKEYS', function() {\n    if (++exchanges > 1)\n      self.emit('rekey');\n  });\n\n  if (kaMgr) {\n    this.once('ready', function() {\n      kaMgr.add(stream);\n    });\n  }\n}\ninherits(Client, EventEmitter);\n\nClient.prototype.end = function() {\n  return this._sshstream.disconnect(DISCONNECT_REASON.BY_APPLICATION);\n};\n\nClient.prototype.x11 = function(originAddr, originPort, cb) {\n  var opts = {\n    originAddr: originAddr,\n    originPort: originPort\n  };\n  return openChannel(this, 'x11', opts, cb);\n};\n\nClient.prototype.forwardOut = function(boundAddr, boundPort, remoteAddr,\n                                       remotePort, cb) {\n  var opts = {\n    boundAddr: boundAddr,\n    boundPort: boundPort,\n    remoteAddr: remoteAddr,\n    remotePort: remotePort\n  };\n  return openChannel(this, 'forwarded-tcpip', opts, cb);\n};\n\nClient.prototype.openssh_forwardOutStreamLocal = function(socketPath, cb) {\n  var opts = {\n    socketPath: socketPath\n  };\n  return openChannel(this, 'forwarded-streamlocal@openssh.com', opts, cb);\n};\n\nClient.prototype.rekey = function(cb) {\n  var stream = this._sshstream;\n  var ret = true;\n  var error;\n\n  try {\n    ret = stream.rekey();\n  } catch (ex) {\n    error = ex;\n  }\n\n  // TODO: re-throw error if no callback?\n\n  if (typeof cb === 'function') {\n    if (error) {\n      process.nextTick(function() {\n        cb(error);\n      });\n    } else\n      this.once('rekey', cb);\n  }\n\n  return ret;\n};\n\nfunction Session(client, info, localChan) {\n  this.subtype = undefined;\n\n  var ending = false;\n  var self = this;\n  var outgoingId = info.sender;\n  var channel;\n\n  var chaninfo = {\n    type: 'session',\n    incoming: {\n      id: localChan,\n      window: Channel.MAX_WINDOW,\n      packetSize: Channel.PACKET_SIZE,\n      state: 'open'\n    },\n    outgoing: {\n      id: info.sender,\n      window: info.window,\n      packetSize: info.packetSize,\n      state: 'open'\n    }\n  };\n\n  function onREQUEST(info) {\n    var replied = false;\n    var accept;\n    var reject;\n\n    if (info.wantReply) {\n      // \"real session\" requests will have custom accept behaviors\n      if (info.request !== 'shell'\n          && info.request !== 'exec'\n          && info.request !== 'subsystem') {\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          return client._sshstream.channelSuccess(outgoingId);\n        };\n      }\n\n      reject = function() {\n        if (replied || ending || channel)\n          return;\n\n        replied = true;\n\n        return client._sshstream.channelFailure(outgoingId);\n      };\n    }\n\n    if (ending) {\n      reject && reject();\n      return;\n    }\n\n    switch (info.request) {\n      // \"pre-real session start\" requests\n      case 'env':\n        if (listenerCount(self, 'env')) {\n          self.emit('env', accept, reject, {\n            key: info.key,\n            val: info.val\n          });\n        } else\n          reject && reject();\n      break;\n      case 'pty-req':\n        if (listenerCount(self, 'pty')) {\n          self.emit('pty', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height,\n            term: info.term,\n            modes: info.modes,\n          });\n        } else\n          reject && reject();\n      break;\n      case 'window-change':\n        if (listenerCount(self, 'window-change')) {\n          self.emit('window-change', accept, reject, {\n            cols: info.cols,\n            rows: info.rows,\n            width: info.width,\n            height: info.height\n          });\n        } else\n          reject && reject();\n      break;\n      case 'x11-req':\n        if (listenerCount(self, 'x11')) {\n          self.emit('x11', accept, reject, {\n            single: info.single,\n            protocol: info.protocol,\n            cookie: info.cookie,\n            screen: info.screen\n          });\n        } else\n          reject && reject();\n      break;\n      // \"post-real session start\" requests\n      case 'signal':\n        if (listenerCount(self, 'signal')) {\n          self.emit('signal', accept, reject, {\n            name: info.signal\n          });\n        } else\n          reject && reject();\n      break;\n      // XXX: is `auth-agent-req@openssh.com` really \"post-real session start\"?\n      case 'auth-agent-req@openssh.com':\n        if (listenerCount(self, 'auth-agent'))\n          self.emit('auth-agent', accept, reject);\n        else\n          reject && reject();\n      break;\n      // \"real session start\" requests\n      case 'shell':\n        if (listenerCount(self, 'shell')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('shell', accept, reject);\n        } else\n          reject && reject();\n      break;\n      case 'exec':\n        if (listenerCount(self, 'exec')) {\n          accept = function() {\n            if (replied || ending || channel)\n              return;\n\n            replied = true;\n\n            if (info.wantReply)\n              client._sshstream.channelSuccess(outgoingId);\n\n            channel = new Channel(chaninfo, client, { server: true });\n\n            channel.subtype = self.subtype = info.request;\n\n            return channel;\n          };\n\n          self.emit('exec', accept, reject, {\n            command: info.command\n          });\n        } else\n          reject && reject();\n      break;\n      case 'subsystem':\n        accept = function() {\n          if (replied || ending || channel)\n            return;\n\n          replied = true;\n\n          if (info.wantReply)\n            client._sshstream.channelSuccess(outgoingId);\n\n          channel = new Channel(chaninfo, client, { server: true });\n\n          channel.subtype = self.subtype = (info.request + ':' + info.subsystem);\n\n          if (info.subsystem === 'sftp') {\n            var sftp = new SFTPStream({\n              server: true,\n              debug: client._sshstream.debug\n            });\n            channel.pipe(sftp).pipe(channel);\n\n            return sftp;\n          } else\n            return channel;\n        };\n\n        if (info.subsystem === 'sftp' && listenerCount(self, 'sftp'))\n          self.emit('sftp', accept, reject);\n        else if (info.subsystem !== 'sftp' && listenerCount(self, 'subsystem')) {\n          self.emit('subsystem', accept, reject, {\n            name: info.subsystem\n          });\n        } else\n          reject && reject();\n      break;\n      default:\n        reject && reject();\n    }\n  }\n  function onEOF() {\n    ending = true;\n    self.emit('eof');\n    self.emit('end');\n  }\n  function onCLOSE() {\n    ending = true;\n    self.emit('close');\n  }\n  client._sshstream\n        .on('CHANNEL_REQUEST:' + localChan, onREQUEST)\n        .once('CHANNEL_EOF:' + localChan, onEOF)\n        .once('CHANNEL_CLOSE:' + localChan, onCLOSE);\n}\ninherits(Session, EventEmitter);\n\n\nfunction AuthContext(stream, username, service, method, cb) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this.username = this.user = username;\n  this.service = service;\n  this.method = method;\n  this._initialResponse = false;\n  this._finalResponse = false;\n  this._multistep = false;\n  this._cbfinal = function(allowed, methodsLeft, isPartial) {\n    if (!self._finalResponse) {\n      self._finalResponse = true;\n      cb(self, allowed, methodsLeft, isPartial);\n    }\n  };\n  this._stream = stream;\n}\ninherits(AuthContext, EventEmitter);\nAuthContext.prototype.accept = function() {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(true);\n};\nAuthContext.prototype.reject = function(methodsLeft, isPartial) {\n  this._cleanup && this._cleanup();\n  this._initialResponse = true;\n  this._cbfinal(false, methodsLeft, isPartial);\n};\n\nvar RE_KBINT_SUBMETHODS = /[ \\t\\r\\n]*,[ \\t\\r\\n]*/g;\nfunction KeyboardAuthContext(stream, username, service, method, submethods, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n  this._multistep = true;\n\n  var self = this;\n\n  this._cb = undefined;\n  this._onInfoResponse = function(responses) {\n    if (self._cb) {\n      var callback = self._cb;\n      self._cb = undefined;\n      callback(responses);\n    }\n  };\n  this.submethods = submethods.split(RE_KBINT_SUBMETHODS);\n  this.on('abort', function() {\n    self._cb && self._cb(new Error('Authentication request aborted'));\n  });\n}\ninherits(KeyboardAuthContext, AuthContext);\nKeyboardAuthContext.prototype._cleanup = function() {\n  this._stream.removeListener('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n};\nKeyboardAuthContext.prototype.prompt = function(prompts, title, instructions,\n                                                cb) {\n  if (!Array.isArray(prompts))\n    prompts = [ prompts ];\n\n  if (typeof title === 'function') {\n    cb = title;\n    title = instructions = undefined;\n  } else if (typeof instructions === 'function') {\n    cb = instructions;\n    instructions = undefined;\n  }\n\n  for (var i = 0; i < prompts.length; ++i) {\n    if (typeof prompts[i] === 'string') {\n      prompts[i] = {\n        prompt: prompts[i],\n        echo: true\n      };\n    }\n  }\n\n  this._cb = cb;\n  this._initialResponse = true;\n  this._stream.once('USERAUTH_INFO_RESPONSE', this._onInfoResponse);\n\n  return this._stream.authInfoReq(title, instructions, prompts);\n};\n\nfunction PKAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    // TODO: move key type checking logic to ssh2-streams\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n      case 'ssh-dss':\n        sigAlgo = 'sha1';\n        break;\n      case 'ssh-ed25519':\n        sigAlgo = null;\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n}\ninherits(PKAuthContext, AuthContext);\nPKAuthContext.prototype.accept = function() {\n  if (!this.signature) {\n    this._initialResponse = true;\n    this._stream.authPKOK(this.key.algo, this.key.data);\n  } else {\n    AuthContext.prototype.accept.call(this);\n  }\n};\n\nfunction HostbasedAuthContext(stream, username, service, method, pkInfo, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.key = { algo: pkInfo.keyAlgo, data: pkInfo.key };\n  this.signature = pkInfo.signature;\n  var sigAlgo;\n  if (this.signature) {\n    // TODO: move key type checking logic to ssh2-streams\n    switch (pkInfo.keyAlgo) {\n      case 'ssh-rsa':\n      case 'ssh-dss':\n        sigAlgo = 'sha1';\n        break;\n      case 'ssh-ed25519':\n        sigAlgo = null;\n        break;\n      case 'ecdsa-sha2-nistp256':\n        sigAlgo = 'sha256';\n        break;\n      case 'ecdsa-sha2-nistp384':\n        sigAlgo = 'sha384';\n        break;\n      case 'ecdsa-sha2-nistp521':\n        sigAlgo = 'sha512';\n        break;\n    }\n  }\n  this.sigAlgo = sigAlgo;\n  this.blob = pkInfo.blob;\n  this.localHostname = pkInfo.localHostname;\n  this.localUsername = pkInfo.localUsername;\n}\ninherits(HostbasedAuthContext, AuthContext);\n\nfunction PwdAuthContext(stream, username, service, method, password, cb) {\n  AuthContext.call(this, stream, username, service, method, cb);\n\n  this.password = password;\n}\ninherits(PwdAuthContext, AuthContext);\n\n\nfunction openChannel(self, type, opts, cb) {\n  // ask the client to open a channel for some purpose\n  // (e.g. a forwarded TCP connection)\n  var localChan = nextChannel(self);\n  var initWindow = Channel.MAX_WINDOW;\n  var maxPacket = Channel.PACKET_SIZE;\n  var ret = true;\n\n  if (localChan === false)\n    return cb(new Error('No free channels available'));\n\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  self._channels[localChan] = true;\n\n  var sshstream = self._sshstream;\n  sshstream.once('CHANNEL_OPEN_CONFIRMATION:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_FAILURE:' + localChan);\n\n    var chaninfo = {\n      type: type,\n      incoming: {\n        id: localChan,\n        window: initWindow,\n        packetSize: maxPacket,\n        state: 'open'\n      },\n      outgoing: {\n        id: info.sender,\n        window: info.window,\n        packetSize: info.packetSize,\n        state: 'open'\n      }\n    };\n    cb(undefined, new Channel(chaninfo, self, { server: true }));\n  }).once('CHANNEL_OPEN_FAILURE:' + localChan, function(info) {\n    sshstream.removeAllListeners('CHANNEL_OPEN_CONFIRMATION:' + localChan);\n\n    delete self._channels[localChan];\n\n    var err = new Error('(SSH) Channel open failure: ' + info.description);\n    err.reason = info.reason;\n    err.lang = info.lang;\n    cb(err);\n  });\n\n  if (type === 'forwarded-tcpip')\n    ret = sshstream.forwardedTcpip(localChan, initWindow, maxPacket, opts);\n  else if (type === 'x11')\n    ret = sshstream.x11(localChan, initWindow, maxPacket, opts);\n  else if (type === 'forwarded-streamlocal@openssh.com') {\n    ret = sshstream.openssh_forwardedStreamLocal(localChan,\n                                                 initWindow,\n                                                 maxPacket,\n                                                 opts);\n  }\n\n  return ret;\n}\n\nfunction nextChannel(self) {\n  // get the next available channel number\n\n  // fast path\n  if (self._curChan < MAX_CHANNEL)\n    return ++self._curChan;\n\n  // slower lookup path\n  for (var i = 0, channels = self._channels; i < MAX_CHANNEL; ++i)\n    if (!channels[i])\n      return i;\n\n  return false;\n}\n\n\nServer.createServer = function(cfg, listener) {\n  return new Server(cfg, listener);\n};\nServer.KEEPALIVE_INTERVAL = 1000;\nServer.KEEPALIVE_CLIENT_INTERVAL = 15000;\nServer.KEEPALIVE_CLIENT_COUNT_MAX = 3;\n\nmodule.exports = Server;\nmodule.exports.IncomingClient = Client;\n","/*\n  Based heavily on the Streaming Boyer-Moore-Horspool C++ implementation\n  by Hongli Lai at: https://github.com/FooBarWidget/boyer-moore-horspool\n*/\nvar EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits;\n\nfunction jsmemcmp(buf1, pos1, buf2, pos2, num) {\n  for (var i = 0; i < num; ++i, ++pos1, ++pos2)\n    if (buf1[pos1] !== buf2[pos2])\n      return false;\n  return true;\n}\n\nfunction SBMH(needle) {\n  if (typeof needle === 'string')\n    needle = new Buffer(needle);\n  var i, j, needle_len = needle.length;\n\n  this.maxMatches = Infinity;\n  this.matches = 0;\n\n  this._occ = new Array(256);\n  this._lookbehind_size = 0;\n  this._needle = needle;\n  this._bufpos = 0;\n\n  this._lookbehind = new Buffer(needle_len);\n\n  // Initialize occurrence table.\n  for (j = 0; j < 256; ++j)\n    this._occ[j] = needle_len;\n\n  // Populate occurrence table with analysis of the needle,\n  // ignoring last letter.\n  if (needle_len >= 1) {\n    for (i = 0; i < needle_len - 1; ++i)\n      this._occ[needle[i]] = needle_len - 1 - i;\n  }\n}\ninherits(SBMH, EventEmitter);\n\nSBMH.prototype.reset = function() {\n  this._lookbehind_size = 0;\n  this.matches = 0;\n  this._bufpos = 0;\n};\n\nSBMH.prototype.push = function(chunk, pos) {\n  var r, chlen;\n  if (!Buffer.isBuffer(chunk))\n    chunk = new Buffer(chunk, 'binary');\n  chlen = chunk.length;\n  this._bufpos = pos || 0;\n  while (r !== chlen && this.matches < this.maxMatches)\n    r = this._sbmh_feed(chunk);\n  return r;\n};\n\nSBMH.prototype._sbmh_feed = function(data) {\n  var len = data.length, needle = this._needle, needle_len = needle.length;\n\n  // Positive: points to a position in `data`\n  //           pos == 3 points to data[3]\n  // Negative: points to a position in the lookbehind buffer\n  //           pos == -2 points to lookbehind[lookbehind_size - 2]\n  var pos = -this._lookbehind_size,\n      last_needle_char = needle[needle_len - 1],\n      occ = this._occ,\n      lookbehind = this._lookbehind;\n\n  if (pos < 0) {\n    // Lookbehind buffer is not empty. Perform Boyer-Moore-Horspool\n    // search with character lookup code that considers both the\n    // lookbehind buffer and the current round's haystack data.\n    //\n    // Loop until\n    //   there is a match.\n    // or until\n    //   we've moved past the position that requires the\n    //   lookbehind buffer. In this case we switch to the\n    //   optimized loop.\n    // or until\n    //   the character to look at lies outside the haystack.\n    while (pos < 0 && pos <= len - needle_len) {\n       var ch = this._sbmh_lookup_char(data, pos + needle_len - 1);\n\n      if (ch === last_needle_char\n          && this._sbmh_memcmp(data, pos, needle_len - 1)) {\n        this._lookbehind_size = 0;\n        ++this.matches;\n        if (pos > -this._lookbehind_size)\n          this.emit('info', true, lookbehind, 0, this._lookbehind_size + pos);\n        else\n          this.emit('info', true);\n\n        this._bufpos = pos + needle_len;\n        return pos + needle_len;\n      } else\n        pos += occ[ch];\n    }\n\n    // No match.\n\n    if (pos < 0) {\n      // There's too few data for Boyer-Moore-Horspool to run,\n      // so let's use a different algorithm to skip as much as\n      // we can.\n      // Forward pos until\n      //   the trailing part of lookbehind + data\n      //   looks like the beginning of the needle\n      // or until\n      //   pos == 0\n      while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos))\n        pos++;\n    }\n\n    if (pos >= 0) {\n      // Discard lookbehind buffer.\n      this.emit('info', false, lookbehind, 0, this._lookbehind_size);\n      this._lookbehind_size = 0;\n    } else {\n      // Cut off part of the lookbehind buffer that has\n      // been processed and append the entire haystack\n      // into it.\n      var bytesToCutOff = this._lookbehind_size + pos;\n\n      if (bytesToCutOff > 0) {\n        // The cut off data is guaranteed not to contain the needle.\n        this.emit('info', false, lookbehind, 0, bytesToCutOff);\n      }\n\n      lookbehind.copy(lookbehind, 0, bytesToCutOff,\n                      this._lookbehind_size - bytesToCutOff);\n      this._lookbehind_size -= bytesToCutOff;\n\n      data.copy(lookbehind, this._lookbehind_size);\n      this._lookbehind_size += len;\n\n      this._bufpos = len;\n      return len;\n    }\n  }\n\n  if (pos >= 0)\n    pos += this._bufpos;\n\n  // Lookbehind buffer is now empty. Perform Boyer-Moore-Horspool\n  // search with optimized character lookup code that only considers\n  // the current round's haystack data.\n  while (pos <= len - needle_len) {\n    var ch = data[pos + needle_len - 1];\n\n    if (ch === last_needle_char\n        && data[pos] === needle[0]\n        && jsmemcmp(needle, 0, data, pos, needle_len - 1)) {\n      ++this.matches;\n      if (pos > 0)\n        this.emit('info', true, data, this._bufpos, pos);\n      else\n        this.emit('info', true);\n\n      this._bufpos = pos + needle_len;\n      return pos + needle_len;\n    } else\n      pos += occ[ch];\n  }\n\n  // There was no match. If there's trailing haystack data that we cannot\n  // match yet using the Boyer-Moore-Horspool algorithm (because the trailing\n  // data is less than the needle size) then match using a modified\n  // algorithm that starts matching from the beginning instead of the end.\n  // Whatever trailing data is left after running this algorithm is added to\n  // the lookbehind buffer.\n  if (pos < len) {\n    while (pos < len && (data[pos] !== needle[0]\n                         || !jsmemcmp(data, pos, needle, 0, len - pos))) {\n      ++pos;\n    }\n    if (pos < len) {\n      data.copy(lookbehind, 0, pos, pos + (len - pos));\n      this._lookbehind_size = len - pos;\n    }\n  }\n\n  // Everything until pos is guaranteed not to contain needle data.\n  if (pos > 0)\n    this.emit('info', false, data, this._bufpos, pos < len ? pos : len);\n\n  this._bufpos = len;\n  return len;\n};\n\nSBMH.prototype._sbmh_lookup_char = function(data, pos) {\n  if (pos < 0)\n    return this._lookbehind[this._lookbehind_size + pos];\n  else\n    return data[pos];\n}\n\nSBMH.prototype._sbmh_memcmp = function(data, pos, len) {\n  var i = 0;\n\n  while (i < len) {\n    if (this._sbmh_lookup_char(data, pos + i) === this._needle[i])\n      ++i;\n    else\n      return false;\n  }\n  return true;\n}\n\nmodule.exports = SBMH;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","var chownr = require('chownr')\nvar tar = require('tar-stream')\nvar pump = require('pump')\nvar mkdirp = require('mkdirp-classic')\nvar fs = require('fs')\nvar path = require('path')\nvar os = require('os')\n\nvar win32 = os.platform() === 'win32'\n\nvar noop = function () {}\n\nvar echo = function (name) {\n  return name\n}\n\nvar normalize = !win32 ? echo : function (name) {\n  return name.replace(/\\\\/g, '/').replace(/[:?<>|]/g, '_')\n}\n\nvar statAll = function (fs, stat, cwd, ignore, entries, sort) {\n  var queue = entries || ['.']\n\n  return function loop (callback) {\n    if (!queue.length) return callback()\n    var next = queue.shift()\n    var nextAbs = path.join(cwd, next)\n\n    stat(nextAbs, function (err, stat) {\n      if (err) return callback(err)\n\n      if (!stat.isDirectory()) return callback(null, next, stat)\n\n      fs.readdir(nextAbs, function (err, files) {\n        if (err) return callback(err)\n\n        if (sort) files.sort()\n        for (var i = 0; i < files.length; i++) {\n          if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]))\n        }\n\n        callback(null, next, stat)\n      })\n    })\n  }\n}\n\nvar strip = function (map, level) {\n  return function (header) {\n    header.name = header.name.split('/').slice(level).join('/')\n\n    var linkname = header.linkname\n    if (linkname && (header.type === 'link' || path.isAbsolute(linkname))) {\n      header.linkname = linkname.split('/').slice(level).join('/')\n    }\n\n    return map(header)\n  }\n}\n\nexports.pack = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort)\n  var strict = opts.strict !== false\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var pack = opts.pack || tar.pack()\n  var finish = opts.finish || noop\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var onsymlink = function (filename, header) {\n    xfs.readlink(path.join(cwd, filename), function (err, linkname) {\n      if (err) return pack.destroy(err)\n      header.linkname = normalize(linkname)\n      pack.entry(header, onnextentry)\n    })\n  }\n\n  var onstat = function (err, filename, stat) {\n    if (err) return pack.destroy(err)\n    if (!filename) {\n      if (opts.finalize !== false) pack.finalize()\n      return finish(pack)\n    }\n\n    if (stat.isSocket()) return onnextentry() // tar does not support sockets...\n\n    var header = {\n      name: normalize(filename),\n      mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,\n      mtime: stat.mtime,\n      size: stat.size,\n      type: 'file',\n      uid: stat.uid,\n      gid: stat.gid\n    }\n\n    if (stat.isDirectory()) {\n      header.size = 0\n      header.type = 'directory'\n      header = map(header) || header\n      return pack.entry(header, onnextentry)\n    }\n\n    if (stat.isSymbolicLink()) {\n      header.size = 0\n      header.type = 'symlink'\n      header = map(header) || header\n      return onsymlink(filename, header)\n    }\n\n    // TODO: add fifo etc...\n\n    header = map(header) || header\n\n    if (!stat.isFile()) {\n      if (strict) return pack.destroy(new Error('unsupported type for ' + filename))\n      return onnextentry()\n    }\n\n    var entry = pack.entry(header, onnextentry)\n    if (!entry) return\n\n    var rs = mapStream(xfs.createReadStream(path.join(cwd, filename)), header)\n\n    rs.on('error', function (err) { // always forward errors on destroy\n      entry.destroy(err)\n    })\n\n    pump(rs, entry)\n  }\n\n  var onnextentry = function (err) {\n    if (err) return pack.destroy(err)\n    statNext(onstat)\n  }\n\n  onnextentry()\n\n  return pack\n}\n\nvar head = function (list) {\n  return list.length ? list[list.length - 1] : null\n}\n\nvar processGetuid = function () {\n  return process.getuid ? process.getuid() : -1\n}\n\nvar processUmask = function () {\n  return process.umask ? process.umask() : 0\n}\n\nexports.extract = function (cwd, opts) {\n  if (!cwd) cwd = '.'\n  if (!opts) opts = {}\n\n  var xfs = opts.fs || fs\n  var ignore = opts.ignore || opts.filter || noop\n  var map = opts.map || noop\n  var mapStream = opts.mapStream || echo\n  var own = opts.chown !== false && !win32 && processGetuid() === 0\n  var extract = opts.extract || tar.extract()\n  var stack = []\n  var now = new Date()\n  var umask = typeof opts.umask === 'number' ? ~opts.umask : ~processUmask()\n  var dmode = typeof opts.dmode === 'number' ? opts.dmode : 0\n  var fmode = typeof opts.fmode === 'number' ? opts.fmode : 0\n  var strict = opts.strict !== false\n\n  if (opts.strip) map = strip(map, opts.strip)\n\n  if (opts.readable) {\n    dmode |= parseInt(555, 8)\n    fmode |= parseInt(444, 8)\n  }\n  if (opts.writable) {\n    dmode |= parseInt(333, 8)\n    fmode |= parseInt(222, 8)\n  }\n\n  var utimesParent = function (name, cb) { // we just set the mtime on the parent dir again everytime we write an entry\n    var top\n    while ((top = head(stack)) && name.slice(0, top[0].length) !== top[0]) stack.pop()\n    if (!top) return cb()\n    xfs.utimes(top[0], now, top[1], cb)\n  }\n\n  var utimes = function (name, header, cb) {\n    if (opts.utimes === false) return cb()\n\n    if (header.type === 'directory') return xfs.utimes(name, now, header.mtime, cb)\n    if (header.type === 'symlink') return utimesParent(name, cb) // TODO: how to set mtime on link?\n\n    xfs.utimes(name, now, header.mtime, function (err) {\n      if (err) return cb(err)\n      utimesParent(name, cb)\n    })\n  }\n\n  var chperm = function (name, header, cb) {\n    var link = header.type === 'symlink'\n\n    /* eslint-disable node/no-deprecated-api */\n    var chmod = link ? xfs.lchmod : xfs.chmod\n    var chown = link ? xfs.lchown : xfs.chown\n    /* eslint-enable node/no-deprecated-api */\n\n    if (!chmod) return cb()\n\n    var mode = (header.mode | (header.type === 'directory' ? dmode : fmode)) & umask\n    chmod(name, mode, function (err) {\n      if (err) return cb(err)\n      if (!own) return cb()\n      if (!chown) return cb()\n      chown(name, header.uid, header.gid, cb)\n    })\n  }\n\n  extract.on('entry', function (header, stream, next) {\n    header = map(header) || header\n    header.name = normalize(header.name)\n    var name = path.join(cwd, path.join('/', header.name))\n\n    if (ignore(name, header)) {\n      stream.resume()\n      return next()\n    }\n\n    var stat = function (err) {\n      if (err) return next(err)\n      utimes(name, header, function (err) {\n        if (err) return next(err)\n        if (win32) return next()\n        chperm(name, header, next)\n      })\n    }\n\n    var onsymlink = function () {\n      if (win32) return next() // skip symlinks on win for now before it can be tested\n      xfs.unlink(name, function () {\n        xfs.symlink(header.linkname, name, stat)\n      })\n    }\n\n    var onlink = function () {\n      if (win32) return next() // skip links on win for now before it can be tested\n      xfs.unlink(name, function () {\n        var srcpath = path.join(cwd, path.join('/', header.linkname))\n\n        xfs.link(srcpath, name, function (err) {\n          if (err && err.code === 'EPERM' && opts.hardlinkAsFilesFallback) {\n            stream = xfs.createReadStream(srcpath)\n            return onfile()\n          }\n\n          stat(err)\n        })\n      })\n    }\n\n    var onfile = function () {\n      var ws = xfs.createWriteStream(name)\n      var rs = mapStream(stream, header)\n\n      ws.on('error', function (err) { // always forward errors on destroy\n        rs.destroy(err)\n      })\n\n      pump(rs, ws, function (err) {\n        if (err) return next(err)\n        ws.on('close', stat)\n      })\n    }\n\n    if (header.type === 'directory') {\n      stack.push([name, header.mtime])\n      return mkdirfix(name, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, stat)\n    }\n\n    var dir = path.dirname(name)\n\n    validate(xfs, dir, path.join(cwd, '.'), function (err, valid) {\n      if (err) return next(err)\n      if (!valid) return next(new Error(dir + ' is not a valid path'))\n\n      mkdirfix(dir, {\n        fs: xfs, own: own, uid: header.uid, gid: header.gid\n      }, function (err) {\n        if (err) return next(err)\n\n        switch (header.type) {\n          case 'file': return onfile()\n          case 'link': return onlink()\n          case 'symlink': return onsymlink()\n        }\n\n        if (strict) return next(new Error('unsupported type for ' + name + ' (' + header.type + ')'))\n\n        stream.resume()\n        next()\n      })\n    })\n  })\n\n  if (opts.finish) extract.on('finish', opts.finish)\n\n  return extract\n}\n\nfunction validate (fs, name, root, cb) {\n  if (name === root) return cb(null, true)\n  fs.lstat(name, function (err, st) {\n    if (err && err.code !== 'ENOENT') return cb(err)\n    if (err || st.isDirectory()) return validate(fs, path.join(name, '..'), root, cb)\n    cb(null, false)\n  })\n}\n\nfunction mkdirfix (name, opts, cb) {\n  mkdirp(name, { fs: opts.fs }, function (err, made) {\n    if (!err && made && opts.own) {\n      chownr(made, opts.uid, opts.gid, cb)\n    } else {\n      cb(err)\n    }\n  })\n}\n","var util = require('util')\nvar bl = require('bl')\nvar headers = require('./headers')\n\nvar Writable = require('readable-stream').Writable\nvar PassThrough = require('readable-stream').PassThrough\n\nvar noop = function () {}\n\nvar overflow = function (size) {\n  size &= 511\n  return size && 512 - size\n}\n\nvar emptyStream = function (self, offset) {\n  var s = new Source(self, offset)\n  s.end()\n  return s\n}\n\nvar mixinPax = function (header, pax) {\n  if (pax.path) header.name = pax.path\n  if (pax.linkpath) header.linkname = pax.linkpath\n  if (pax.size) header.size = parseInt(pax.size, 10)\n  header.pax = pax\n  return header\n}\n\nvar Source = function (self, offset) {\n  this._parent = self\n  this.offset = offset\n  PassThrough.call(this, { autoDestroy: false })\n}\n\nutil.inherits(Source, PassThrough)\n\nSource.prototype.destroy = function (err) {\n  this._parent.destroy(err)\n}\n\nvar Extract = function (opts) {\n  if (!(this instanceof Extract)) return new Extract(opts)\n  Writable.call(this, opts)\n\n  opts = opts || {}\n\n  this._offset = 0\n  this._buffer = bl()\n  this._missing = 0\n  this._partial = false\n  this._onparse = noop\n  this._header = null\n  this._stream = null\n  this._overflow = null\n  this._cb = null\n  this._locked = false\n  this._destroyed = false\n  this._pax = null\n  this._paxGlobal = null\n  this._gnuLongPath = null\n  this._gnuLongLinkPath = null\n\n  var self = this\n  var b = self._buffer\n\n  var oncontinue = function () {\n    self._continue()\n  }\n\n  var onunlock = function (err) {\n    self._locked = false\n    if (err) return self.destroy(err)\n    if (!self._stream) oncontinue()\n  }\n\n  var onstreamend = function () {\n    self._stream = null\n    var drain = overflow(self._header.size)\n    if (drain) self._parse(drain, ondrain)\n    else self._parse(512, onheader)\n    if (!self._locked) oncontinue()\n  }\n\n  var ondrain = function () {\n    self._buffer.consume(overflow(self._header.size))\n    self._parse(512, onheader)\n    oncontinue()\n  }\n\n  var onpaxglobalheader = function () {\n    var size = self._header.size\n    self._paxGlobal = headers.decodePax(b.slice(0, size))\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onpaxheader = function () {\n    var size = self._header.size\n    self._pax = headers.decodePax(b.slice(0, size))\n    if (self._paxGlobal) self._pax = Object.assign({}, self._paxGlobal, self._pax)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulongpath = function () {\n    var size = self._header.size\n    this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var ongnulonglinkpath = function () {\n    var size = self._header.size\n    this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding)\n    b.consume(size)\n    onstreamend()\n  }\n\n  var onheader = function () {\n    var offset = self._offset\n    var header\n    try {\n      header = self._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat)\n    } catch (err) {\n      self.emit('error', err)\n    }\n    b.consume(512)\n\n    if (!header) {\n      self._parse(512, onheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-path') {\n      self._parse(header.size, ongnulongpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'gnu-long-link-path') {\n      self._parse(header.size, ongnulonglinkpath)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-global-header') {\n      self._parse(header.size, onpaxglobalheader)\n      oncontinue()\n      return\n    }\n    if (header.type === 'pax-header') {\n      self._parse(header.size, onpaxheader)\n      oncontinue()\n      return\n    }\n\n    if (self._gnuLongPath) {\n      header.name = self._gnuLongPath\n      self._gnuLongPath = null\n    }\n\n    if (self._gnuLongLinkPath) {\n      header.linkname = self._gnuLongLinkPath\n      self._gnuLongLinkPath = null\n    }\n\n    if (self._pax) {\n      self._header = header = mixinPax(header, self._pax)\n      self._pax = null\n    }\n\n    self._locked = true\n\n    if (!header.size || header.type === 'directory') {\n      self._parse(512, onheader)\n      self.emit('entry', header, emptyStream(self, offset), onunlock)\n      return\n    }\n\n    self._stream = new Source(self, offset)\n\n    self.emit('entry', header, self._stream, onunlock)\n    self._parse(header.size, onstreamend)\n    oncontinue()\n  }\n\n  this._onheader = onheader\n  this._parse(512, onheader)\n}\n\nutil.inherits(Extract, Writable)\n\nExtract.prototype.destroy = function (err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream) this._stream.emit('close')\n}\n\nExtract.prototype._parse = function (size, onparse) {\n  if (this._destroyed) return\n  this._offset += size\n  this._missing = size\n  if (onparse === this._onheader) this._partial = false\n  this._onparse = onparse\n}\n\nExtract.prototype._continue = function () {\n  if (this._destroyed) return\n  var cb = this._cb\n  this._cb = noop\n  if (this._overflow) this._write(this._overflow, undefined, cb)\n  else cb()\n}\n\nExtract.prototype._write = function (data, enc, cb) {\n  if (this._destroyed) return\n\n  var s = this._stream\n  var b = this._buffer\n  var missing = this._missing\n  if (data.length) this._partial = true\n\n  // we do not reach end-of-chunk now. just forward it\n\n  if (data.length < missing) {\n    this._missing -= data.length\n    this._overflow = null\n    if (s) return s.write(data, cb)\n    b.append(data)\n    return cb()\n  }\n\n  // end-of-chunk. the parser should call cb.\n\n  this._cb = cb\n  this._missing = 0\n\n  var overflow = null\n  if (data.length > missing) {\n    overflow = data.slice(missing)\n    data = data.slice(0, missing)\n  }\n\n  if (s) s.end(data)\n  else b.append(data)\n\n  this._overflow = overflow\n  this._onparse()\n}\n\nExtract.prototype._final = function (cb) {\n  if (this._partial) return this.destroy(new Error('Unexpected end of data'))\n  cb()\n}\n\nmodule.exports = Extract\n","var alloc = Buffer.alloc\n\nvar ZEROS = '0000000000000000000'\nvar SEVENS = '7777777777777777777'\nvar ZERO_OFFSET = '0'.charCodeAt(0)\nvar USTAR_MAGIC = Buffer.from('ustar\\x00', 'binary')\nvar USTAR_VER = Buffer.from('00', 'binary')\nvar GNU_MAGIC = Buffer.from('ustar\\x20', 'binary')\nvar GNU_VER = Buffer.from('\\x20\\x00', 'binary')\nvar MASK = parseInt('7777', 8)\nvar MAGIC_OFFSET = 257\nvar VERSION_OFFSET = 263\n\nvar clamp = function (index, len, defaultValue) {\n  if (typeof index !== 'number') return defaultValue\n  index = ~~index // Coerce to integer.\n  if (index >= len) return len\n  if (index >= 0) return index\n  index += len\n  if (index >= 0) return index\n  return 0\n}\n\nvar toType = function (flag) {\n  switch (flag) {\n    case 0:\n      return 'file'\n    case 1:\n      return 'link'\n    case 2:\n      return 'symlink'\n    case 3:\n      return 'character-device'\n    case 4:\n      return 'block-device'\n    case 5:\n      return 'directory'\n    case 6:\n      return 'fifo'\n    case 7:\n      return 'contiguous-file'\n    case 72:\n      return 'pax-header'\n    case 55:\n      return 'pax-global-header'\n    case 27:\n      return 'gnu-long-link-path'\n    case 28:\n    case 30:\n      return 'gnu-long-path'\n  }\n\n  return null\n}\n\nvar toTypeflag = function (flag) {\n  switch (flag) {\n    case 'file':\n      return 0\n    case 'link':\n      return 1\n    case 'symlink':\n      return 2\n    case 'character-device':\n      return 3\n    case 'block-device':\n      return 4\n    case 'directory':\n      return 5\n    case 'fifo':\n      return 6\n    case 'contiguous-file':\n      return 7\n    case 'pax-header':\n      return 72\n  }\n\n  return 0\n}\n\nvar indexOf = function (block, num, offset, end) {\n  for (; offset < end; offset++) {\n    if (block[offset] === num) return offset\n  }\n  return end\n}\n\nvar cksum = function (block) {\n  var sum = 8 * 32\n  for (var i = 0; i < 148; i++) sum += block[i]\n  for (var j = 156; j < 512; j++) sum += block[j]\n  return sum\n}\n\nvar encodeOct = function (val, n) {\n  val = val.toString(8)\n  if (val.length > n) return SEVENS.slice(0, n) + ' '\n  else return ZEROS.slice(0, n - val.length) + val + ' '\n}\n\n/* Copied from the node-tar repo and modified to meet\n * tar-stream coding standard.\n *\n * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349\n */\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  var tuple = []\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf[i]\n    if (positive) tuple.push(byte)\n    else tuple.push(0xFF - byte)\n  }\n\n  var sum = 0\n  var l = tuple.length\n  for (i = 0; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nvar decodeOct = function (val, offset, length) {\n  val = val.slice(offset, offset + length)\n  offset = 0\n\n  // If prefixed with 0x80 then parse as a base-256 integer\n  if (val[offset] & 0x80) {\n    return parse256(val)\n  } else {\n    // Older versions of tar can prefix with spaces\n    while (offset < val.length && val[offset] === 32) offset++\n    var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length)\n    while (offset < end && val[offset] === 0) offset++\n    if (end === offset) return 0\n    return parseInt(val.slice(offset, end).toString(), 8)\n  }\n}\n\nvar decodeStr = function (val, offset, length, encoding) {\n  return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding)\n}\n\nvar addLength = function (str) {\n  var len = Buffer.byteLength(str)\n  var digits = Math.floor(Math.log(len) / Math.log(10)) + 1\n  if (len + digits >= Math.pow(10, digits)) digits++\n\n  return (len + digits) + str\n}\n\nexports.decodeLongPath = function (buf, encoding) {\n  return decodeStr(buf, 0, buf.length, encoding)\n}\n\nexports.encodePax = function (opts) { // TODO: encode more stuff in pax\n  var result = ''\n  if (opts.name) result += addLength(' path=' + opts.name + '\\n')\n  if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\\n')\n  var pax = opts.pax\n  if (pax) {\n    for (var key in pax) {\n      result += addLength(' ' + key + '=' + pax[key] + '\\n')\n    }\n  }\n  return Buffer.from(result)\n}\n\nexports.decodePax = function (buf) {\n  var result = {}\n\n  while (buf.length) {\n    var i = 0\n    while (i < buf.length && buf[i] !== 32) i++\n    var len = parseInt(buf.slice(0, i).toString(), 10)\n    if (!len) return result\n\n    var b = buf.slice(i + 1, len - 1).toString()\n    var keyIndex = b.indexOf('=')\n    if (keyIndex === -1) return result\n    result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1)\n\n    buf = buf.slice(len)\n  }\n\n  return result\n}\n\nexports.encode = function (opts) {\n  var buf = alloc(512)\n  var name = opts.name\n  var prefix = ''\n\n  if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/'\n  if (Buffer.byteLength(name) !== name.length) return null // utf-8\n\n  while (Buffer.byteLength(name) > 100) {\n    var i = name.indexOf('/')\n    if (i === -1) return null\n    prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i)\n    name = name.slice(i + 1)\n  }\n\n  if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null\n  if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null\n\n  buf.write(name)\n  buf.write(encodeOct(opts.mode & MASK, 6), 100)\n  buf.write(encodeOct(opts.uid, 6), 108)\n  buf.write(encodeOct(opts.gid, 6), 116)\n  buf.write(encodeOct(opts.size, 11), 124)\n  buf.write(encodeOct((opts.mtime.getTime() / 1000) | 0, 11), 136)\n\n  buf[156] = ZERO_OFFSET + toTypeflag(opts.type)\n\n  if (opts.linkname) buf.write(opts.linkname, 157)\n\n  USTAR_MAGIC.copy(buf, MAGIC_OFFSET)\n  USTAR_VER.copy(buf, VERSION_OFFSET)\n  if (opts.uname) buf.write(opts.uname, 265)\n  if (opts.gname) buf.write(opts.gname, 297)\n  buf.write(encodeOct(opts.devmajor || 0, 6), 329)\n  buf.write(encodeOct(opts.devminor || 0, 6), 337)\n\n  if (prefix) buf.write(prefix, 345)\n\n  buf.write(encodeOct(cksum(buf), 6), 148)\n\n  return buf\n}\n\nexports.decode = function (buf, filenameEncoding, allowUnknownFormat) {\n  var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET\n\n  var name = decodeStr(buf, 0, 100, filenameEncoding)\n  var mode = decodeOct(buf, 100, 8)\n  var uid = decodeOct(buf, 108, 8)\n  var gid = decodeOct(buf, 116, 8)\n  var size = decodeOct(buf, 124, 12)\n  var mtime = decodeOct(buf, 136, 12)\n  var type = toType(typeflag)\n  var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding)\n  var uname = decodeStr(buf, 265, 32)\n  var gname = decodeStr(buf, 297, 32)\n  var devmajor = decodeOct(buf, 329, 8)\n  var devminor = decodeOct(buf, 337, 8)\n\n  var c = cksum(buf)\n\n  // checksum is still initial value if header was null.\n  if (c === 8 * 32) return null\n\n  // valid checksum\n  if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?')\n\n  if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {\n    // ustar (posix) format.\n    // prepend prefix, if present.\n    if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name\n  } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 &&\n             GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {\n    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and\n    // multi-volume tarballs.\n  } else {\n    if (!allowUnknownFormat) {\n      throw new Error('Invalid tar header: unknown format.')\n    }\n  }\n\n  // to support old tar versions that use trailing / to indicate dirs\n  if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5\n\n  return {\n    name,\n    mode,\n    uid,\n    gid,\n    size,\n    mtime: new Date(1000 * mtime),\n    type,\n    linkname,\n    uname,\n    gname,\n    devmajor,\n    devminor\n  }\n}\n","exports.extract = require('./extract')\nexports.pack = require('./pack')\n","var constants = require('fs-constants')\nvar eos = require('end-of-stream')\nvar inherits = require('inherits')\nvar alloc = Buffer.alloc\n\nvar Readable = require('readable-stream').Readable\nvar Writable = require('readable-stream').Writable\nvar StringDecoder = require('string_decoder').StringDecoder\n\nvar headers = require('./headers')\n\nvar DMODE = parseInt('755', 8)\nvar FMODE = parseInt('644', 8)\n\nvar END_OF_TAR = alloc(1024)\n\nvar noop = function () {}\n\nvar overflow = function (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.slice(0, 512 - size))\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nvar Sink = function (to) {\n  Writable.call(this)\n  this.written = 0\n  this._to = to\n  this._destroyed = false\n}\n\ninherits(Sink, Writable)\n\nSink.prototype._write = function (data, enc, cb) {\n  this.written += data.length\n  if (this._to.push(data)) return cb()\n  this._to._drain = cb\n}\n\nSink.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar LinkSink = function () {\n  Writable.call(this)\n  this.linkname = ''\n  this._decoder = new StringDecoder('utf-8')\n  this._destroyed = false\n}\n\ninherits(LinkSink, Writable)\n\nLinkSink.prototype._write = function (data, enc, cb) {\n  this.linkname += this._decoder.write(data)\n  cb()\n}\n\nLinkSink.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Void = function () {\n  Writable.call(this)\n  this._destroyed = false\n}\n\ninherits(Void, Writable)\n\nVoid.prototype._write = function (data, enc, cb) {\n  cb(new Error('No body allowed for this entry'))\n}\n\nVoid.prototype.destroy = function () {\n  if (this._destroyed) return\n  this._destroyed = true\n  this.emit('close')\n}\n\nvar Pack = function (opts) {\n  if (!(this instanceof Pack)) return new Pack(opts)\n  Readable.call(this, opts)\n\n  this._drain = noop\n  this._finalized = false\n  this._finalizing = false\n  this._destroyed = false\n  this._stream = null\n}\n\ninherits(Pack, Readable)\n\nPack.prototype.entry = function (header, buffer, callback) {\n  if (this._stream) throw new Error('already piping an entry')\n  if (this._finalized || this._destroyed) return\n\n  if (typeof buffer === 'function') {\n    callback = buffer\n    buffer = null\n  }\n\n  if (!callback) callback = noop\n\n  var self = this\n\n  if (!header.size || header.type === 'symlink') header.size = 0\n  if (!header.type) header.type = modeToType(header.mode)\n  if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n  if (!header.uid) header.uid = 0\n  if (!header.gid) header.gid = 0\n  if (!header.mtime) header.mtime = new Date()\n\n  if (typeof buffer === 'string') buffer = Buffer.from(buffer)\n  if (Buffer.isBuffer(buffer)) {\n    header.size = buffer.length\n    this._encode(header)\n    var ok = this.push(buffer)\n    overflow(self, header.size)\n    if (ok) process.nextTick(callback)\n    else this._drain = callback\n    return new Void()\n  }\n\n  if (header.type === 'symlink' && !header.linkname) {\n    var linkSink = new LinkSink()\n    eos(linkSink, function (err) {\n      if (err) { // stream was closed\n        self.destroy()\n        return callback(err)\n      }\n\n      header.linkname = linkSink.linkname\n      self._encode(header)\n      callback()\n    })\n\n    return linkSink\n  }\n\n  this._encode(header)\n\n  if (header.type !== 'file' && header.type !== 'contiguous-file') {\n    process.nextTick(callback)\n    return new Void()\n  }\n\n  var sink = new Sink(this)\n\n  this._stream = sink\n\n  eos(sink, function (err) {\n    self._stream = null\n\n    if (err) { // stream was closed\n      self.destroy()\n      return callback(err)\n    }\n\n    if (sink.written !== header.size) { // corrupting tar\n      self.destroy()\n      return callback(new Error('size mismatch'))\n    }\n\n    overflow(self, header.size)\n    if (self._finalizing) self.finalize()\n    callback()\n  })\n\n  return sink\n}\n\nPack.prototype.finalize = function () {\n  if (this._stream) {\n    this._finalizing = true\n    return\n  }\n\n  if (this._finalized) return\n  this._finalized = true\n  this.push(END_OF_TAR)\n  this.push(null)\n}\n\nPack.prototype.destroy = function (err) {\n  if (this._destroyed) return\n  this._destroyed = true\n\n  if (err) this.emit('error', err)\n  this.emit('close')\n  if (this._stream && this._stream.destroy) this._stream.destroy()\n}\n\nPack.prototype._encode = function (header) {\n  if (!header.pax) {\n    var buf = headers.encode(header)\n    if (buf) {\n      this.push(buf)\n      return\n    }\n  }\n  this._encodePax(header)\n}\n\nPack.prototype._encodePax = function (header) {\n  var paxHeader = headers.encodePax({\n    name: header.name,\n    linkname: header.linkname,\n    pax: header.pax\n  })\n\n  var newHeader = {\n    name: 'PaxHeader',\n    mode: header.mode,\n    uid: header.uid,\n    gid: header.gid,\n    size: paxHeader.length,\n    mtime: header.mtime,\n    type: 'pax-header',\n    linkname: header.linkname && 'PaxHeader',\n    uname: header.uname,\n    gname: header.gname,\n    devmajor: header.devmajor,\n    devminor: header.devminor\n  }\n\n  this.push(headers.encode(newHeader))\n  this.push(paxHeader)\n  overflow(this, paxHeader.length)\n\n  newHeader.size = header.size\n  newHeader.type = header.type\n  this.push(headers.encode(newHeader))\n}\n\nPack.prototype._read = function (n) {\n  var drain = this._drain\n  this._drain = noop\n  drain()\n}\n\nmodule.exports = Pack\n","(function(nacl) {\n'use strict';\n\n// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.\n// Public domain.\n//\n// Implementation derived from TweetNaCl version 20140427.\n// See for details: http://tweetnacl.cr.yp.to/\n\nvar gf = function(init) {\n  var i, r = new Float64Array(16);\n  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];\n  return r;\n};\n\n//  Pluggable, initialized in high-level API below.\nvar randombytes = function(/* x, n */) { throw new Error('no PRNG'); };\n\nvar _0 = new Uint8Array(16);\nvar _9 = new Uint8Array(32); _9[0] = 9;\n\nvar gf0 = gf(),\n    gf1 = gf([1]),\n    _121665 = gf([0xdb41, 1]),\n    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),\n    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),\n    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),\n    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),\n    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);\n\nfunction ts64(x, i, h, l) {\n  x[i]   = (h >> 24) & 0xff;\n  x[i+1] = (h >> 16) & 0xff;\n  x[i+2] = (h >>  8) & 0xff;\n  x[i+3] = h & 0xff;\n  x[i+4] = (l >> 24)  & 0xff;\n  x[i+5] = (l >> 16)  & 0xff;\n  x[i+6] = (l >>  8)  & 0xff;\n  x[i+7] = l & 0xff;\n}\n\nfunction vn(x, xi, y, yi, n) {\n  var i,d = 0;\n  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];\n  return (1 & ((d - 1) >>> 8)) - 1;\n}\n\nfunction crypto_verify_16(x, xi, y, yi) {\n  return vn(x,xi,y,yi,16);\n}\n\nfunction crypto_verify_32(x, xi, y, yi) {\n  return vn(x,xi,y,yi,32);\n}\n\nfunction core_salsa20(o, p, k, c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n   x0 =  x0 +  j0 | 0;\n   x1 =  x1 +  j1 | 0;\n   x2 =  x2 +  j2 | 0;\n   x3 =  x3 +  j3 | 0;\n   x4 =  x4 +  j4 | 0;\n   x5 =  x5 +  j5 | 0;\n   x6 =  x6 +  j6 | 0;\n   x7 =  x7 +  j7 | 0;\n   x8 =  x8 +  j8 | 0;\n   x9 =  x9 +  j9 | 0;\n  x10 = x10 + j10 | 0;\n  x11 = x11 + j11 | 0;\n  x12 = x12 + j12 | 0;\n  x13 = x13 + j13 | 0;\n  x14 = x14 + j14 | 0;\n  x15 = x15 + j15 | 0;\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x1 >>>  0 & 0xff;\n  o[ 5] = x1 >>>  8 & 0xff;\n  o[ 6] = x1 >>> 16 & 0xff;\n  o[ 7] = x1 >>> 24 & 0xff;\n\n  o[ 8] = x2 >>>  0 & 0xff;\n  o[ 9] = x2 >>>  8 & 0xff;\n  o[10] = x2 >>> 16 & 0xff;\n  o[11] = x2 >>> 24 & 0xff;\n\n  o[12] = x3 >>>  0 & 0xff;\n  o[13] = x3 >>>  8 & 0xff;\n  o[14] = x3 >>> 16 & 0xff;\n  o[15] = x3 >>> 24 & 0xff;\n\n  o[16] = x4 >>>  0 & 0xff;\n  o[17] = x4 >>>  8 & 0xff;\n  o[18] = x4 >>> 16 & 0xff;\n  o[19] = x4 >>> 24 & 0xff;\n\n  o[20] = x5 >>>  0 & 0xff;\n  o[21] = x5 >>>  8 & 0xff;\n  o[22] = x5 >>> 16 & 0xff;\n  o[23] = x5 >>> 24 & 0xff;\n\n  o[24] = x6 >>>  0 & 0xff;\n  o[25] = x6 >>>  8 & 0xff;\n  o[26] = x6 >>> 16 & 0xff;\n  o[27] = x6 >>> 24 & 0xff;\n\n  o[28] = x7 >>>  0 & 0xff;\n  o[29] = x7 >>>  8 & 0xff;\n  o[30] = x7 >>> 16 & 0xff;\n  o[31] = x7 >>> 24 & 0xff;\n\n  o[32] = x8 >>>  0 & 0xff;\n  o[33] = x8 >>>  8 & 0xff;\n  o[34] = x8 >>> 16 & 0xff;\n  o[35] = x8 >>> 24 & 0xff;\n\n  o[36] = x9 >>>  0 & 0xff;\n  o[37] = x9 >>>  8 & 0xff;\n  o[38] = x9 >>> 16 & 0xff;\n  o[39] = x9 >>> 24 & 0xff;\n\n  o[40] = x10 >>>  0 & 0xff;\n  o[41] = x10 >>>  8 & 0xff;\n  o[42] = x10 >>> 16 & 0xff;\n  o[43] = x10 >>> 24 & 0xff;\n\n  o[44] = x11 >>>  0 & 0xff;\n  o[45] = x11 >>>  8 & 0xff;\n  o[46] = x11 >>> 16 & 0xff;\n  o[47] = x11 >>> 24 & 0xff;\n\n  o[48] = x12 >>>  0 & 0xff;\n  o[49] = x12 >>>  8 & 0xff;\n  o[50] = x12 >>> 16 & 0xff;\n  o[51] = x12 >>> 24 & 0xff;\n\n  o[52] = x13 >>>  0 & 0xff;\n  o[53] = x13 >>>  8 & 0xff;\n  o[54] = x13 >>> 16 & 0xff;\n  o[55] = x13 >>> 24 & 0xff;\n\n  o[56] = x14 >>>  0 & 0xff;\n  o[57] = x14 >>>  8 & 0xff;\n  o[58] = x14 >>> 16 & 0xff;\n  o[59] = x14 >>> 24 & 0xff;\n\n  o[60] = x15 >>>  0 & 0xff;\n  o[61] = x15 >>>  8 & 0xff;\n  o[62] = x15 >>> 16 & 0xff;\n  o[63] = x15 >>> 24 & 0xff;\n}\n\nfunction core_hsalsa20(o,p,k,c) {\n  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,\n      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,\n      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,\n      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,\n      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,\n      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,\n      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,\n      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,\n      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,\n      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,\n      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,\n      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,\n      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,\n      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,\n      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,\n      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;\n\n  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,\n      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,\n      x15 = j15, u;\n\n  for (var i = 0; i < 20; i += 2) {\n    u = x0 + x12 | 0;\n    x4 ^= u<<7 | u>>>(32-7);\n    u = x4 + x0 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x4 | 0;\n    x12 ^= u<<13 | u>>>(32-13);\n    u = x12 + x8 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x1 | 0;\n    x9 ^= u<<7 | u>>>(32-7);\n    u = x9 + x5 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x9 | 0;\n    x1 ^= u<<13 | u>>>(32-13);\n    u = x1 + x13 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x6 | 0;\n    x14 ^= u<<7 | u>>>(32-7);\n    u = x14 + x10 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x14 | 0;\n    x6 ^= u<<13 | u>>>(32-13);\n    u = x6 + x2 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x11 | 0;\n    x3 ^= u<<7 | u>>>(32-7);\n    u = x3 + x15 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x3 | 0;\n    x11 ^= u<<13 | u>>>(32-13);\n    u = x11 + x7 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n\n    u = x0 + x3 | 0;\n    x1 ^= u<<7 | u>>>(32-7);\n    u = x1 + x0 | 0;\n    x2 ^= u<<9 | u>>>(32-9);\n    u = x2 + x1 | 0;\n    x3 ^= u<<13 | u>>>(32-13);\n    u = x3 + x2 | 0;\n    x0 ^= u<<18 | u>>>(32-18);\n\n    u = x5 + x4 | 0;\n    x6 ^= u<<7 | u>>>(32-7);\n    u = x6 + x5 | 0;\n    x7 ^= u<<9 | u>>>(32-9);\n    u = x7 + x6 | 0;\n    x4 ^= u<<13 | u>>>(32-13);\n    u = x4 + x7 | 0;\n    x5 ^= u<<18 | u>>>(32-18);\n\n    u = x10 + x9 | 0;\n    x11 ^= u<<7 | u>>>(32-7);\n    u = x11 + x10 | 0;\n    x8 ^= u<<9 | u>>>(32-9);\n    u = x8 + x11 | 0;\n    x9 ^= u<<13 | u>>>(32-13);\n    u = x9 + x8 | 0;\n    x10 ^= u<<18 | u>>>(32-18);\n\n    u = x15 + x14 | 0;\n    x12 ^= u<<7 | u>>>(32-7);\n    u = x12 + x15 | 0;\n    x13 ^= u<<9 | u>>>(32-9);\n    u = x13 + x12 | 0;\n    x14 ^= u<<13 | u>>>(32-13);\n    u = x14 + x13 | 0;\n    x15 ^= u<<18 | u>>>(32-18);\n  }\n\n  o[ 0] = x0 >>>  0 & 0xff;\n  o[ 1] = x0 >>>  8 & 0xff;\n  o[ 2] = x0 >>> 16 & 0xff;\n  o[ 3] = x0 >>> 24 & 0xff;\n\n  o[ 4] = x5 >>>  0 & 0xff;\n  o[ 5] = x5 >>>  8 & 0xff;\n  o[ 6] = x5 >>> 16 & 0xff;\n  o[ 7] = x5 >>> 24 & 0xff;\n\n  o[ 8] = x10 >>>  0 & 0xff;\n  o[ 9] = x10 >>>  8 & 0xff;\n  o[10] = x10 >>> 16 & 0xff;\n  o[11] = x10 >>> 24 & 0xff;\n\n  o[12] = x15 >>>  0 & 0xff;\n  o[13] = x15 >>>  8 & 0xff;\n  o[14] = x15 >>> 16 & 0xff;\n  o[15] = x15 >>> 24 & 0xff;\n\n  o[16] = x6 >>>  0 & 0xff;\n  o[17] = x6 >>>  8 & 0xff;\n  o[18] = x6 >>> 16 & 0xff;\n  o[19] = x6 >>> 24 & 0xff;\n\n  o[20] = x7 >>>  0 & 0xff;\n  o[21] = x7 >>>  8 & 0xff;\n  o[22] = x7 >>> 16 & 0xff;\n  o[23] = x7 >>> 24 & 0xff;\n\n  o[24] = x8 >>>  0 & 0xff;\n  o[25] = x8 >>>  8 & 0xff;\n  o[26] = x8 >>> 16 & 0xff;\n  o[27] = x8 >>> 24 & 0xff;\n\n  o[28] = x9 >>>  0 & 0xff;\n  o[29] = x9 >>>  8 & 0xff;\n  o[30] = x9 >>> 16 & 0xff;\n  o[31] = x9 >>> 24 & 0xff;\n}\n\nfunction crypto_core_salsa20(out,inp,k,c) {\n  core_salsa20(out,inp,k,c);\n}\n\nfunction crypto_core_hsalsa20(out,inp,k,c) {\n  core_hsalsa20(out,inp,k,c);\n}\n\nvar sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);\n            // \"expand 32-byte k\"\n\nfunction crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n    mpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream_salsa20(c,cpos,b,n,k) {\n  var z = new Uint8Array(16), x = new Uint8Array(64);\n  var u, i;\n  for (i = 0; i < 16; i++) z[i] = 0;\n  for (i = 0; i < 8; i++) z[i] = n[i];\n  while (b >= 64) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < 64; i++) c[cpos+i] = x[i];\n    u = 1;\n    for (i = 8; i < 16; i++) {\n      u = u + (z[i] & 0xff) | 0;\n      z[i] = u & 0xff;\n      u >>>= 8;\n    }\n    b -= 64;\n    cpos += 64;\n  }\n  if (b > 0) {\n    crypto_core_salsa20(x,z,k,sigma);\n    for (i = 0; i < b; i++) c[cpos+i] = x[i];\n  }\n  return 0;\n}\n\nfunction crypto_stream(c,cpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20(c,cpos,d,sn,s);\n}\n\nfunction crypto_stream_xor(c,cpos,m,mpos,d,n,k) {\n  var s = new Uint8Array(32);\n  crypto_core_hsalsa20(s,n,k,sigma);\n  var sn = new Uint8Array(8);\n  for (var i = 0; i < 8; i++) sn[i] = n[i+16];\n  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);\n}\n\n/*\n* Port of Andrew Moon's Poly1305-donna-16. Public domain.\n* https://github.com/floodyberry/poly1305-donna\n*/\n\nvar poly1305 = function(key) {\n  this.buffer = new Uint8Array(16);\n  this.r = new Uint16Array(10);\n  this.h = new Uint16Array(10);\n  this.pad = new Uint16Array(8);\n  this.leftover = 0;\n  this.fin = 0;\n\n  var t0, t1, t2, t3, t4, t5, t6, t7;\n\n  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;\n  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;\n  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;\n  this.r[5] = ((t4 >>>  1)) & 0x1ffe;\n  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;\n  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n  this.r[9] = ((t7 >>>  5)) & 0x007f;\n\n  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;\n  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;\n  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;\n  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;\n  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;\n  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;\n  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;\n  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;\n};\n\npoly1305.prototype.blocks = function(m, mpos, bytes) {\n  var hibit = this.fin ? 0 : (1 << 11);\n  var t0, t1, t2, t3, t4, t5, t6, t7, c;\n  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;\n\n  var h0 = this.h[0],\n      h1 = this.h[1],\n      h2 = this.h[2],\n      h3 = this.h[3],\n      h4 = this.h[4],\n      h5 = this.h[5],\n      h6 = this.h[6],\n      h7 = this.h[7],\n      h8 = this.h[8],\n      h9 = this.h[9];\n\n  var r0 = this.r[0],\n      r1 = this.r[1],\n      r2 = this.r[2],\n      r3 = this.r[3],\n      r4 = this.r[4],\n      r5 = this.r[5],\n      r6 = this.r[6],\n      r7 = this.r[7],\n      r8 = this.r[8],\n      r9 = this.r[9];\n\n  while (bytes >= 16) {\n    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;\n    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;\n    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;\n    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;\n    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;\n    h5 += ((t4 >>>  1)) & 0x1fff;\n    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;\n    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;\n    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;\n    h9 += ((t7 >>> 5)) | hibit;\n\n    c = 0;\n\n    d0 = c;\n    d0 += h0 * r0;\n    d0 += h1 * (5 * r9);\n    d0 += h2 * (5 * r8);\n    d0 += h3 * (5 * r7);\n    d0 += h4 * (5 * r6);\n    c = (d0 >>> 13); d0 &= 0x1fff;\n    d0 += h5 * (5 * r5);\n    d0 += h6 * (5 * r4);\n    d0 += h7 * (5 * r3);\n    d0 += h8 * (5 * r2);\n    d0 += h9 * (5 * r1);\n    c += (d0 >>> 13); d0 &= 0x1fff;\n\n    d1 = c;\n    d1 += h0 * r1;\n    d1 += h1 * r0;\n    d1 += h2 * (5 * r9);\n    d1 += h3 * (5 * r8);\n    d1 += h4 * (5 * r7);\n    c = (d1 >>> 13); d1 &= 0x1fff;\n    d1 += h5 * (5 * r6);\n    d1 += h6 * (5 * r5);\n    d1 += h7 * (5 * r4);\n    d1 += h8 * (5 * r3);\n    d1 += h9 * (5 * r2);\n    c += (d1 >>> 13); d1 &= 0x1fff;\n\n    d2 = c;\n    d2 += h0 * r2;\n    d2 += h1 * r1;\n    d2 += h2 * r0;\n    d2 += h3 * (5 * r9);\n    d2 += h4 * (5 * r8);\n    c = (d2 >>> 13); d2 &= 0x1fff;\n    d2 += h5 * (5 * r7);\n    d2 += h6 * (5 * r6);\n    d2 += h7 * (5 * r5);\n    d2 += h8 * (5 * r4);\n    d2 += h9 * (5 * r3);\n    c += (d2 >>> 13); d2 &= 0x1fff;\n\n    d3 = c;\n    d3 += h0 * r3;\n    d3 += h1 * r2;\n    d3 += h2 * r1;\n    d3 += h3 * r0;\n    d3 += h4 * (5 * r9);\n    c = (d3 >>> 13); d3 &= 0x1fff;\n    d3 += h5 * (5 * r8);\n    d3 += h6 * (5 * r7);\n    d3 += h7 * (5 * r6);\n    d3 += h8 * (5 * r5);\n    d3 += h9 * (5 * r4);\n    c += (d3 >>> 13); d3 &= 0x1fff;\n\n    d4 = c;\n    d4 += h0 * r4;\n    d4 += h1 * r3;\n    d4 += h2 * r2;\n    d4 += h3 * r1;\n    d4 += h4 * r0;\n    c = (d4 >>> 13); d4 &= 0x1fff;\n    d4 += h5 * (5 * r9);\n    d4 += h6 * (5 * r8);\n    d4 += h7 * (5 * r7);\n    d4 += h8 * (5 * r6);\n    d4 += h9 * (5 * r5);\n    c += (d4 >>> 13); d4 &= 0x1fff;\n\n    d5 = c;\n    d5 += h0 * r5;\n    d5 += h1 * r4;\n    d5 += h2 * r3;\n    d5 += h3 * r2;\n    d5 += h4 * r1;\n    c = (d5 >>> 13); d5 &= 0x1fff;\n    d5 += h5 * r0;\n    d5 += h6 * (5 * r9);\n    d5 += h7 * (5 * r8);\n    d5 += h8 * (5 * r7);\n    d5 += h9 * (5 * r6);\n    c += (d5 >>> 13); d5 &= 0x1fff;\n\n    d6 = c;\n    d6 += h0 * r6;\n    d6 += h1 * r5;\n    d6 += h2 * r4;\n    d6 += h3 * r3;\n    d6 += h4 * r2;\n    c = (d6 >>> 13); d6 &= 0x1fff;\n    d6 += h5 * r1;\n    d6 += h6 * r0;\n    d6 += h7 * (5 * r9);\n    d6 += h8 * (5 * r8);\n    d6 += h9 * (5 * r7);\n    c += (d6 >>> 13); d6 &= 0x1fff;\n\n    d7 = c;\n    d7 += h0 * r7;\n    d7 += h1 * r6;\n    d7 += h2 * r5;\n    d7 += h3 * r4;\n    d7 += h4 * r3;\n    c = (d7 >>> 13); d7 &= 0x1fff;\n    d7 += h5 * r2;\n    d7 += h6 * r1;\n    d7 += h7 * r0;\n    d7 += h8 * (5 * r9);\n    d7 += h9 * (5 * r8);\n    c += (d7 >>> 13); d7 &= 0x1fff;\n\n    d8 = c;\n    d8 += h0 * r8;\n    d8 += h1 * r7;\n    d8 += h2 * r6;\n    d8 += h3 * r5;\n    d8 += h4 * r4;\n    c = (d8 >>> 13); d8 &= 0x1fff;\n    d8 += h5 * r3;\n    d8 += h6 * r2;\n    d8 += h7 * r1;\n    d8 += h8 * r0;\n    d8 += h9 * (5 * r9);\n    c += (d8 >>> 13); d8 &= 0x1fff;\n\n    d9 = c;\n    d9 += h0 * r9;\n    d9 += h1 * r8;\n    d9 += h2 * r7;\n    d9 += h3 * r6;\n    d9 += h4 * r5;\n    c = (d9 >>> 13); d9 &= 0x1fff;\n    d9 += h5 * r4;\n    d9 += h6 * r3;\n    d9 += h7 * r2;\n    d9 += h8 * r1;\n    d9 += h9 * r0;\n    c += (d9 >>> 13); d9 &= 0x1fff;\n\n    c = (((c << 2) + c)) | 0;\n    c = (c + d0) | 0;\n    d0 = c & 0x1fff;\n    c = (c >>> 13);\n    d1 += c;\n\n    h0 = d0;\n    h1 = d1;\n    h2 = d2;\n    h3 = d3;\n    h4 = d4;\n    h5 = d5;\n    h6 = d6;\n    h7 = d7;\n    h8 = d8;\n    h9 = d9;\n\n    mpos += 16;\n    bytes -= 16;\n  }\n  this.h[0] = h0;\n  this.h[1] = h1;\n  this.h[2] = h2;\n  this.h[3] = h3;\n  this.h[4] = h4;\n  this.h[5] = h5;\n  this.h[6] = h6;\n  this.h[7] = h7;\n  this.h[8] = h8;\n  this.h[9] = h9;\n};\n\npoly1305.prototype.finish = function(mac, macpos) {\n  var g = new Uint16Array(10);\n  var c, mask, f, i;\n\n  if (this.leftover) {\n    i = this.leftover;\n    this.buffer[i++] = 1;\n    for (; i < 16; i++) this.buffer[i] = 0;\n    this.fin = 1;\n    this.blocks(this.buffer, 0, 16);\n  }\n\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  for (i = 2; i < 10; i++) {\n    this.h[i] += c;\n    c = this.h[i] >>> 13;\n    this.h[i] &= 0x1fff;\n  }\n  this.h[0] += (c * 5);\n  c = this.h[0] >>> 13;\n  this.h[0] &= 0x1fff;\n  this.h[1] += c;\n  c = this.h[1] >>> 13;\n  this.h[1] &= 0x1fff;\n  this.h[2] += c;\n\n  g[0] = this.h[0] + 5;\n  c = g[0] >>> 13;\n  g[0] &= 0x1fff;\n  for (i = 1; i < 10; i++) {\n    g[i] = this.h[i] + c;\n    c = g[i] >>> 13;\n    g[i] &= 0x1fff;\n  }\n  g[9] -= (1 << 13);\n\n  mask = (c ^ 1) - 1;\n  for (i = 0; i < 10; i++) g[i] &= mask;\n  mask = ~mask;\n  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];\n\n  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;\n  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;\n  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;\n  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;\n  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;\n  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;\n  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;\n  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;\n\n  f = this.h[0] + this.pad[0];\n  this.h[0] = f & 0xffff;\n  for (i = 1; i < 8; i++) {\n    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;\n    this.h[i] = f & 0xffff;\n  }\n\n  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;\n  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;\n  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;\n  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;\n  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;\n  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;\n  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;\n  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;\n  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;\n  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;\n  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;\n  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;\n  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;\n  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;\n  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;\n  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;\n};\n\npoly1305.prototype.update = function(m, mpos, bytes) {\n  var i, want;\n\n  if (this.leftover) {\n    want = (16 - this.leftover);\n    if (want > bytes)\n      want = bytes;\n    for (i = 0; i < want; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    bytes -= want;\n    mpos += want;\n    this.leftover += want;\n    if (this.leftover < 16)\n      return;\n    this.blocks(this.buffer, 0, 16);\n    this.leftover = 0;\n  }\n\n  if (bytes >= 16) {\n    want = bytes - (bytes % 16);\n    this.blocks(m, mpos, want);\n    mpos += want;\n    bytes -= want;\n  }\n\n  if (bytes) {\n    for (i = 0; i < bytes; i++)\n      this.buffer[this.leftover + i] = m[mpos+i];\n    this.leftover += bytes;\n  }\n};\n\nfunction crypto_onetimeauth(out, outpos, m, mpos, n, k) {\n  var s = new poly1305(k);\n  s.update(m, mpos, n);\n  s.finish(out, outpos);\n  return 0;\n}\n\nfunction crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {\n  var x = new Uint8Array(16);\n  crypto_onetimeauth(x,0,m,mpos,n,k);\n  return crypto_verify_16(h,hpos,x,0);\n}\n\nfunction crypto_secretbox(c,m,d,n,k) {\n  var i;\n  if (d < 32) return -1;\n  crypto_stream_xor(c,0,m,0,d,n,k);\n  crypto_onetimeauth(c, 16, c, 32, d - 32, c);\n  for (i = 0; i < 16; i++) c[i] = 0;\n  return 0;\n}\n\nfunction crypto_secretbox_open(m,c,d,n,k) {\n  var i;\n  var x = new Uint8Array(32);\n  if (d < 32) return -1;\n  crypto_stream(x,0,32,n,k);\n  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;\n  crypto_stream_xor(m,0,c,0,d,n,k);\n  for (i = 0; i < 32; i++) m[i] = 0;\n  return 0;\n}\n\nfunction set25519(r, a) {\n  var i;\n  for (i = 0; i < 16; i++) r[i] = a[i]|0;\n}\n\nfunction car25519(o) {\n  var i, v, c = 1;\n  for (i = 0; i < 16; i++) {\n    v = o[i] + c + 65535;\n    c = Math.floor(v / 65536);\n    o[i] = v - c * 65536;\n  }\n  o[0] += c-1 + 37 * (c-1);\n}\n\nfunction sel25519(p, q, b) {\n  var t, c = ~(b-1);\n  for (var i = 0; i < 16; i++) {\n    t = c & (p[i] ^ q[i]);\n    p[i] ^= t;\n    q[i] ^= t;\n  }\n}\n\nfunction pack25519(o, n) {\n  var i, j, b;\n  var m = gf(), t = gf();\n  for (i = 0; i < 16; i++) t[i] = n[i];\n  car25519(t);\n  car25519(t);\n  car25519(t);\n  for (j = 0; j < 2; j++) {\n    m[0] = t[0] - 0xffed;\n    for (i = 1; i < 15; i++) {\n      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);\n      m[i-1] &= 0xffff;\n    }\n    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);\n    b = (m[15]>>16) & 1;\n    m[14] &= 0xffff;\n    sel25519(t, m, 1-b);\n  }\n  for (i = 0; i < 16; i++) {\n    o[2*i] = t[i] & 0xff;\n    o[2*i+1] = t[i]>>8;\n  }\n}\n\nfunction neq25519(a, b) {\n  var c = new Uint8Array(32), d = new Uint8Array(32);\n  pack25519(c, a);\n  pack25519(d, b);\n  return crypto_verify_32(c, 0, d, 0);\n}\n\nfunction par25519(a) {\n  var d = new Uint8Array(32);\n  pack25519(d, a);\n  return d[0] & 1;\n}\n\nfunction unpack25519(o, n) {\n  var i;\n  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);\n  o[15] &= 0x7fff;\n}\n\nfunction A(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];\n}\n\nfunction Z(o, a, b) {\n  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];\n}\n\nfunction M(o, a, b) {\n  var v, c,\n     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,\n     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,\n    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,\n    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,\n    b0 = b[0],\n    b1 = b[1],\n    b2 = b[2],\n    b3 = b[3],\n    b4 = b[4],\n    b5 = b[5],\n    b6 = b[6],\n    b7 = b[7],\n    b8 = b[8],\n    b9 = b[9],\n    b10 = b[10],\n    b11 = b[11],\n    b12 = b[12],\n    b13 = b[13],\n    b14 = b[14],\n    b15 = b[15];\n\n  v = a[0];\n  t0 += v * b0;\n  t1 += v * b1;\n  t2 += v * b2;\n  t3 += v * b3;\n  t4 += v * b4;\n  t5 += v * b5;\n  t6 += v * b6;\n  t7 += v * b7;\n  t8 += v * b8;\n  t9 += v * b9;\n  t10 += v * b10;\n  t11 += v * b11;\n  t12 += v * b12;\n  t13 += v * b13;\n  t14 += v * b14;\n  t15 += v * b15;\n  v = a[1];\n  t1 += v * b0;\n  t2 += v * b1;\n  t3 += v * b2;\n  t4 += v * b3;\n  t5 += v * b4;\n  t6 += v * b5;\n  t7 += v * b6;\n  t8 += v * b7;\n  t9 += v * b8;\n  t10 += v * b9;\n  t11 += v * b10;\n  t12 += v * b11;\n  t13 += v * b12;\n  t14 += v * b13;\n  t15 += v * b14;\n  t16 += v * b15;\n  v = a[2];\n  t2 += v * b0;\n  t3 += v * b1;\n  t4 += v * b2;\n  t5 += v * b3;\n  t6 += v * b4;\n  t7 += v * b5;\n  t8 += v * b6;\n  t9 += v * b7;\n  t10 += v * b8;\n  t11 += v * b9;\n  t12 += v * b10;\n  t13 += v * b11;\n  t14 += v * b12;\n  t15 += v * b13;\n  t16 += v * b14;\n  t17 += v * b15;\n  v = a[3];\n  t3 += v * b0;\n  t4 += v * b1;\n  t5 += v * b2;\n  t6 += v * b3;\n  t7 += v * b4;\n  t8 += v * b5;\n  t9 += v * b6;\n  t10 += v * b7;\n  t11 += v * b8;\n  t12 += v * b9;\n  t13 += v * b10;\n  t14 += v * b11;\n  t15 += v * b12;\n  t16 += v * b13;\n  t17 += v * b14;\n  t18 += v * b15;\n  v = a[4];\n  t4 += v * b0;\n  t5 += v * b1;\n  t6 += v * b2;\n  t7 += v * b3;\n  t8 += v * b4;\n  t9 += v * b5;\n  t10 += v * b6;\n  t11 += v * b7;\n  t12 += v * b8;\n  t13 += v * b9;\n  t14 += v * b10;\n  t15 += v * b11;\n  t16 += v * b12;\n  t17 += v * b13;\n  t18 += v * b14;\n  t19 += v * b15;\n  v = a[5];\n  t5 += v * b0;\n  t6 += v * b1;\n  t7 += v * b2;\n  t8 += v * b3;\n  t9 += v * b4;\n  t10 += v * b5;\n  t11 += v * b6;\n  t12 += v * b7;\n  t13 += v * b8;\n  t14 += v * b9;\n  t15 += v * b10;\n  t16 += v * b11;\n  t17 += v * b12;\n  t18 += v * b13;\n  t19 += v * b14;\n  t20 += v * b15;\n  v = a[6];\n  t6 += v * b0;\n  t7 += v * b1;\n  t8 += v * b2;\n  t9 += v * b3;\n  t10 += v * b4;\n  t11 += v * b5;\n  t12 += v * b6;\n  t13 += v * b7;\n  t14 += v * b8;\n  t15 += v * b9;\n  t16 += v * b10;\n  t17 += v * b11;\n  t18 += v * b12;\n  t19 += v * b13;\n  t20 += v * b14;\n  t21 += v * b15;\n  v = a[7];\n  t7 += v * b0;\n  t8 += v * b1;\n  t9 += v * b2;\n  t10 += v * b3;\n  t11 += v * b4;\n  t12 += v * b5;\n  t13 += v * b6;\n  t14 += v * b7;\n  t15 += v * b8;\n  t16 += v * b9;\n  t17 += v * b10;\n  t18 += v * b11;\n  t19 += v * b12;\n  t20 += v * b13;\n  t21 += v * b14;\n  t22 += v * b15;\n  v = a[8];\n  t8 += v * b0;\n  t9 += v * b1;\n  t10 += v * b2;\n  t11 += v * b3;\n  t12 += v * b4;\n  t13 += v * b5;\n  t14 += v * b6;\n  t15 += v * b7;\n  t16 += v * b8;\n  t17 += v * b9;\n  t18 += v * b10;\n  t19 += v * b11;\n  t20 += v * b12;\n  t21 += v * b13;\n  t22 += v * b14;\n  t23 += v * b15;\n  v = a[9];\n  t9 += v * b0;\n  t10 += v * b1;\n  t11 += v * b2;\n  t12 += v * b3;\n  t13 += v * b4;\n  t14 += v * b5;\n  t15 += v * b6;\n  t16 += v * b7;\n  t17 += v * b8;\n  t18 += v * b9;\n  t19 += v * b10;\n  t20 += v * b11;\n  t21 += v * b12;\n  t22 += v * b13;\n  t23 += v * b14;\n  t24 += v * b15;\n  v = a[10];\n  t10 += v * b0;\n  t11 += v * b1;\n  t12 += v * b2;\n  t13 += v * b3;\n  t14 += v * b4;\n  t15 += v * b5;\n  t16 += v * b6;\n  t17 += v * b7;\n  t18 += v * b8;\n  t19 += v * b9;\n  t20 += v * b10;\n  t21 += v * b11;\n  t22 += v * b12;\n  t23 += v * b13;\n  t24 += v * b14;\n  t25 += v * b15;\n  v = a[11];\n  t11 += v * b0;\n  t12 += v * b1;\n  t13 += v * b2;\n  t14 += v * b3;\n  t15 += v * b4;\n  t16 += v * b5;\n  t17 += v * b6;\n  t18 += v * b7;\n  t19 += v * b8;\n  t20 += v * b9;\n  t21 += v * b10;\n  t22 += v * b11;\n  t23 += v * b12;\n  t24 += v * b13;\n  t25 += v * b14;\n  t26 += v * b15;\n  v = a[12];\n  t12 += v * b0;\n  t13 += v * b1;\n  t14 += v * b2;\n  t15 += v * b3;\n  t16 += v * b4;\n  t17 += v * b5;\n  t18 += v * b6;\n  t19 += v * b7;\n  t20 += v * b8;\n  t21 += v * b9;\n  t22 += v * b10;\n  t23 += v * b11;\n  t24 += v * b12;\n  t25 += v * b13;\n  t26 += v * b14;\n  t27 += v * b15;\n  v = a[13];\n  t13 += v * b0;\n  t14 += v * b1;\n  t15 += v * b2;\n  t16 += v * b3;\n  t17 += v * b4;\n  t18 += v * b5;\n  t19 += v * b6;\n  t20 += v * b7;\n  t21 += v * b8;\n  t22 += v * b9;\n  t23 += v * b10;\n  t24 += v * b11;\n  t25 += v * b12;\n  t26 += v * b13;\n  t27 += v * b14;\n  t28 += v * b15;\n  v = a[14];\n  t14 += v * b0;\n  t15 += v * b1;\n  t16 += v * b2;\n  t17 += v * b3;\n  t18 += v * b4;\n  t19 += v * b5;\n  t20 += v * b6;\n  t21 += v * b7;\n  t22 += v * b8;\n  t23 += v * b9;\n  t24 += v * b10;\n  t25 += v * b11;\n  t26 += v * b12;\n  t27 += v * b13;\n  t28 += v * b14;\n  t29 += v * b15;\n  v = a[15];\n  t15 += v * b0;\n  t16 += v * b1;\n  t17 += v * b2;\n  t18 += v * b3;\n  t19 += v * b4;\n  t20 += v * b5;\n  t21 += v * b6;\n  t22 += v * b7;\n  t23 += v * b8;\n  t24 += v * b9;\n  t25 += v * b10;\n  t26 += v * b11;\n  t27 += v * b12;\n  t28 += v * b13;\n  t29 += v * b14;\n  t30 += v * b15;\n\n  t0  += 38 * t16;\n  t1  += 38 * t17;\n  t2  += 38 * t18;\n  t3  += 38 * t19;\n  t4  += 38 * t20;\n  t5  += 38 * t21;\n  t6  += 38 * t22;\n  t7  += 38 * t23;\n  t8  += 38 * t24;\n  t9  += 38 * t25;\n  t10 += 38 * t26;\n  t11 += 38 * t27;\n  t12 += 38 * t28;\n  t13 += 38 * t29;\n  t14 += 38 * t30;\n  // t15 left as is\n\n  // first car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  // second car\n  c = 1;\n  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;\n  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;\n  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;\n  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;\n  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;\n  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;\n  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;\n  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;\n  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;\n  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;\n  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;\n  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;\n  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;\n  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;\n  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;\n  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;\n  t0 += c-1 + 37 * (c-1);\n\n  o[ 0] = t0;\n  o[ 1] = t1;\n  o[ 2] = t2;\n  o[ 3] = t3;\n  o[ 4] = t4;\n  o[ 5] = t5;\n  o[ 6] = t6;\n  o[ 7] = t7;\n  o[ 8] = t8;\n  o[ 9] = t9;\n  o[10] = t10;\n  o[11] = t11;\n  o[12] = t12;\n  o[13] = t13;\n  o[14] = t14;\n  o[15] = t15;\n}\n\nfunction S(o, a) {\n  M(o, a, a);\n}\n\nfunction inv25519(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 253; a >= 0; a--) {\n    S(c, c);\n    if(a !== 2 && a !== 4) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction pow2523(o, i) {\n  var c = gf();\n  var a;\n  for (a = 0; a < 16; a++) c[a] = i[a];\n  for (a = 250; a >= 0; a--) {\n      S(c, c);\n      if(a !== 1) M(c, c, i);\n  }\n  for (a = 0; a < 16; a++) o[a] = c[a];\n}\n\nfunction crypto_scalarmult(q, n, p) {\n  var z = new Uint8Array(32);\n  var x = new Float64Array(80), r, i;\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf();\n  for (i = 0; i < 31; i++) z[i] = n[i];\n  z[31]=(n[31]&127)|64;\n  z[0]&=248;\n  unpack25519(x,p);\n  for (i = 0; i < 16; i++) {\n    b[i]=x[i];\n    d[i]=a[i]=c[i]=0;\n  }\n  a[0]=d[0]=1;\n  for (i=254; i>=0; --i) {\n    r=(z[i>>>3]>>>(i&7))&1;\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n    A(e,a,c);\n    Z(a,a,c);\n    A(c,b,d);\n    Z(b,b,d);\n    S(d,e);\n    S(f,a);\n    M(a,c,a);\n    M(c,b,e);\n    A(e,a,c);\n    Z(a,a,c);\n    S(b,a);\n    Z(c,d,f);\n    M(a,c,_121665);\n    A(a,a,d);\n    M(c,c,a);\n    M(a,d,f);\n    M(d,b,x);\n    S(b,e);\n    sel25519(a,b,r);\n    sel25519(c,d,r);\n  }\n  for (i = 0; i < 16; i++) {\n    x[i+16]=a[i];\n    x[i+32]=c[i];\n    x[i+48]=b[i];\n    x[i+64]=d[i];\n  }\n  var x32 = x.subarray(32);\n  var x16 = x.subarray(16);\n  inv25519(x32,x32);\n  M(x16,x16,x32);\n  pack25519(q,x16);\n  return 0;\n}\n\nfunction crypto_scalarmult_base(q, n) {\n  return crypto_scalarmult(q, n, _9);\n}\n\nfunction crypto_box_keypair(y, x) {\n  randombytes(x, 32);\n  return crypto_scalarmult_base(y, x);\n}\n\nfunction crypto_box_beforenm(k, y, x) {\n  var s = new Uint8Array(32);\n  crypto_scalarmult(s, x, y);\n  return crypto_core_hsalsa20(k, _0, s, sigma);\n}\n\nvar crypto_box_afternm = crypto_secretbox;\nvar crypto_box_open_afternm = crypto_secretbox_open;\n\nfunction crypto_box(c, m, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_afternm(c, m, d, n, k);\n}\n\nfunction crypto_box_open(m, c, d, n, y, x) {\n  var k = new Uint8Array(32);\n  crypto_box_beforenm(k, y, x);\n  return crypto_box_open_afternm(m, c, d, n, k);\n}\n\nvar K = [\n  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n];\n\nfunction crypto_hashblocks_hl(hh, hl, m, n) {\n  var wh = new Int32Array(16), wl = new Int32Array(16),\n      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,\n      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,\n      th, tl, i, j, h, l, a, b, c, d;\n\n  var ah0 = hh[0],\n      ah1 = hh[1],\n      ah2 = hh[2],\n      ah3 = hh[3],\n      ah4 = hh[4],\n      ah5 = hh[5],\n      ah6 = hh[6],\n      ah7 = hh[7],\n\n      al0 = hl[0],\n      al1 = hl[1],\n      al2 = hl[2],\n      al3 = hl[3],\n      al4 = hl[4],\n      al5 = hl[5],\n      al6 = hl[6],\n      al7 = hl[7];\n\n  var pos = 0;\n  while (n >= 128) {\n    for (i = 0; i < 16; i++) {\n      j = 8 * i + pos;\n      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];\n      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];\n    }\n    for (i = 0; i < 80; i++) {\n      bh0 = ah0;\n      bh1 = ah1;\n      bh2 = ah2;\n      bh3 = ah3;\n      bh4 = ah4;\n      bh5 = ah5;\n      bh6 = ah6;\n      bh7 = ah7;\n\n      bl0 = al0;\n      bl1 = al1;\n      bl2 = al2;\n      bl3 = al3;\n      bl4 = al4;\n      bl5 = al5;\n      bl6 = al6;\n      bl7 = al7;\n\n      // add\n      h = ah7;\n      l = al7;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma1\n      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));\n      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Ch\n      h = (ah4 & ah5) ^ (~ah4 & ah6);\n      l = (al4 & al5) ^ (~al4 & al6);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // K\n      h = K[i*2];\n      l = K[i*2+1];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // w\n      h = wh[i%16];\n      l = wl[i%16];\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      th = c & 0xffff | d << 16;\n      tl = a & 0xffff | b << 16;\n\n      // add\n      h = th;\n      l = tl;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      // Sigma0\n      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));\n      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      // Maj\n      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);\n      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh7 = (c & 0xffff) | (d << 16);\n      bl7 = (a & 0xffff) | (b << 16);\n\n      // add\n      h = bh3;\n      l = bl3;\n\n      a = l & 0xffff; b = l >>> 16;\n      c = h & 0xffff; d = h >>> 16;\n\n      h = th;\n      l = tl;\n\n      a += l & 0xffff; b += l >>> 16;\n      c += h & 0xffff; d += h >>> 16;\n\n      b += a >>> 16;\n      c += b >>> 16;\n      d += c >>> 16;\n\n      bh3 = (c & 0xffff) | (d << 16);\n      bl3 = (a & 0xffff) | (b << 16);\n\n      ah1 = bh0;\n      ah2 = bh1;\n      ah3 = bh2;\n      ah4 = bh3;\n      ah5 = bh4;\n      ah6 = bh5;\n      ah7 = bh6;\n      ah0 = bh7;\n\n      al1 = bl0;\n      al2 = bl1;\n      al3 = bl2;\n      al4 = bl3;\n      al5 = bl4;\n      al6 = bl5;\n      al7 = bl6;\n      al0 = bl7;\n\n      if (i%16 === 15) {\n        for (j = 0; j < 16; j++) {\n          // add\n          h = wh[j];\n          l = wl[j];\n\n          a = l & 0xffff; b = l >>> 16;\n          c = h & 0xffff; d = h >>> 16;\n\n          h = wh[(j+9)%16];\n          l = wl[(j+9)%16];\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma0\n          th = wh[(j+1)%16];\n          tl = wl[(j+1)%16];\n          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);\n          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          // sigma1\n          th = wh[(j+14)%16];\n          tl = wl[(j+14)%16];\n          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);\n          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));\n\n          a += l & 0xffff; b += l >>> 16;\n          c += h & 0xffff; d += h >>> 16;\n\n          b += a >>> 16;\n          c += b >>> 16;\n          d += c >>> 16;\n\n          wh[j] = (c & 0xffff) | (d << 16);\n          wl[j] = (a & 0xffff) | (b << 16);\n        }\n      }\n    }\n\n    // add\n    h = ah0;\n    l = al0;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[0];\n    l = hl[0];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[0] = ah0 = (c & 0xffff) | (d << 16);\n    hl[0] = al0 = (a & 0xffff) | (b << 16);\n\n    h = ah1;\n    l = al1;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[1];\n    l = hl[1];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[1] = ah1 = (c & 0xffff) | (d << 16);\n    hl[1] = al1 = (a & 0xffff) | (b << 16);\n\n    h = ah2;\n    l = al2;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[2];\n    l = hl[2];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[2] = ah2 = (c & 0xffff) | (d << 16);\n    hl[2] = al2 = (a & 0xffff) | (b << 16);\n\n    h = ah3;\n    l = al3;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[3];\n    l = hl[3];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[3] = ah3 = (c & 0xffff) | (d << 16);\n    hl[3] = al3 = (a & 0xffff) | (b << 16);\n\n    h = ah4;\n    l = al4;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[4];\n    l = hl[4];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[4] = ah4 = (c & 0xffff) | (d << 16);\n    hl[4] = al4 = (a & 0xffff) | (b << 16);\n\n    h = ah5;\n    l = al5;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[5];\n    l = hl[5];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[5] = ah5 = (c & 0xffff) | (d << 16);\n    hl[5] = al5 = (a & 0xffff) | (b << 16);\n\n    h = ah6;\n    l = al6;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[6];\n    l = hl[6];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[6] = ah6 = (c & 0xffff) | (d << 16);\n    hl[6] = al6 = (a & 0xffff) | (b << 16);\n\n    h = ah7;\n    l = al7;\n\n    a = l & 0xffff; b = l >>> 16;\n    c = h & 0xffff; d = h >>> 16;\n\n    h = hh[7];\n    l = hl[7];\n\n    a += l & 0xffff; b += l >>> 16;\n    c += h & 0xffff; d += h >>> 16;\n\n    b += a >>> 16;\n    c += b >>> 16;\n    d += c >>> 16;\n\n    hh[7] = ah7 = (c & 0xffff) | (d << 16);\n    hl[7] = al7 = (a & 0xffff) | (b << 16);\n\n    pos += 128;\n    n -= 128;\n  }\n\n  return n;\n}\n\nfunction crypto_hash(out, m, n) {\n  var hh = new Int32Array(8),\n      hl = new Int32Array(8),\n      x = new Uint8Array(256),\n      i, b = n;\n\n  hh[0] = 0x6a09e667;\n  hh[1] = 0xbb67ae85;\n  hh[2] = 0x3c6ef372;\n  hh[3] = 0xa54ff53a;\n  hh[4] = 0x510e527f;\n  hh[5] = 0x9b05688c;\n  hh[6] = 0x1f83d9ab;\n  hh[7] = 0x5be0cd19;\n\n  hl[0] = 0xf3bcc908;\n  hl[1] = 0x84caa73b;\n  hl[2] = 0xfe94f82b;\n  hl[3] = 0x5f1d36f1;\n  hl[4] = 0xade682d1;\n  hl[5] = 0x2b3e6c1f;\n  hl[6] = 0xfb41bd6b;\n  hl[7] = 0x137e2179;\n\n  crypto_hashblocks_hl(hh, hl, m, n);\n  n %= 128;\n\n  for (i = 0; i < n; i++) x[i] = m[b-n+i];\n  x[n] = 128;\n\n  n = 256-128*(n<112?1:0);\n  x[n-9] = 0;\n  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);\n  crypto_hashblocks_hl(hh, hl, x, n);\n\n  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);\n\n  return 0;\n}\n\nfunction add(p, q) {\n  var a = gf(), b = gf(), c = gf(),\n      d = gf(), e = gf(), f = gf(),\n      g = gf(), h = gf(), t = gf();\n\n  Z(a, p[1], p[0]);\n  Z(t, q[1], q[0]);\n  M(a, a, t);\n  A(b, p[0], p[1]);\n  A(t, q[0], q[1]);\n  M(b, b, t);\n  M(c, p[3], q[3]);\n  M(c, c, D2);\n  M(d, p[2], q[2]);\n  A(d, d, d);\n  Z(e, b, a);\n  Z(f, d, c);\n  A(g, d, c);\n  A(h, b, a);\n\n  M(p[0], e, f);\n  M(p[1], h, g);\n  M(p[2], g, f);\n  M(p[3], e, h);\n}\n\nfunction cswap(p, q, b) {\n  var i;\n  for (i = 0; i < 4; i++) {\n    sel25519(p[i], q[i], b);\n  }\n}\n\nfunction pack(r, p) {\n  var tx = gf(), ty = gf(), zi = gf();\n  inv25519(zi, p[2]);\n  M(tx, p[0], zi);\n  M(ty, p[1], zi);\n  pack25519(r, ty);\n  r[31] ^= par25519(tx) << 7;\n}\n\nfunction scalarmult(p, q, s) {\n  var b, i;\n  set25519(p[0], gf0);\n  set25519(p[1], gf1);\n  set25519(p[2], gf1);\n  set25519(p[3], gf0);\n  for (i = 255; i >= 0; --i) {\n    b = (s[(i/8)|0] >> (i&7)) & 1;\n    cswap(p, q, b);\n    add(q, p);\n    add(p, p);\n    cswap(p, q, b);\n  }\n}\n\nfunction scalarbase(p, s) {\n  var q = [gf(), gf(), gf(), gf()];\n  set25519(q[0], X);\n  set25519(q[1], Y);\n  set25519(q[2], gf1);\n  M(q[3], X, Y);\n  scalarmult(p, q, s);\n}\n\nfunction crypto_sign_keypair(pk, sk, seeded) {\n  var d = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n  var i;\n\n  if (!seeded) randombytes(sk, 32);\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  scalarbase(p, d);\n  pack(pk, p);\n\n  for (i = 0; i < 32; i++) sk[i+32] = pk[i];\n  return 0;\n}\n\nvar L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);\n\nfunction modL(r, x) {\n  var carry, i, j, k;\n  for (i = 63; i >= 32; --i) {\n    carry = 0;\n    for (j = i - 32, k = i - 12; j < k; ++j) {\n      x[j] += carry - 16 * x[i] * L[j - (i - 32)];\n      carry = (x[j] + 128) >> 8;\n      x[j] -= carry * 256;\n    }\n    x[j] += carry;\n    x[i] = 0;\n  }\n  carry = 0;\n  for (j = 0; j < 32; j++) {\n    x[j] += carry - (x[31] >> 4) * L[j];\n    carry = x[j] >> 8;\n    x[j] &= 255;\n  }\n  for (j = 0; j < 32; j++) x[j] -= carry * L[j];\n  for (i = 0; i < 32; i++) {\n    x[i+1] += x[i] >> 8;\n    r[i] = x[i] & 255;\n  }\n}\n\nfunction reduce(r) {\n  var x = new Float64Array(64), i;\n  for (i = 0; i < 64; i++) x[i] = r[i];\n  for (i = 0; i < 64; i++) r[i] = 0;\n  modL(r, x);\n}\n\n// Note: difference from C - smlen returned, not passed as argument.\nfunction crypto_sign(sm, m, n, sk) {\n  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);\n  var i, j, x = new Float64Array(64);\n  var p = [gf(), gf(), gf(), gf()];\n\n  crypto_hash(d, sk, 32);\n  d[0] &= 248;\n  d[31] &= 127;\n  d[31] |= 64;\n\n  var smlen = n + 64;\n  for (i = 0; i < n; i++) sm[64 + i] = m[i];\n  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];\n\n  crypto_hash(r, sm.subarray(32), n+32);\n  reduce(r);\n  scalarbase(p, r);\n  pack(sm, p);\n\n  for (i = 32; i < 64; i++) sm[i] = sk[i];\n  crypto_hash(h, sm, n + 64);\n  reduce(h);\n\n  for (i = 0; i < 64; i++) x[i] = 0;\n  for (i = 0; i < 32; i++) x[i] = r[i];\n  for (i = 0; i < 32; i++) {\n    for (j = 0; j < 32; j++) {\n      x[i+j] += h[i] * d[j];\n    }\n  }\n\n  modL(sm.subarray(32), x);\n  return smlen;\n}\n\nfunction unpackneg(r, p) {\n  var t = gf(), chk = gf(), num = gf(),\n      den = gf(), den2 = gf(), den4 = gf(),\n      den6 = gf();\n\n  set25519(r[2], gf1);\n  unpack25519(r[1], p);\n  S(num, r[1]);\n  M(den, num, D);\n  Z(num, num, r[2]);\n  A(den, r[2], den);\n\n  S(den2, den);\n  S(den4, den2);\n  M(den6, den4, den2);\n  M(t, den6, num);\n  M(t, t, den);\n\n  pow2523(t, t);\n  M(t, t, num);\n  M(t, t, den);\n  M(t, t, den);\n  M(r[0], t, den);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) M(r[0], r[0], I);\n\n  S(chk, r[0]);\n  M(chk, chk, den);\n  if (neq25519(chk, num)) return -1;\n\n  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);\n\n  M(r[3], r[0], r[1]);\n  return 0;\n}\n\nfunction crypto_sign_open(m, sm, n, pk) {\n  var i, mlen;\n  var t = new Uint8Array(32), h = new Uint8Array(64);\n  var p = [gf(), gf(), gf(), gf()],\n      q = [gf(), gf(), gf(), gf()];\n\n  mlen = -1;\n  if (n < 64) return -1;\n\n  if (unpackneg(q, pk)) return -1;\n\n  for (i = 0; i < n; i++) m[i] = sm[i];\n  for (i = 0; i < 32; i++) m[i+32] = pk[i];\n  crypto_hash(h, m, n);\n  reduce(h);\n  scalarmult(p, q, h);\n\n  scalarbase(q, sm.subarray(32));\n  add(p, q);\n  pack(t, p);\n\n  n -= 64;\n  if (crypto_verify_32(sm, 0, t, 0)) {\n    for (i = 0; i < n; i++) m[i] = 0;\n    return -1;\n  }\n\n  for (i = 0; i < n; i++) m[i] = sm[i + 64];\n  mlen = n;\n  return mlen;\n}\n\nvar crypto_secretbox_KEYBYTES = 32,\n    crypto_secretbox_NONCEBYTES = 24,\n    crypto_secretbox_ZEROBYTES = 32,\n    crypto_secretbox_BOXZEROBYTES = 16,\n    crypto_scalarmult_BYTES = 32,\n    crypto_scalarmult_SCALARBYTES = 32,\n    crypto_box_PUBLICKEYBYTES = 32,\n    crypto_box_SECRETKEYBYTES = 32,\n    crypto_box_BEFORENMBYTES = 32,\n    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,\n    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,\n    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,\n    crypto_sign_BYTES = 64,\n    crypto_sign_PUBLICKEYBYTES = 32,\n    crypto_sign_SECRETKEYBYTES = 64,\n    crypto_sign_SEEDBYTES = 32,\n    crypto_hash_BYTES = 64;\n\nnacl.lowlevel = {\n  crypto_core_hsalsa20: crypto_core_hsalsa20,\n  crypto_stream_xor: crypto_stream_xor,\n  crypto_stream: crypto_stream,\n  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,\n  crypto_stream_salsa20: crypto_stream_salsa20,\n  crypto_onetimeauth: crypto_onetimeauth,\n  crypto_onetimeauth_verify: crypto_onetimeauth_verify,\n  crypto_verify_16: crypto_verify_16,\n  crypto_verify_32: crypto_verify_32,\n  crypto_secretbox: crypto_secretbox,\n  crypto_secretbox_open: crypto_secretbox_open,\n  crypto_scalarmult: crypto_scalarmult,\n  crypto_scalarmult_base: crypto_scalarmult_base,\n  crypto_box_beforenm: crypto_box_beforenm,\n  crypto_box_afternm: crypto_box_afternm,\n  crypto_box: crypto_box,\n  crypto_box_open: crypto_box_open,\n  crypto_box_keypair: crypto_box_keypair,\n  crypto_hash: crypto_hash,\n  crypto_sign: crypto_sign,\n  crypto_sign_keypair: crypto_sign_keypair,\n  crypto_sign_open: crypto_sign_open,\n\n  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,\n  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,\n  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,\n  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,\n  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,\n  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,\n  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,\n  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,\n  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,\n  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,\n  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,\n  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,\n  crypto_sign_BYTES: crypto_sign_BYTES,\n  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,\n  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,\n  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,\n  crypto_hash_BYTES: crypto_hash_BYTES\n};\n\n/* High-level API */\n\nfunction checkLengths(k, n) {\n  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');\n  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');\n}\n\nfunction checkBoxLengths(pk, sk) {\n  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');\n  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');\n}\n\nfunction checkArrayTypes() {\n  var t, i;\n  for (i = 0; i < arguments.length; i++) {\n     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')\n       throw new TypeError('unexpected type ' + t + ', use Uint8Array');\n  }\n}\n\nfunction cleanup(arr) {\n  for (var i = 0; i < arr.length; i++) arr[i] = 0;\n}\n\n// TODO: Completely remove this in v0.15.\nif (!nacl.util) {\n  nacl.util = {};\n  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {\n    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');\n  };\n}\n\nnacl.randomBytes = function(n) {\n  var b = new Uint8Array(n);\n  randombytes(b, n);\n  return b;\n};\n\nnacl.secretbox = function(msg, nonce, key) {\n  checkArrayTypes(msg, nonce, key);\n  checkLengths(key, nonce);\n  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);\n  var c = new Uint8Array(m.length);\n  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];\n  crypto_secretbox(c, m, m.length, nonce, key);\n  return c.subarray(crypto_secretbox_BOXZEROBYTES);\n};\n\nnacl.secretbox.open = function(box, nonce, key) {\n  checkArrayTypes(box, nonce, key);\n  checkLengths(key, nonce);\n  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);\n  var m = new Uint8Array(c.length);\n  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];\n  if (c.length < 32) return false;\n  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;\n  return m.subarray(crypto_secretbox_ZEROBYTES);\n};\n\nnacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;\nnacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;\nnacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;\n\nnacl.scalarMult = function(n, p) {\n  checkArrayTypes(n, p);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult(q, n, p);\n  return q;\n};\n\nnacl.scalarMult.base = function(n) {\n  checkArrayTypes(n);\n  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');\n  var q = new Uint8Array(crypto_scalarmult_BYTES);\n  crypto_scalarmult_base(q, n);\n  return q;\n};\n\nnacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;\nnacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;\n\nnacl.box = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox(msg, nonce, k);\n};\n\nnacl.box.before = function(publicKey, secretKey) {\n  checkArrayTypes(publicKey, secretKey);\n  checkBoxLengths(publicKey, secretKey);\n  var k = new Uint8Array(crypto_box_BEFORENMBYTES);\n  crypto_box_beforenm(k, publicKey, secretKey);\n  return k;\n};\n\nnacl.box.after = nacl.secretbox;\n\nnacl.box.open = function(msg, nonce, publicKey, secretKey) {\n  var k = nacl.box.before(publicKey, secretKey);\n  return nacl.secretbox.open(msg, nonce, k);\n};\n\nnacl.box.open.after = nacl.secretbox.open;\n\nnacl.box.keyPair = function() {\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);\n  crypto_box_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.box.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_box_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);\n  crypto_scalarmult_base(pk, secretKey);\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;\nnacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;\nnacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;\nnacl.box.nonceLength = crypto_box_NONCEBYTES;\nnacl.box.overheadLength = nacl.secretbox.overheadLength;\n\nnacl.sign = function(msg, secretKey) {\n  checkArrayTypes(msg, secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);\n  crypto_sign(signedMsg, msg, msg.length, secretKey);\n  return signedMsg;\n};\n\nnacl.sign.open = function(signedMsg, publicKey) {\n  if (arguments.length !== 2)\n    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');\n  checkArrayTypes(signedMsg, publicKey);\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var tmp = new Uint8Array(signedMsg.length);\n  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);\n  if (mlen < 0) return null;\n  var m = new Uint8Array(mlen);\n  for (var i = 0; i < m.length; i++) m[i] = tmp[i];\n  return m;\n};\n\nnacl.sign.detached = function(msg, secretKey) {\n  var signedMsg = nacl.sign(msg, secretKey);\n  var sig = new Uint8Array(crypto_sign_BYTES);\n  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];\n  return sig;\n};\n\nnacl.sign.detached.verify = function(msg, sig, publicKey) {\n  checkArrayTypes(msg, sig, publicKey);\n  if (sig.length !== crypto_sign_BYTES)\n    throw new Error('bad signature size');\n  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)\n    throw new Error('bad public key size');\n  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var m = new Uint8Array(crypto_sign_BYTES + msg.length);\n  var i;\n  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];\n  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];\n  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);\n};\n\nnacl.sign.keyPair = function() {\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  crypto_sign_keypair(pk, sk);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.keyPair.fromSecretKey = function(secretKey) {\n  checkArrayTypes(secretKey);\n  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)\n    throw new Error('bad secret key size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];\n  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};\n};\n\nnacl.sign.keyPair.fromSeed = function(seed) {\n  checkArrayTypes(seed);\n  if (seed.length !== crypto_sign_SEEDBYTES)\n    throw new Error('bad seed size');\n  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);\n  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);\n  for (var i = 0; i < 32; i++) sk[i] = seed[i];\n  crypto_sign_keypair(pk, sk, true);\n  return {publicKey: pk, secretKey: sk};\n};\n\nnacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;\nnacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;\nnacl.sign.seedLength = crypto_sign_SEEDBYTES;\nnacl.sign.signatureLength = crypto_sign_BYTES;\n\nnacl.hash = function(msg) {\n  checkArrayTypes(msg);\n  var h = new Uint8Array(crypto_hash_BYTES);\n  crypto_hash(h, msg, msg.length);\n  return h;\n};\n\nnacl.hash.hashLength = crypto_hash_BYTES;\n\nnacl.verify = function(x, y) {\n  checkArrayTypes(x, y);\n  // Zero length arguments are considered not equal.\n  if (x.length === 0 || y.length === 0) return false;\n  if (x.length !== y.length) return false;\n  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;\n};\n\nnacl.setPRNG = function(fn) {\n  randombytes = fn;\n};\n\n(function() {\n  // Initialize PRNG if environment provides CSPRNG.\n  // If not, methods calling randombytes will throw.\n  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;\n  if (crypto && crypto.getRandomValues) {\n    // Browsers.\n    var QUOTA = 65536;\n    nacl.setPRNG(function(x, n) {\n      var i, v = new Uint8Array(n);\n      for (i = 0; i < n; i += QUOTA) {\n        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));\n      }\n      for (i = 0; i < n; i++) x[i] = v[i];\n      cleanup(v);\n    });\n  } else if (typeof require !== 'undefined') {\n    // Node.js.\n    crypto = require('crypto');\n    if (crypto && crypto.randomBytes) {\n      nacl.setPRNG(function(x, n) {\n        var i, v = crypto.randomBytes(n);\n        for (i = 0; i < n; i++) x[i] = v[i];\n        cleanup(v);\n      });\n    }\n  }\n})();\n\n})(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));\n","\n/**\n * For Node.js, simply re-export the core `util.deprecate` function.\n */\n\nmodule.exports = require('util').deprecate;\n","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__angular_common__;","module.exports = __WEBPACK_EXTERNAL_MODULE__angular_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__angular_forms__;","module.exports = __WEBPACK_EXTERNAL_MODULE__ng_bootstrap_ng_bootstrap__;","module.exports = require(\"assert\");;","module.exports = require(\"buffer\");;","module.exports = require(\"child_process\");;","module.exports = require(\"constants\");;","module.exports = require(\"crypto\");;","module.exports = require(\"dns\");;","module.exports = require(\"events\");;","module.exports = __WEBPACK_EXTERNAL_MODULE_fs__;","module.exports = require(\"http\");;","module.exports = require(\"https\");;","module.exports = require(\"net\");;","module.exports = require(\"os\");;","module.exports = require(\"path\");;","module.exports = require(\"querystring\");;","module.exports = __WEBPACK_EXTERNAL_MODULE_rxjs__;","module.exports = require(\"stream\");;","module.exports = require(\"string_decoder\");;","module.exports = __WEBPACK_EXTERNAL_MODULE_tabby_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE_tabby_settings__;","module.exports = __WEBPACK_EXTERNAL_MODULE_tabby_terminal__;","module.exports = require(\"tty\");;","module.exports = require(\"url\");;","module.exports = __WEBPACK_EXTERNAL_MODULE_util__;","module.exports = require(\"zlib\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/index.ts\");\n"],"sourceRoot":""}